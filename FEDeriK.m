(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
FunctionalD[expr_,v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=Internal`InheritedBlock[{f,GammaN,Propagator,nonConst},

nonConst={f,GammaN,Propagator};

(*Rule for normal functional derivatives*)
f/:D[f[x_],f[y_],NonConstants->nonConst]:=\[Gamma][-y,x];
(*Ignore fields without indices. These are usually tags*)
f/:D[f,f[y_],NonConstants->nonConst]:=0;(*\[Delta][#,y]&;*)

Unprotect[GammaN,Propagator];

(*Derivative rule for GammaN*)
GammaN/:D[GammaN[{a__},{b__}],f[y_],NonConstants->nonConst]:=GammaN[{f,a},{y,b}];

(*Derivative rule for Propagators*)
Propagator/:D[Propagator[{b_,a_},{ib_,ia_}],f[if_],NonConstants->nonConst]:=Module[
{ic,id,ie},
Propagator[{b,AnyField},{ib,ic}]GammaN[{f,AnyField,AnyField},{-if,-ic,-id}]Propagator[{AnyField,a},{id,ie}]
(-1)\[Gamma][ia,-ie]
];

Protect[GammaN,Propagator];

D[expr,v,NonConstants->nonConst]
];


(* ::Input::Initialization:: *)
$CanonicalOrdering="f>af>b";
$AvailableCanonicalOrderings={"f>af>b","af>f>b","b>f>af","b>af>f"};

CanonicalOrdering::unknownInteger="The integer `1` should be between 1 and 4.";
CanonicalOrdering::unknownString="The expression `1` should be one of "<>ToString[$AvailableCanonicalOrderings];

SetCanonicalOrdering[a_Integer]:=Module[{},
Switch[a,
1,$CanonicalOrdering="f>af>b",

2,$CanonicalOrdering="af>f>b",

3,$CanonicalOrdering="b>f>af",

4,$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownInteger,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];

SetCanonicalOrdering[a_]:=Module[{},
Switch[a,
"f>af>b",$CanonicalOrdering="f>af>b",

"af>f>b",$CanonicalOrdering="af>f>b",

"b>f>af",$CanonicalOrdering="b>f>af",

"b>af>f",$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownString,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];


(* ::Input::Initialization:: *)
(*Returns true if f1 < f2, and false if f1 > f2*)
FieldOrderLess[setup_,f1_Symbol,f2_Symbol]:=Module[
{kind1,kind2,
idxHigh,idxMid,idxLow,
lessLow,lessMid,lessHigh},

kind1={IsFermion[setup,#],IsAntiFermion[setup,#],IsBoson[setup,#]}&[f1];
kind2={IsFermion[setup,#],IsAntiFermion[setup,#],IsBoson[setup,#]}&[f2];

Switch[$CanonicalOrdering,
"f>af>b",
idxHigh=1;
idxMid=2;
idxLow=3;
,

"af>f>b",
idxHigh=2;
idxMid=1;
idxLow=3;
,

"b>f>af",
idxHigh=3;
idxMid=1;
idxLow=2;
,

"b>af>f",
idxHigh=3;
idxMid=2;
idxLow=1;
,
_,
Print["Order failure: order \""<>$CanonicalOrdering<>"\" unknown."];
Abort[];
];

lessLow=kind1[[idxLow]]&&Not[kind2[[idxLow]]];
lessMid=kind1[[idxMid]]&&kind2[[idxHigh]];
lessHigh=False;
If[lessLow||lessMid||lessHigh,Return[True]];

Return[False]
];


(* ::Input::Initialization:: *)
(*Returns the sign that results from exchanging the two fields f1 and f2*)
CommuteSign[setup_,f1_,f2_]:=Module[
{kind1,kind2},

kind1={IsGrassmann[setup,#],IsBoson[setup,#]}&[f1];
kind2={IsGrassmann[setup,#],IsBoson[setup,#]}&[f2];

Return[If[kind1[[1]]&&kind2[[1]],-1,1]];
];


(* ::Input::Initialization:: *)
(*Find all instances of $OrderedObjects and order their field value according to the canonical scheme*)
$OrderedObjects={Propagator,GammaN};
OrderObject[setup_,expr_]:=expr;
OrderObject[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{i,j,curi,prefactor,pref,reverse,
nfields=fields,nindices=indices,
trackedField},

(*The propagator gets a reverse ordering*)
reverse=If[obj===Propagator,True,False];
pref=If[reverse,Identity,Not];
prefactor=1;

(*Always compare the ith field with all previous fields and put it in the right place.
Iterate until one reaches the end of the array, then it is sorted.*)
For[i=1,i<=Length[nfields],i++,
curi=i;
(*Check if we should switch curi and curi-1*)
While[curi>=2&&pref@FieldOrderLess[setup,nfields[[curi]],nfields[[curi-1]]],
nfields[[{curi,curi-1}]]=nfields[[{curi-1,curi}]];
nindices[[{curi,curi-1}]]=nindices[[{curi-1,curi}]];
prefactor*=CommuteSign[setup,nfields[[curi]],nfields[[curi-1]]];
curi--;
];
];

Return[prefactor*obj[nfields,nindices]];
];
OrderEquation[setup_,expr_]:=Map[OrderObject[setup,#]&,expr,{1,3}];


(* ::Input::Initialization:: *)
(*Compatibility: Output any expression in a Form which looks like QMeS output*)
QMeSNaming[setup_,expr_]:=expr;
QMeSNaming[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{oldCanonicalOrdering,transf,prefactor,
mobj,mfields,mindices,
prefix,fieldPart,indexPart},

(*QMeS follows b>af>f, so we switch temporarily!*)
Block[{$CanonicalOrdering},
$CanonicalOrdering="b>af>f";
transf=OrderObject[setup,obj[fields,indices]];
];

prefactor=1;
If[MatchQ[transf,Times[-1,a_]],prefactor=-1;transf=-transf;];
mobj=Head[transf];
mfields=(List@@transf)[[1]];
mindices=(List@@transf)[[2]];

prefix=Switch[obj,
Propagator,"G",
GammaN,"\[CapitalGamma]"
];
fieldPart=StringJoin[Map[ToString,mfields]];
indexPart=Flatten[mindices];
Return[prefactor*Symbol[prefix<>fieldPart][indexPart]];
];
QMeSForm[setup_,expr_]:=Map[QMeSNaming[setup,#]&,expr,{1,3}];
QMeSForm[Setup,#]&[{{GammaN[{A,cb,c},{x,y,z}]A[c]GammaN[{c,cb,c,cb},{x,y,z,k}]}}]


(* ::Input::Initialization:: *)
IsValidSetup[setup_]:=Module[{valid=True},
valid=valid&&Head[setup]===Association;
If[Not@valid,Print["A valid setup must be an Association!"];Return[valid]];

valid=valid&&MemberQ[Keys[setup],"FieldSpace"];
If[Not@valid,Print["A valid setup must have the key \"FieldSpace\"!"];Return[valid]];

valid=valid&&IsValidFieldDefinition[setup["FieldSpace"]];
If[Not@valid,Print["A valid setup must have the a valid \"FieldSpace\"!"];Return[valid]];

Return[valid];
];


(* ::Input::Initialization:: *)
(*Get the field definition with its kind from the setup, for the field named fieldName.*)
GetFieldDefinition[setup_,fieldName_]:=Module[{def,sig,pick},
If[IsGrassmann[setup,fieldName],
def=setup["FieldSpace"]["fermionic"];
If[IsFermion[setup,fieldName],
pick=Map[Head[#]===fieldName&,def[[All,2]]];
Return[Pick[def[[All,2]],pick][[1]]],
pick=Map[Head[#]===fieldName&,def[[All,1]]];
Return[Pick[def[[All,1]],pick][[1]]]
];
Print[pick];
];

def=setup["FieldSpace"]["bosonic"];
pick=Map[Head[#]===fieldName&,def];
pick=Pick[def,pick];
If[Length[pick]===0,Print["Field \"",fieldName,"\" not found!"];Abort[]];
Return[pick[[1]]]
];


(* ::Input::Initialization:: *)
(*See if a field is included in the setup, and if it has the correct index structure.*)
SetupHasField[setup_,field_]:=Module[{head,body,template,templateBody},
If[Not@IsValidField[field],Print["A valid field has the shape f_[p_,{___}], which is not fulfilled for \"",field,"\"!"];Return[False]];

head=Head[field];
body=List@@field;
template=GetFieldDefinition[setup,head];
templateBody=List@@template;

(*Check if the body structure is generally correct*)
If[Length[body]>2||Length[body]==0||Head[body[[1]]]===List,
Print["The body \"",body,"\" of the field \"",field,"\" is wrongly formatted!"];Return[False]
];

(*Check the group index structure, if there is any*)
If[Length[body]==2,
If[Head[body[[2]]]=!=List,
Print["The body \"",body,"\" of the field \"",field,"\" is wrongly formatted!"];Return[False]
];

If[Length[body[[2]]]=!=Length[templateBody[[2]]],
Print["The body \"",body,"\" of the field \"",field,"\"  does not match the template \"",templateBody,"\"!"];Return[False]
];
];

(*Check if the group index structure is missing*)
If[Length[body]==1&&Length[templateBody]==2,
Print["The body \"",body,"\" of the field \"",field,"\"  does not match the template \"",templateBody,"\"!"];Return[False]
];

Return[True];
];


(* ::Input::Initialization:: *)
(*Check a derivative list for correct formatting.*)
IsValidDerivativeList[setup_,derivativeList_]:=Module[{valid=True},
valid=valid&&Head[derivativeList]===List;
If[Not@valid,Print["A valid derivativeList must be an List!"];Return[valid]];

valid=valid&&AllTrue[derivativeList,IsValidField];
If[Not@valid,Print["A valid derivativeList must be an List of fields f_[p_,{___}]!"];Return[valid]];

valid=valid&&AllTrue[derivativeList,SetupHasField[setup,#]&];
If[Not@valid,Print["A valid derivativeList must be an List of fields f_[p_,{___}]!"];Return[valid]];

Return[valid];
];


(* ::Input::Initialization:: *)
IsValidField[field_]:=MatchQ[field,_Symbol[_,{__Symbol}]]||MatchQ[field,_Symbol[_]];

IsValidFieldDefinition[fields_Association]:=Module[{valid=True},
valid=valid&&Keys[fields]==={"bosonic","fermionic"};
If[Not@valid,Print["fields must contain the two keys {\"bosonic\",\"fermionic\"}!"];Return[valid]];

valid=valid&&ListQ[fields["bosonic"]];
If[Not@valid,Print["fields[\"bosonic\"] must be a list!"];Return[valid]];
valid=valid&&(And@@Map[IsValidField,fields["bosonic"]]);
If[Not@valid,Print["fields[\"bosonic\"] must contain valid fields!"];Return[valid]];

valid=valid&&ListQ[fields["fermionic"]];
If[Not@valid,Print["fields[\"fermionic\"] must be a list!"];Return[valid]];
valid=valid&&(And@@Map[ListQ,fields["fermionic"]]);
valid=valid&&(And@@Map[Length[#]===2&,fields["fermionic"]]);
If[Not@valid,Print["fields[\"fermionic\"] must contain pairs of fields!"];Return[valid]];
valid=valid&&(And@@Map[List@@(#[[1]])===List@@(#[[2]])&,fields["fermionic"]]);
If[Not@valid,Print["fields[\"fermionic\"] must contain pairs of fields with identical indices!"];Return[valid]];
valid=valid&&(And@@Map[IsValidField,Flatten[fields["fermionic"]]]);
If[Not@valid,Print["fields[\"fermionic\"] must contain valid fields!"];Return[valid]];

Return[valid];
];


(* ::Input::Initialization:: *)
IsValidTerm[expr_]:=Module[{valid=True},
valid=valid&&Head[expr]===List;
valid=valid&&Length[expr]>0;
If[Not@valid,Print["Terms are non-empty lists!"];Return[valid]];

valid=valid&&(And@@Map[Head[#]=!=List&,expr]);
If[Not@valid,Print["Terms are lists of non-lists!"];Return[valid]];

Return[valid];
];
IsTerm[expr_]:=Module[{valid=True},
Return[
Block[{Print},IsValidTerm[expr]]
];
];


(* ::Input::Initialization:: *)
IsValidMasterEq[masterEq_List]:=Module[{valid=True},
valid=Length[masterEq]>0;
valid=valid&&(And@@Map[ListQ,masterEq]);
If[Not@valid,Print["MasterEq must be a list of lists!"];Return[valid]];

valid=valid&&(And@@Map[(Length[#]>0)&,masterEq]);
If[Not@valid,Print["MasterEq must be a list of lists with length > 0!"];Return[valid]];

valid=valid&&(And@@Map[IsValidTerm,masterEq]);
If[Not@valid,Print["MasterEq must be a list of valid terms!"];Return[valid]];

Return[valid];
];
IsMasterEq[expr_]:=Module[{valid=True},
Return[
Block[{Print},IsValidMasterEq[expr]]
];
];


(* ::Input::Initialization:: *)
GetAllObjectsWithIndex[setup_Association,expr_]:=Module[{
fields,extracted,indices,
flattened,objects
},

fields=GetAllFieldsWithIndex[setup,expr];
indices={};
fields//._[\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)]:>(AppendTo[indices,a];1)//._[\!\(\*
TagBox[
StyleBox["a_Symbol",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)]:>(AppendTo[indices,a];1);
expr//.{
ABasis[{f__},{\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];ABasis[{f},{b}]),
ABasis[{f__},{\!\(\*
TagBox[
StyleBox["a_Symbol",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];ABasis[{f},{b}])
};
expr//.{
VBasis[{f__},{\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];VBasis[{f},{b}]),
VBasis[{f__},{\!\(\*
TagBox[
StyleBox["a_Symbol",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];VBasis[{f},{b}])
};
expr//.{
\[Delta][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Delta][b]),
\[Delta][a_Symbol,b___]:>(AppendTo[indices,a];\[Delta][b])
};
expr//.{
\[Gamma][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Delta][b]),
\[Gamma][a_Symbol,b___]:>(AppendTo[indices,a];\[Delta][b])
};

indices=DeleteDuplicates[indices];
If[IsTerm[expr],
flattened=Times@@expr;

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[{b},indices\[Union](-indices)]&&a=!=Times:>(AppendTo[objects,a[b]];1);

Return[objects];
];
If[IsMasterEq[expr],
flattened=Times@@(Join@@expr);

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[{b},indices\[Union](-indices)]&&a=!=Times:>(AppendTo[objects,a[b]];1);
Return[objects];
];

Print["Expression \"",expr,"\" is neither a term nor a master equation!"];Abort[];
];


(* ::Input::Initialization:: *)
(*Get a list of all unique super-indices within the expression expr*)
GetAllSuperIndices[setup_,expr_]:=Module[{fields,indices},
fields=GetAllObjectsWithIndex[setup,expr];
indices={};
fields//._[Times[-1,a_]]:>(AppendTo[indices,a];1)//._[a_]:>(AppendTo[indices,a];1);
Return[indices//DeleteDuplicates];
];

(*Get a list of all open super-indices within the expression expr*)
GetOpenSuperIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=GetAllObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
pick=Table[If [Mod[count[[i]],2]==0,False,True],{i,1,Length[indices]}];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Abort[]];

Return[Pick[indices,pick]];
];

(*Get a list of all closed super-indices within the expression expr*)
GetClosedSuperIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=GetAllObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Abort[]];

pick=Table[If [Mod[count[[i]],2]!=0,False,True],{i,1,Length[indices]}];
Return[Pick[indices,pick]];
];

(*Get a list of all open super-indices within the expression expr*)
TermSuperIndicesValid[setup_,expr_]:=Module[{objects,indices,count},
objects=GetAllObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Return[False]];
Return[True];
];


(* ::Input::Initialization:: *)
(*Check whether all indices are closed within expr. 
This disallows also multiple use of a single index name, !anywhere!*)
AllIndicesClosed[setup_,expr_]:=Module[{objects,indices,count,valid},
objects=GetAllObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
valid=AllTrue[count,#==2&];
Return[valid];
];


(* ::Input::Initialization:: *)
GetBosons[setup_Association]:=Map[Head,setup["FieldSpace"]["bosonic"]];
GetFermionPairs[setup_Association]:=Map[{Head[#[[1]]],Head[#[[2]]]}&,setup["FieldSpace"]["fermionic"]];
GetFermions[setup_Association]:=Map[Head[#[[2]]]&,setup["FieldSpace"]["fermionic"]];
GetAntiFermions[setup_Association]:=Map[Head[#[[1]]]&,setup["FieldSpace"]["fermionic"]];

IsFermion[setup_Association,field_]:=MemberQ[GetFermions[setup],field,Infinity];
IsFermion[setup_Association,field_[__]]:=IsFermion[setup,field];

IsAntiFermion[setup_Association,field_]:=MemberQ[GetAntiFermions[setup],field,Infinity];
IsAntiFermion[setup_Association,field_[__]]:=IsAntiFermion[setup,field];

IsBoson[setup_Association,field_]:=MemberQ[GetBosons[setup],field,Infinity];
IsBoson[setup_Association,field_[__]]:=IsBoson[setup,field];

IsGrassmann[setup_Association,field_]:=IsFermion[setup,field]||IsAntiFermion[setup,field];
IsGrassmann[setup_Association,field_[__]]:=IsGrassmann[setup,field];


(* ::Input::Initialization:: *)
GetPartnerField[setup_Association,field_]:=Module[{fermions,bosons,sel},
fermions=GetFermionPairs[setup];
bosons=GetBosons[setup];

If[MemberQ[fermions,field,Infinity],
sel=Select[fermions,MemberQ[#,field,Infinity]&][[1]];
sel=DeleteCases[sel,field];
Return[sel[[1]]];
];

If[MemberQ[bosons,field,Infinity],
Return[field]
];

Print["field ",field," not found!"];Abort[];
];


(* ::Input::Initialization:: *)
exclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power}
GetAllSymbols[expr_]:=DeleteDuplicates@Cases[Flatten[{expr}//.Times[a_,b__]:>{a,b}/.a_Symbol[b__]/;exclusions[a]:>{a,b}],_Symbol,Infinity]


(* ::Input::Initialization:: *)
GetAllFields[setup_Association,expr_]:=Module[{symbols},
symbols=GetAllSymbols[expr];
Return@Select[symbols,(IsFermion[setup,#]||IsAntiFermion[setup,#]||IsBoson[setup,#])&];
];
GetAllFieldsWithIndex[setup_Association,expr_]:=Module[{fields,extracted},
fields=GetAllFields[setup,expr];
extracted={};
expr//.{a_[b_]/;MemberQ[fields,a]:>(AppendTo[extracted,a[b]];1)};
Return[extracted]
];
ContainsGrassmann[setup_Association,expr_]:=Module[{fields},
fields=GetAllFields[setup,expr];
Return[
AnyTrue[fields,IsGrassmann[setup,#]&]
];
]
GrassmannCount[setup_Association,expr_]:=Module[{fields},
fields=GetAllFieldsWithIndex[setup,expr];
Return[Length@
Select[fields,IsGrassmann[setup,Head[#]]&]
];
]


(* ::Input::Initialization:: *)
(*Given a user-defined term or master equation, give all (closed) indices unique names.*)
FixIndices[setup_Association,expr_]:=Module[{
indices,newIndices,replacements,indexedObjects
},
If[IsMasterEq[expr],
Return[FixIndices[setup,#]&/@expr];
];
If[IsTerm[expr],
If[Not@TermSuperIndicesValid[setup,expr],Abort[]];

indices=GetClosedSuperIndices[setup,expr];
newIndices=Map[Unique[ToString[#]]&,indices];
replacements=Thread[indices->newIndices];

Return[expr/.replacements];
];

Print["Expression \"",expr,"\" is neither a term nor a master equation!"];Abort[];
];


(* ::Input::Initialization:: *)
Unprotect[FEq,FTerm];
ClearAll[FEq,FTerm];

(*Sum splitting of functional terms*)
FEq[preEq___,FTerm[preTerm___,Plus[a_,b__],postTerm___],postEq___]:=FEq[preEq,FTerm[preTerm,a,postTerm],FTerm[preTerm,Plus[b],postTerm],postEq]

(*Sums of functional Equations*)
FEq/:Plus[preEq___,FEq[terms1___],midEq___,FEq[terms2___],postEq___]:=Plus[preEq,midEq,postEq,FEq[terms1,terms2]]

Protect[FEq,FTerm];


(* ::Input::Initialization:: *)
FTermQ[expr_]:=Head[expr]===FTerm;
FTerm::notFTerm="The term `1` is not an FTerm.";
AssertFTerm[expr_]:=If[Not@FTermQ[expr],Message[FTerm::notFTerm,expr];Abort[]];

FEqQ[expr_]:=Head[expr]===FEq;
FEq::notFEq="The term `1` is not an FEq.";
AssertFEq[expr_]:=If[Not@FEqQ[expr],Message[FEq::notFEq,expr];Abort[]];


(* ::Input::Initialization:: *)
(* Simplify a term appearing in an equation. Remove all parts that are multiplied with 0 and try to merge as many factors as possible, while not changing the Grassmann structure of the term.
Returns {0} if the term is trivial.
*)
ReduceTerm[setup_,term_]:=Module[{reduced=term,mergeGrassmanFactors,i},
If[Not@IsValidTerm[reduced],Print[reduced," is not a valid term!"];Abort[]];

If[MemberQ[term,Plus[a_,b__],Infinity],Print[reduced," is not a valid term! A term cannot contain a Plus[___]. Use expandTerm before reducing it."];Abort[]];

If[Length[reduced]===0,Return[{0}]];
If[MemberQ[reduced,0],Return[{0}]];

(*Merge scalar terms with the closest Grassman term*)
If[GrassmannCount[setup,reduced[[1]]]>1,Print["Grassmann count is > 1, error!"];Abort[]];
While[(GrassmannCount[setup,reduced[[1]]]===0)&&Length[reduced]>1,
reduced=Join[{reduced[[1]]*reduced[[2]]},reduced[[3;;]]];
];

i=2;
While[i<=Length[reduced],
If[GrassmannCount[setup,reduced[[i]]]>1,Print["Grassmann count is > 1, error!"];Abort[]];
If[GrassmannCount[setup,reduced[[i]]]==0,
reduced=Join[reduced[[;;i-2]],{reduced[[i]]*reduced[[i-1]]},reduced[[i+1;;]]];
,
i++;
];
];

reduced=OrderEquation[setup,term];

Return[reduced];
];


(* ::Input::Initialization:: *)
(* Split the expression either in a list (if it has a Plus) or return it without change *)
splitPlus[expr_]:=Module[{ret},
ret=expr//.Plus[a_,b__]:>List[a,b];

Return[
If[Head[expr]===List,
Flatten[ret],
ret
]
];
];
expandTerm[expr_]:=Module[{factors={},newTerms},
If[Not@IsValidTerm[expr],Print[expr," is not a term!"];Abort[]];

(*Split all parts of the term into factors, i.e. either the element itself (no Plus inside the part) or a list (containing the sum)*)
factors=Map[splitPlus,expr];

(*Start the iteration for the expansion: If the first factor is an element, we start with a single term. Otherwise, the parts of the sum split into new terms.*)
newTerms=If[Head[factors[[1]]]===List,List/@factors[[1]],{{factors[[1]]}}];
factors=Delete[factors,1];

(*Iterate. Simply append elements and if a split occurs, generate new terms. Pop the factors from the start point after each iteration, until no more factors exist.*)
While[Length[factors]>0,
If[
Head[factors[[1]]]===List,
newTerms=Join@@Table[
Map[Append[#,factors[[1,i]]]&,newTerms]
,{i,1,Length[factors[[1]]]}
]
,
newTerms=Map[Append[#,factors[[1]]]&,newTerms];
];
factors=Delete[factors,1];
];

Return[newTerms]
];


(* ::Input::Initialization:: *)
ReduceEquation[setup_,equation_]:=Module[
{reduced=equation},

(*Split all Plus[__]*)
reduced=Join@@(expandTerm/@reduced);

(*Make sure all terms are reduced*)
reduced=ReduceTerm[setup,#]&/@reduced;

(*Remove all terms that are 0*)
reduced=Select[reduced,#=!={0}&];

If[Length[reduced]===0,Return[{{0}}]];

(*Amend the index structure*)
reduced=FixIndices[setup,reduced];

Return[reduced];
];


(* ::Input::Initialization:: *)
(* Perform a single functional derivative on a term.*)
TermDerivative[setup_,term_,field_]:=Module[{newTerms,prefactor,splitTerms},
(*Simplify the input and copy it as many times as the product rule will be applied*)
newTerms=ReduceTerm[setup,term];
newTerms=Table[newTerms,{i,1,Length[term]}];

(*Perform the product rule. Each factor in the term contains one Grassmann, so appropriately add the minus signs*)
Do[
prefactor=If[IsGrassmann[setup,field],(-1)^(i+1),1];
newTerms[[i,i]]=prefactor FunctionalD[newTerms[[i,i]],field],
{i,1,Length[term]}
];

Return[newTerms];
];

(* Perform a single functional derivative on an equation.*)
EquationDerivative[setup_,equation_,field_]:=Module[
{newTerms},
If[Not@IsMasterEq[equation],Print["The expression \"",equation,"\" is not a master equation!"];Abort[]];

(*Take derivatives of all terms in the equation*)
newTerms=TermDerivative[setup,#,field]&/@equation;
(*A term derivative yields an equation; join these equations to obtain the full equation*)
newTerms=Join@@newTerms;

(*Simplify the resulting equation*)
Return[ReduceEquation[setup,newTerms]];
];


(* ::Input::Initialization:: *)


(* Perform a single functional derivative on a term.*)
TermDerivative[setup_,term_,field_]:=Module[{newTerms,prefactor,splitTerms},
If[Not@FEqQ[term],Message[FEq::notFEq,term];Abort[]];

(*Simplify the input and copy it as many times as the product rule will be applied*)
newTerms=ReduceTerm[setup,term];
newTerms=Table[newTerms,{i,1,Length[term]}];

(*Perform the product rule. Each factor in the term contains one Grassmann, so appropriately add the minus signs*)
Do[
prefactor=If[IsGrassmann[setup,field],(-1)^(i+1),1];
newTerms[[i,i]]=prefactor FunctionalD[newTerms[[i,i]],field],
{i,1,Length[term]}
];

Return[newTerms];
];

(* Perform a single functional derivative on an equation.*)
EquationDerivative[setup_,equation_,field_]:=Module[
{newTerms},
If[Not@IsMasterEq[equation],Print["The expression \"",equation,"\" is not a master equation!"];Abort[]];

(*Take derivatives of all terms in the equation*)
newTerms=TermDerivative[setup,#,field]&/@equation;
(*A term derivative yields an equation; join these equations to obtain the full equation*)
newTerms=Join@@newTerms;

(*Simplify the resulting equation*)
Return[ReduceEquation[setup,newTerms]];
];


(* ::Input::Initialization:: *)
Protect[OutputLevel,SuperIndexForm];
Options[DeriveFunctionalEquation]={OutputLevel->SuperIndexForm};


(* ::Input::Initialization:: *)
(* Perform multiple functional derivatives on a master equation.*)
DeriveFunctionalEquation[setup_,expr_,derivativeList_,OptionsPattern[]]:=Module[
{result,
externalIndexNames,outputReplacements,
derivativeListSIDX
},

If[Not@IsValidSetup[setup],Print["The expression \"",setup,"\" is not a valid setup!"];Abort[]];
If[Not@IsValidMasterEq[expr],Print["The expression \"",expr,"\" is not a master equation!"];Abort[]];
If[Not@IsValidDerivativeList[setup,derivativeList],Print["The expression \"",derivativeList,"\" is not a derivative list!"];Abort[]];

(*While doing the derivatives, we want to use super-indices. Afterwards, we can replace these again with the given indices*)
externalIndexNames=Map[Unique["eI"]&,derivativeList];
outputReplacements=Thread[externalIndexNames->Map[FieldIndices@@Join[Head[#],List@@#]&,derivativeList]];
derivativeListSIDX=Table[Head[derivativeList[[i]]][externalIndexNames[[i]]],{i,1,Length[derivativeList]}];

(*We take them in reverse order.*)
derivativeListSIDX=Reverse[derivativeListSIDX];

(*First, fix the indices in the input equation, i.e. make everything have unique names*)
result=FixIndices[setup,expr];
(*Perform all the derivatives, one after the other*)
Do[
result=EquationDerivative[setup,result,derivativeListSIDX[[pass]]]
,
{pass,1,Length[derivativeList]}
];

If[OptionValue[OutputLevel]===SuperIndexForm,
Return[ {result,outputReplacements}];
];

Return[result//.outputReplacements];
];

DeriveFunctionalEquation[Setup,{{c[x],GammaN[{c,cb},{x,y}]c[y]}},{c[-f,{a}],cb[f,{a}]}]



