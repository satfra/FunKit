(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
$OrderedObjects={Propagator,GammaN,Rdot};
$indexedObjects={ABasis,VBasis,GammaN,Propagator,Rdot};
$MaxDerivativeIterations=500;
$CanonicalOrdering="f>af>b";


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
Unprotect[FTerm];
ClearAll[FTerm];

FTimesPowerPatternaToFTermb=\!\(\*
TagBox[
StyleBox[
RowBox[{"Power", "[", 
RowBox[{"a", ",", 
RowBox[{"FTerm", "[", "b_", "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);
FTimesPowerPatternFTermbtoa=\!\(\*
TagBox[
StyleBox[
RowBox[{"Power", "[", 
RowBox[{"a", ",", 
RowBox[{"FTerm", "[", "b_", "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);

FTerm::TimesError="An FTerm cannot be multiplied using Times[__]. To multiply FTerms, use term1**term2, also with scalars, a**term. Error in expression
`1`";
FTerm::FTermPowerError="An FTerm cannot be taken to a power of an FTerm.";

(*Multiplication of FTerms*)
FTerm/:NonCommutativeMultiply[FTerm[a__],FTerm[b__]]:=FTerm[a,b]
FTerm[]:=FTerm[1]

(*Pre-reduction of zero FTerms*)
FTerm[___,0,___]:=FTerm[0]
FTerm[pre___,a_,b:(_Integer|_Real|_Rational|_Complex),post___]:=FTerm[pre,a*b,post]
FTerm[a:(_Integer|_Real|_Rational|_Complex),b_,post___]:=FTerm[a*b,post]

(*Reduction of immediately nested FTerms*)
FTerm[pre___,FTerm[in__],post___]:=FTerm[pre,in,post] 

FTerm/:Power[FTerm[a___],FTerm[b___]]:=(Message[FTerm::FTermPowerError];Abort[]);

Protect[FTerm];


(* ::Input::Initialization:: *)
Unprotect[FEq];
ClearAll[FEq];

FEq::TimesError="A FEq cannot be multiplied using Times[__]. To multiply FEqs, use eq1**eq2, also with scalars, a**eq. Error in expression
`1`";

(*Removal of zero FTerms*)
FEq[pre___,FTerm[___,0,___],post___]:=FEq[pre,post]
FEq[pre___,FTerm[],post___]:=FEq[pre,post]

(*Sum splitting of FTerms*)
FEq[preEq___,FTerm[preTerm___,Plus[a_,b__],postTerm___],postEq___]:=FEq[preEq,FTerm[preTerm,a,postTerm],FTerm[preTerm,Plus[b],postTerm],postEq]

(*Sums of FTerms*)
FEq[preEq___,Plus[FTerm[a__],FTerm[b__],c___],postEq___]:=FEq[preEq,FTerm[a],Plus[FTerm[b],c],postEq]
FEq/:Plus[FEq[a___],FTerm[b__]]:=FEq[a,FTerm[b]]

(*Sums of FEqs*)
FEq/:Plus[preEq___,FEq[terms1___],midEq___,FEq[terms2___],postEq___]:=Plus[preEq,midEq,postEq,FEq[terms1,terms2]]

(*Multiplication of FEqs*)
FEq/:Times[pre___,FEq[a__],post___]:=(Message[FEq::TimesError,{pre,FEq[a],post}];Abort[])
FEq[prefeq__,Times[pre___,FTerm[a__],post___],postfeq__]:=(Message[FTerm::TimesError,{pre,FTerm[a],post}];Abort[])

FEq/:NonCommutativeMultiply[FTerm[b__],FEq[c__]]:=FEq[Map[FTerm[b]**#&,FEq[c]]]
FEq/:NonCommutativeMultiply[FEq[a__],FEq[b__]]:=FEq@@(Flatten@Table[FEq[{a}[[i]]**{b}[[j]]],{i,1,Length[{a}]},{j,1,Length[{b}]}])
FEq/:NonCommutativeMultiply[FTerm[b___],FEq[]]:=FEq[]
FEq/:NonCommutativeMultiply[FTerm[],FEq[b___]]:=FEq[]
FEq/:NonCommutativeMultiply[FTerm[0],FEq[b___]]:=FEq[]

(*Reduction of immediately nested FEqs*)
FEq[pre___,FEq[in___],post___]:=FEq[pre,in,post]
FEq[pre___,FTerm[],post___]:=FEq[pre,post]

Protect[FEq];


(* ::Input::Initialization:: *)
Unprotect[FDOp];
ClearAll[FDOp];

FDOp::invalidArgument="The argument \"`1`\" is not a valid argument for an FDOp. Only single fields with indices are allowed!";

FDOp[a_,b__]:=(Message[FDOp::invalidArgument,{a,b}];Abort[])

Protect[FDOp];


(* ::Input::Initialization:: *)
FExpand[expr_,order_Integer]:=Module[{ret=expr},
ret=ret//.Power[a_FTerm,b_]:>Series[a^b,{a,0,order}]//.Power[a_,b_FTerm]:>Series[a^b,{b,0,order}]//Normal;
ret=ret//.Power[FTerm[a__],b_Integer]/;b>0:>FTerm[a,FTerm[a]^(b-1)]
];


(* ::Input::Initialization:: *)
FTermQ[expr_]:=Head[expr]===FTerm;
FTerm::notFTerm="The term `1` is not an FTerm.";
AssertFTerm[expr_]:=If[Not@FTermQ[expr],Message[FTerm::notFTerm,expr];Abort[]];

FEqQ[expr_]:=Head[expr]===FEq;
FEq::notFEq="The term `1` is not an FEq.";
AssertFEq[expr_]:=If[Not@FEqQ[expr],Message[FEq::notFEq,expr];Abort[]];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldDefQ[expr_]:=Module[{},
If[Head[expr]===List,
If[Length[expr]=!=2,
Print["A field definition must be either of form f[x...] or {af[x...],f[x...]}. \"",expr,"\" does not fit."];Return[False]];

If[Head[expr[[1]]]===Head[expr[[2]]],
Print["A field definition {af[x...],f[x...]} must have different field names af and f. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(List@@(expr[[1]])===List@@(expr[[2]])),
Print["A field definition {af[x...],f[x...]} must have identical indices. \"",expr,"\" does not fit."];
Return[False]];

Do[
If[Not@(MatchQ[expr[[i]],_Symbol[_,{__Symbol}]]||MatchQ[expr[[i]],_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr[[i]],"\" does not fit."];
Return[False]],
{i,1,2}
];

Return[True];
];

If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

Return[True];
];

FieldDef::invalidFieldDefinition="The given field definition `1` is not valid.";

AssertFieldDef[expr_]:=If[Not@FieldDefQ[expr],
Message[FieldDefinition::invalidFieldDefinition];
Abort[]];


(* ::Input::Initialization:: *)
(* Check if a given field space definition is valid *)
FieldSpaceDefQ[fieldSpace_]:=Module[{},
If[Head[fieldSpace]=!=Association,Print["An FSetup must be an association"];Return[False]];

If[Not@(Keys[fieldSpace]==={"cField","Grassmann"}),
Print["fields must contain the two keys {\"cField\",\"Grassmann\"}!"];
Return[False]];

If[Not@ListQ[fieldSpace["cField"]],
Print["fields[\"cField\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["cField"]]),
Print["fields[\"cField\"] must contain valid fields!"];
Return[False]];

If[Not@ListQ[fieldSpace["Grassmann"]],
Print["fields[\"Grassmann\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["Grassmann"]]),
Print["fields[\"Grassmann\"] must contain valid fields!"];
Return[False]];

Return[True];
];

FieldSpaceDefinition::invalidFieldDefinition="The given field space definition is invalid.";

AssertFieldSpaceDef[fields_]:=If[Not@FieldSpaceDefQ[fields],
Message[FieldSpaceDefinition::invalidFieldDefinition];Abort[]];


(* ::Input::Initialization:: *)
FSetup::notFSetup="The given setup is not valid!";

FSetupQ[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Return[False]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Return[False]];

If[Not@FieldSpaceDefQ[setup["FieldSpace"]],
Return[False]];

Return[True];
];

AssertFSetup[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Message[FSetup::notFSetup];
Abort[]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Message[FSetup::notFSetup];
Abort[]];

AssertFieldSpaceDef[setup["FieldSpace"]];
];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldQ[setup_,expr_]:=Module[{},
If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(MemberQ[Map[Head,setup["FieldSpace"]//Values//Flatten],Head[expr]]),
Print["The field \"",expr,"\" is not contained in the field space."];
Return[False]];

Return[True];
];

Field::invalidField="The given field `1` does not exist.";

AssertField[setup_,expr_]:=If[Not@FieldQ[setup,expr],
Message[FieldDefinition::invalidField];
Abort[]];


(* ::Input::Initialization:: *)
(*Check a derivative list for correct formatting.*)
DerivativeListQ[setup_,derivativeList_]:=Module[{},

If[Not@(Head[derivativeList]===List),
Print["A valid derivativeList must be an List!"];
Return[False]];

If[Not@AllTrue[derivativeList,FieldQ[setup,#]&],
Print["A valid derivativeList must be an List of fields f_[p_,{___}] of f_[p_] which have been defined in the setup!"];
Return[False]];

Return[True];
];

DeriveEquation::invalidDerivativeList="The given derivativeList `1` is not valid.";

AssertDerivativeList[setup_,expr_]:=If[Not@DerivativeListQ[setup,expr],
Message[DeriveEquation::invalidDerivativeList];
Abort[]];


(* ::Input::Initialization:: *)
FDOpQ[setup_,expr_]:=(Head[expr]===FDOp)&&MatchQ[expr,(_[_,{__}]|_[_])]&&FieldQ[setup,#]&@@expr;

FDOp::invalid="`1` is not a valid FDOp.";

AssertFDOp[setup_,expr_]:=If[Not@FDOpQ[setup,expr],Message[FDOp::invalid,expr];Abort[]];



(* ::Input::Initialization:: *)
Protect[GammaN,Propagator,AnyField,ABasis,VBasis];


(* ::Input::Initialization:: *)
exclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power,a=!=Times}
GetAllSymbols[expr_]:=DeleteDuplicates@Cases[
Flatten[{expr}//.Times[a_,b__]:>{a,b}//.a_Symbol[b__]/;exclusions[a]:>{a,b}],
_Symbol,
Infinity]


(* ::Input::Initialization:: *)
FunctionalD::malformed="Cannot take a derivative of `1`. Expression is either malformed or this is a bug.";

ClearAll[FunctionalD]
FunctionalD[expr_,v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=Internal`InheritedBlock[
{f,GammaN,Propagator,nonConst,FTerm,FEq},

nonConst=Sort@{f,GammaN,Propagator,Power};

(*Rule for normal functional derivatives*)
f/:D[f[x_],f[y_],NonConstants->nonConst]:=\[Gamma][-y,x];
(*Ignore fields without indices. These are usually tags*)
f/:D[f,f[y_],NonConstants->nonConst]:=0;(*\[Delta][#,y]&;*)

Unprotect[GammaN,Propagator,FTerm,FEq];

(*Derivative rule for GammaN*)
GammaN/:D[GammaN[{a__},{b__}],f[if_],NonConstants->nonConst]:=GammaN[{f,a},{-if,b}];

(*Derivative rule for Propagators*)
Propagator/:D[Propagator[{b_,a_},{ib_,ia_}],f[if_],NonConstants->nonConst]:=Module[
{ic,id,ie},
Propagator[{b,AnyField},{ib,ic}]GammaN[{f,AnyField,AnyField},{-if,-ic,-id}]Propagator[{AnyField,a},{id,ie}]
(-1)\[Gamma][ia,-ie]
];

(*No derivatives of FTerm, FEq*)
FTerm/:D[FTerm[a___],f[y_],NonConstants->nonConst]:=(Message[FunctionalD::malformed,FTerm[a]];Abort[]);
FEq/:D[FEq[a___],f[y_],NonConstants->nonConst]:=(Message[FunctionalD::malformed,FEq[a]];Abort[]);

(*Chain rules*)
f/:D[g_[FTerm[a___]],f[y_],NonConstants->nonConst]:=(FTerm[g'[FTerm[a]]]**FTerm[FDOp[f[y]],a]);
f/:D[Power[FTerm[a___],b_],f[y_],NonConstants->nonConst]:=(FTerm[b,Power[FTerm[a],b-1]]**FTerm[FDOp[f[y]],a]);
f/:D[Power[a_,FTerm[b___]],f[y_],NonConstants->nonConst]:=(FTerm[Log[a],Power[a,FTerm[b]]]**FTerm[FDOp[f[y]],b]);

Protect[GammaN,Propagator,FTerm,FEq];

D[expr,v,NonConstants->nonConst]
];

FunctionalD::badArgumentFTerm="Cannot take derivative of an FTerm. Use DeriveFunctional instead.";
FunctionalD[FTerm[expr_],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFTerm];Abort[]);

FunctionalD::badArgumentFEq="Cannot take derivative of an FEq. Use DeriveFunctional instead.";
FunctionalD[FEq[___],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFEq];Abort[]);



(* ::Input::Initialization:: *)
GetcFields[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["cField"]
];
GetAnticFields[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["cField"]
],#=!={}&];

GetGrassmanns[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["Grassmann"]
];
GetAntiGrassmanns[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["Grassmann"]
],#=!={}&];


(* ::Input::Initialization:: *)
GetFieldPairs[setup_]:=Map[{Head[#[[1]]],Head[#[[2]]]}&,
Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]===List&
]
];

GetSingleFields[setup_]:=Map[Head[#]&,Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]=!=List&
]
];

GetAllFields[setup_]:=Join[Flatten@GetFieldPairs[setup],GetSingleFields[setup]];

HasPartnerField[setup_,field_]:=MemberQ[
Flatten@GetFieldPairs[setup],
field
];
HasPartnerField[setup_,field_[__]]:=HasPartnerField[setup,field];

IsGrassmann[setup_,field_]:=MemberQ[GetGrassmanns[setup],field,Infinity];
IsGrassmann[setup_,field_[__]]:=IsGrassmann[setup,field];

IsAntiGrassmann[setup_,field_]:=MemberQ[GetAntiGrassmanns[setup],field,Infinity];
IsAntiGrassmann[setup_,field_[__]]:=IsAntiGrassmann[setup,field];

IscField[setup_,field_]:=MemberQ[GetcFields[setup],field,Infinity];
IscField[setup_,field_[__]]:=IscField[setup,field];

IsAnticField[setup_,field_]:=MemberQ[GetAnticFields[setup],field,Infinity];
IsAnticField[setup_,field_[__]]:=IsAnticField[setup,field];


(* ::Input::Initialization:: *)
GetPartnerField[setup_,field_Symbol]:=Module[{pairs,sel},
If[Not@HasPartnerField[setup,field],Return[field]];

pairs=GetFieldPairs[setup];

sel=Select[pairs,MemberQ[#,field,Infinity]&][[1]];
sel=DeleteCases[sel,field];
If[Length[sel]>0,Return[sel[[1]]]];

Print["field ",field," not found!"];Abort[];
];
GetPartnerField[setup_,field_Symbol[i__]]:=GetPartnerField[setup,field][i]


(* ::Input::Initialization:: *)
ExtractFields[setup_Association,expr_]:=Module[{symbols},
symbols=GetAllSymbols[expr];
Return@Select[symbols,MemberQ[GetAllFields[setup],#]&];
];
ExtractFieldsWithIndex[setup_Association,expr_]:=Module[{fields,extracted},
fields=ExtractFields[setup,expr];
extracted={};
expr//.{a_[b_]/;MemberQ[fields,a]:>(AppendTo[extracted,a[b]];1)};
Return[extracted]
];


(* ::Input::Initialization:: *)
ContainsGrassmann[setup_Association,expr_]:=Module[{fields},
fields=ExtractFields[setup,expr];
Return[
AnyTrue[fields,IsGrassmann[setup,#]||IsAntiGrassmann[setup,#]&]
];
]
GrassmannCount[setup_Association,expr_]:=Module[{fields},
fields=ExtractFieldsWithIndex[setup,expr];
Return[Length@
Select[fields,IsGrassmann[setup,Head[#]]||IsAntiGrassmann[setup,Head[#]]&]
];
]


(* ::Input::Initialization:: *)
(*Get a list of all unique super-indices within the expression expr*)
GetAllSuperIndices[setup_,expr_]:=Module[{fields,indices,i,j},
fields=ExtractFieldsWithIndex[setup,expr];
indices={};
fields//.
p_[Times[-1,a_]]/;exclusions[p]:>(AppendTo[indices,a];1)//.
p_[a_]/;exclusions[p]:>(AppendTo[indices,a];1);

Do[
expr//.{
$indexedObjects[[i]][{f__},{\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", 
RowBox[{"a", ":", 
RowBox[{"(", 
RowBox[{"_Symbol", "|", "_Subscript", "|", "_Superscript"}], ")"}]}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];$indexedObjects[[i]][{f},{b}]),
$indexedObjects[[i]][{f__},{\!\(\*
TagBox[
RowBox[{"a", ":", 
RowBox[{"(", 
RowBox[{"_Symbol", "|", "_Subscript", "|", "_Superscript"}], ")"}]}],
FullForm]\),b___}]:>(AppendTo[indices,a];$indexedObjects[[i]][{f},{b}])
},
{i,1,Length[$indexedObjects]}
];
expr//.{
\[Delta][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", 
RowBox[{"a", ":", 
RowBox[{"(", 
RowBox[{"_Symbol", "|", "_Subscript", "|", "_Superscript"}], ")"}]}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Delta][b]),
\[Delta][a:(_Symbol|_Subscript|_Superscript),b___]:>(AppendTo[indices,a];\[Delta][b])
};
expr//.{
\[Gamma][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", 
RowBox[{"a", ":", 
RowBox[{"(", 
RowBox[{"_Symbol", "|", "_Subscript", "|", "_Superscript"}], ")"}]}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Gamma][b]),
\[Gamma][a:(_Symbol|_Subscript|_Superscript),b___]:>(AppendTo[indices,a];\[Gamma][b])
};
Return[indices//DeleteDuplicates];
];


(* ::Input::Initialization:: *)
ExtractObjectsWithIndex[setup_Association,expr_]:=Module[{
indices,flattened,objects
},
indices=GetAllSuperIndices[Setup,expr];

If[FTermQ[expr],
flattened=Times@@expr;

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[Flatten@{b},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[b]];1);

Return[objects];
];

If[FEqQ[expr],
flattened=Times@@(Join@@Map[List@@#&,expr]);

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[{b},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[b]];1);
flattened//.a_Symbol[{f__},{i__}]/;ContainsAny[{i},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[{f},{i}]];1);
Return[objects];
];

Print["Expression \"",expr,"\" is neither an FTerm nor an FEq!"];Abort[];
];


(* ::Input::Initialization:: *)
SuperIndices::undeterminedSums="There are indices with count > 2 in the expression
    `1`
This is not allowed for valid terms/equation. Problematic indices:
    `2`";

hideSubSuper[expr_]:=Module[{},
expr//.{
Subscript[a_Symbol,b_:(_Integer|_Symbol)]:>Symbol[ToString[a]<>"SUBSCRIPT"<>ToString[b]],
Superscript[a_Symbol,b_:(_Integer|_Symbol)]:>Symbol[ToString[a]<>"SUPERSCRIPT"<>ToString[b]]
}
];

(*Get a list of all open super-indices within the expression expr*)
GetOpenIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects//hideSubSuper,#,Infinity]&,indices//hideSubSuper];
pick=Table[If [Mod[count[[i]],2]==0,False,True],{i,1,Length[indices]}];

If[AnyTrue[count,#>2&],Message[SuperIndices::undeterminedSums,expr,Pick[indices,#>2&/@count]];Abort[]];

Return[Pick[indices,pick]];
];

(*Get a list of all closed super-indices within the expression expr*)
GetClosedSuperIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects//hideSubSuper,#,Infinity]&,indices//hideSubSuper];
If[AnyTrue[count,#>2&],Message[SuperIndices::undeterminedSums,expr,Pick[indices,#>2&/@count]];Abort[]];

pick=Table[If [Mod[count[[i]],2]!=0,False,True],{i,1,Length[indices]}];
Return[Pick[indices,pick]];
];

(*Get a list of all open super-indices within the expression expr*)
SuperIndicesValid[setup_,expr_]:=Module[{objects,indices,count},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects//hideSubSuper,#,Infinity]&,indices//hideSubSuper];
If[AnyTrue[count,#>2&],Message[SuperIndices::undeterminedSums,expr,Pick[indices,#>2&/@count]];Return[False]];
Return[True];
];


(* ::Input::Initialization:: *)
(*Check whether all indices are closed within expr. 
This disallows also multiple use of a single index name, !anywhere!*)
AllIndicesClosed[setup_,expr_]:=Module[{objects,indices,count,valid},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects//hideSubSuper,#,Infinity]&,indices//hideSubSuper];
valid=AllTrue[count,#==2&];
Return[valid];
];


(* ::Input::Initialization:: *)
$AvailableCanonicalOrderings={"f>af>b","af>f>b","b>f>af","b>af>f"};

CanonicalOrdering::unknownInteger="The integer `1` should be between 1 and 4.";
CanonicalOrdering::unknownString="The expression `1` should be one of "<>ToString[$AvailableCanonicalOrderings];

SetCanonicalOrdering[a_Integer]:=Module[{},
Switch[a,
1,$CanonicalOrdering="f>af>b",

2,$CanonicalOrdering="af>f>b",

3,$CanonicalOrdering="b>f>af",

4,$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownInteger,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];

SetCanonicalOrdering[a_]:=Module[{},
Switch[a,
"f>af>b",$CanonicalOrdering="f>af>b",

"af>f>b",$CanonicalOrdering="af>f>b",

"b>f>af",$CanonicalOrdering="b>f>af",

"b>af>f",$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownString,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];


(* ::Input::Initialization:: *)
(*Returns true if f1 < f2, and false if f1 > f2*)
FieldOrderLess[setup_,f1_Symbol,f2_Symbol]:=Module[
{kind1,kind2,
idxOrder,
n1,n2},

kind1={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#],#===AnyField}&[f1];
kind2={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#],#===AnyField}&[f2];

Switch[$CanonicalOrdering,
"f>af>b",
idxOrder={4,3,2,1,0},
"af>f>b",
idxOrder={3,4,1,2,0},
"b>f>af",
idxOrder={2,1,4,3,0},
"b>af>f",
idxOrder={1,2,3,4,0},
_,
Print["Order failure: order \""<>$CanonicalOrdering<>"\" unknown."];Abort[];
];

n1=Pick[idxOrder,kind1][[1]];
n2=Pick[idxOrder,kind2][[1]];

Return[n1<n2]
];


(* ::Input::Initialization:: *)
(*Returns the sign that results from exchanging the two fields f1 and f2*)
CommuteSign[setup_,f1_,f2_]:=Module[
{kind1,kind2},

kind1={IsGrassmann[setup,#]||IsAntiGrassmann[setup,#],IscField[setup,#]||IsAnticField[setup,#]}&[f1];
kind2={IsGrassmann[setup,#]||IsAntiGrassmann[setup,#],IscField[setup,#]||IsAnticField[setup,#]}&[f2];

Return[If[kind1[[1]]&&kind2[[1]],-1,1]];
];


(* ::Input::Initialization:: *)
(*Find all instances of $OrderedObjects and order their field value according to the canonical scheme*)
OrderObject[setup_,expr_]:=expr;
OrderObject[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{i,j,curi,prefactor,pref,reverse,
nfields=fields,nindices=indices,
trackedField},

(*The propagator gets a reverse ordering*)
reverse=If[obj===Propagator,True,False];
pref=If[reverse,Identity,Not];
prefactor=1;

(*Always compare the ith field with all previous fields and put it in the right place.
Iterate until one reaches the end of the array, then it is sorted.*)
For[i=1,i<=Length[nfields],i++,
curi=i;
(*Check if we should switch curi and curi-1*)
While[curi>=2&&pref@FieldOrderLess[setup,nfields[[curi]],nfields[[curi-1]]],
nfields[[{curi,curi-1}]]=nfields[[{curi-1,curi}]];
nindices[[{curi,curi-1}]]=nindices[[{curi-1,curi}]];
prefactor*=CommuteSign[setup,nfields[[curi]],nfields[[curi-1]]];
curi--;
];
];

Return[prefactor*obj[nfields,nindices]];
];
OrderFields[setup_,expr_]:=Map[OrderObject[setup,#]&,expr,Infinity];


(* ::Input::Initialization:: *)
(*Compatibility: Output any expression in a Form which looks like QMeS output*)
QMeSNaming[setup_,expr_]:=expr;
QMeSNaming[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{oldCanonicalOrdering,transf,prefactor,
mobj,mfields,mindices,
prefix,fieldPart,indexPart},

(*QMeS follows b>af>f, so we switch temporarily!*)
Block[{$CanonicalOrdering},
$CanonicalOrdering="b>af>f";
transf=OrderObject[setup,obj[fields,indices]];
];

prefactor=1;
If[MatchQ[transf,Times[-1,a_]],prefactor=-1;transf=-transf;];
mobj=Head[transf];
mfields=(List@@transf)[[1]];
mindices=(List@@transf)[[2]];

prefix=Switch[obj,
Propagator,"G",
GammaN,"\[CapitalGamma]"
];
fieldPart=StringJoin[Map[ToString,mfields]];
indexPart=Flatten[mindices];
Return[prefactor*Symbol[prefix<>fieldPart][indexPart]];
];
QMeSForm[setup_,expr_]:=Map[QMeSNaming[setup,#]&,expr,{1,3}]//.{FEq:>List,FTerm:>List};


(* ::Input::Initialization:: *)
(*Given a user-defined term or master equation, give all (closed) indices unique names.*)
FixIndices[setup_,expr_]:=Module[{
indices,newIndices,replacements,indexedObjects,
ret=expr
},
AssertFSetup[setup];

(*Indices should be fixed on a per-term basis to ensure we do not mess up things*)
If[FEqQ[ret],
Return[FixIndices[setup,#]&/@ret];
];

If[FTermQ[ret],
(*First, take care of nested sub-terms*)
ret=FTerm@@((List@@ret)/.FTerm[a__]:>FixIndices[setup,FTerm[a]]);

(*Now check if everything is alright*)
If[Not@SuperIndicesValid[setup,ret],Print["Invalid superindices: ",ret];Abort[]];

indices=GetClosedSuperIndices[setup,ret];
newIndices=Map[
Unique[
StringReplace[ToString[#],i:DigitCharacter..:>""]
]&,
indices];
replacements=Thread[indices->newIndices];

Return[ret/.replacements];
];

Print["Expression \"",expr,"\" is neither a term nor a master equation!"];Abort[];
];


(* ::Input::Initialization:: *)
FTerm::GrassmannCountError="The term `1` has a multiple Grassmanns in a single factor.";FTerm::GrassmannOpen="The term `1` has open Grassmann factors.";

(* Simplify a term appearing in an equation. Try to merge as many factors as possible, while not changing the Grassmann structure of the term.
*)
ReduceFTerm[setup_,term_]:=Module[{reduced=List@@term,mergeGrassmanFactors,i},
AssertFSetup[setup];
AssertFTerm[term];

(*Reduce nested FTerms and such first*)
reduced=reduced//.FEq[a__]:>ReduceFEq[setup,FEq[a]];
(*TODO: find a way to not reduce terms twice*)
reduced=reduced//.FTerm[a__]:>ReduceFTerm[setup,FTerm[a]];
(*TODO: Ensure that nested terms are Grassmann-neutral*)
reduced//.FTerm[a__]:>If[Mod[GrassmannCount[setup,FTerm[a]],2]=!=0,Message[FTerm::GrassmannOpen,FTerm[a]];Abort[]];

(*Merge scalar terms with the closest Grassman term. We need to "vanish" nested FTerms, to make sure we do not overcount.*)
If[GrassmannCount[setup,reduced[[1]]//.FTerm[__]:>1]>1,Message[FTerm::GrassmannCountError,term];Abort[]];
While[(GrassmannCount[setup,reduced[[1]]//.FTerm[__]:>1]===0&&
Length[reduced]>1&&
FreeQ[reduced[[1]],FDOp,Infinity]&&
FreeQ[reduced[[2]],FDOp,Infinity]),
reduced=Join[{reduced[[1]]*reduced[[2]]},reduced[[3;;]]];
];

i=2;
While[i<=Length[reduced],
If[GrassmannCount[setup,reduced[[i]]//.FTerm[__]:>1]>1,Message[FTerm::GrassmannCountError,term];Abort[]];
If[(GrassmannCount[setup,reduced[[i]]//.FTerm[__]:>1]==0&&
FreeQ[reduced[[i]],FDOp,Infinity]),
If[FreeQ[reduced[[i-1]],FDOp,Infinity],
reduced=Join[reduced[[;;i-2]],{reduced[[i]]*reduced[[i-1]]},reduced[[i+1;;]]],
i++
];
,
i++;
];
];
reduced=OrderFields[setup,reduced];

Return[FTerm@@reduced];
];


(* ::Input::Initialization:: *)
ReduceFEq[setup_,equation_]:=Module[
{reduced=equation},

AssertFSetup[setup];
AssertFEq[equation];

(*Amend the index structure*)
reduced=FixIndices[setup,reduced];

(*Make sure all terms are reduced*)
reduced=ReduceFTerm[setup,#]&/@reduced;

Return[reduced];
];


(* ::Input::Initialization:: *)
(*Resolve a single occurence of FDOp*)
ResolveFDOp[setup_,feq_FEq]:=Module[
{},
Return[FEq@@Map[ResolveFDOp[setup,#]&,List@@feq]];
];
ResolveFDOp[setup_,term_FTerm]:=Module[
{rTerm=ReduceFTerm[setup,term],
FDOpPos,
termsNoFDOp,dF,
dTerms,nPre,nPost},

(*If no derivatives are present, do nothing*)
If[FreeQ[rTerm,FDOp,Infinity],Return[rTerm]];

FDOpPos=Length[rTerm]-FirstPosition[Reverse@(List@@rTerm),FDOp[_]][[1]]+1;
termsNoFDOp=rTerm[[1;;FDOpPos-1]]**rTerm[[FDOpPos+1;;]];

(*If the derivative operator is trailing, simply remove it*)
If[FDOpPos>=Length[rTerm],Return[termsNoFDOp]];

dF=rTerm[[FDOpPos,1]];

(*Perform the product rule*)
nPre=FDOpPos-1;
nPost=Length[rTerm]-FDOpPos;
dTerms=Table[
termsNoFDOp[[;;nPre+idx-1]]**FTerm[(-1)^(idx+1) FunctionalD[termsNoFDOp[[nPre+idx]],dF]]**termsNoFDOp[[nPre+idx+1;;]],
{idx,1,nPost}
];

Return[ReduceFEq[setup,FEq@@dTerms]];
]


(* ::Input::Initialization:: *)
ResolveDerivatives::argument="The given argument is neither an FTerm nor a FEq.
The argument was `1`";
(*Iteratively resolve all derivative operators in an FTerm or FEq*)
ResolveDerivatives[setup_,expr_]:=Module[{ret=expr,i=1},
AssertFSetup[setup];

If[FreeQ[ret,FDOp[__],Infinity],Return[ReduceFEq[setup,ret]]];

If[FTermQ[ret],
While[MemberQ[ret,FDOp[__],Infinity]&&i<$MaxDerivativeIterations,
ret=ResolveFDOp[setup,ret];
];
Return[ret];
];

If[FEqQ[ret],
Return[FEq@@Map[ResolveDerivatives[setup,#]&,List@@ret]];
];

Message[ResolveDerivatives::argument,ret];Abort[];
];


(* ::Input::Initialization:: *)
Protect[OutputLevel,SuperIndexForm];
Options[TakeDerivatives]={OutputLevel->SuperIndexForm};


(* ::Input::Initialization:: *)
(* Perform multiple functional derivatives on a master equation.*)
TakeDerivatives[setup_,expr_,derivativeList_,OptionsPattern[]]:=Module[
{result,
externalIndexNames,outputReplacements,
derivativeListSIDX
},

AssertFSetup[setup];
AssertFEq[expr];
AssertDerivativeList[setup,derivativeList];

(*While doing the derivatives, we want to use super-indices. Afterwards, we can replace these again with the given indices*)
externalIndexNames=Map[Unique["eI"]&,derivativeList];
outputReplacements=Thread[externalIndexNames->Map[FieldIndices@@Join[Head[#],List@@#]&,derivativeList]];
derivativeListSIDX=Table[Head[derivativeList[[i]]][externalIndexNames[[i]]],{i,1,Length[derivativeList]}];

(*We take them in reverse order.*)
derivativeListSIDX=Reverse[derivativeListSIDX];

(*First, fix the indices in the input equation, i.e. make everything have unique names*)
result=FixIndices[setup,expr];
(*Perform all the derivatives, one after the other*)
Do[
result=ResolveDerivatives[setup,FTerm[FDOp[derivativeListSIDX[[pass]]]]**result]
,
{pass,1,Length[derivativeList]}
];

If[OptionValue[OutputLevel]===SuperIndexForm,
Return[ {result,outputReplacements}];
];

Return[result//.outputReplacements];
];


(* ::Input::Initialization:: *)
If[Length@PacletFind["MaTeX"]===0,
ResourceFunction["MaTeXInstall"][]
]
Get["MaTeX`"]
Import[$FunKitDirectory<>"/utils/MathematicaTeXUtilities.m"]


(* ::Input::Initialization:: *)
MakeTexIndexList[{i__}]:=Module[
{
ni=Length[{i}],
isLower,
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];
indices=Table[If[isLower[[idx]],-indices[[idx]],indices[[idx]]],{idx,1,ni}];

lowerList=Table[
If[isLower[[idx]],
ToString@TeXForm[indices[[idx]]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}",
ToString@TeXForm[indices[[idx]]]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
MakeIdxField[f_,i_,up]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],-i,i]]
MakeIdxField[f_,i_,down]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],i,-i]]
MakeIdxField[f_,i_]:=Module[{isLower,idx,idxStr,subSuper},
isLower=MatchQ[i,Times[-1,_]];
idx=If[isLower,-i,i];
If[f===AnyField,Return[ToString[TeXForm[idx]]]];

idxStr=If[Depth[idx]>1,"{"<>ToString[TeXForm[idx]]<>"}",ToString[TeXForm[idx]]];
subSuper=If[isLower,"_","^"];

ToString[TeXForm[f]]<>subSuper<>idxStr
]

MakeTexIndexList[{f__},{i__}]:=Module[
{
ni=Length[{f}],
isLower,
fields={f},
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];

lowerList=Table[
If[isLower[[idx]],
MakeIdxField[fields[[idx]],indices[[idx]],up],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}",
MakeIdxField[fields[[idx]],indices[[idx]],up]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
prettyIndices[setup_,expr_FEq]:=Map[prettyIndices[setup,#]&,expr];
prettyIndices[setup_,expr_FTerm]:=Module[{closedIndices,openIndices,repl,indices},
closedIndices=GetClosedSuperIndices[setup,expr];
openIndices=GetOpenIndices[setup,expr];
indices=Alphabet[];
Do[
indices=Select[indices,#=!=ToString[openIndices[[i]]]&],
{i,1,Length[openIndices]}
];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]];
Return[expr//.repl]
];


(* ::Input::Initialization:: *)
Unprotect[GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta]];

Format[GammaN[{f__},{i__}],TeXForm]:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret="\\Gamma";
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
]

Format[Propagator[{f__},{i__}],TeXForm]:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret="G";
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
]

Format[Rdot[{f__},{i__}],TeXForm]:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret="\\partial_t R";
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
]

Format[\[Delta][a_,b_],TeXForm]:=Module[{isLower,sub,sup,ret},
{sub,sup}=MakeTexIndexList[{a,b}];
ret="\\delta";
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
]

Format[\[Gamma][a_,b_],TeXForm]:=Module[{isLower,sub,sup,ret},
{sub,sup}=MakeTexIndexList[{a,b}];
ret="\\gamma";
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
]

Format[FTerm[a__],TeXForm]:=TeXDelimited["",a,"","DelimSeparator"->"","BodySeparator"->""]
Format[FEq[a___],TeXForm]:=TeXDelimited["",a,"","DelimSeparator"->"","BodySeparator"->"
\,+\,"]

Protect[GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta]];


(* ::Input::Initialization:: *)
ClearAll[FPrint,FTex];

FTex[setup_,expr_,replacements_:{}]:=Module[{prExp=expr//.replacements,fields},
AssertFSetup[setup];
prExp=prettyIndices[setup,prExp];
fields=GetAllFields[setup];
prExp=prExp//.Map[#[Times[-1,a_]]:>Subscript[#,a]&,fields]//.Map[#[a_]:>Superscript[#,a]&,fields];
Return[prExp//TeXForm];
]

FPrint[setup_,expr_,replacements_:{}]:=Module[{},
FTex[setup,expr,replacements]//MaTeX
]



