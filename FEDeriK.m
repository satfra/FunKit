(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Unprotect[FEq,FTerm];
ClearAll[FEq,FTerm];

FTerm::TimesError="An FTerm cannot be multiplied using Times[__]. To multiply FTerms, use term1**term2, also with scalars, a**term.";
FEq::TimesError="A FEq cannot be multiplied using Times[__]. To multiply FEqs, use eq1**eq2, also with scalars, a**eq.";

(*Multiplication of FTerms*)
FTerm/:Times[pre___,FTerm[a__],post___]:=(Message[FTerm::TimesError];Abort[])
FTerm/:NonCommutativeMultiply[FTerm[a__],FTerm[b__]]:=FTerm[a,b]

(*Reduction of immediately nested FTerms*)
FTerm[pre___,FTerm[in__],post___]:=FTerm[pre,in,post] 

(*Sum splitting of FTerms*)
FEq[preEq___,FTerm[preTerm___,Plus[a_,b__],postTerm___],postEq___]:=FEq[preEq,FTerm[preTerm,a,postTerm],FTerm[preTerm,Plus[b],postTerm],postEq]

(*Sums of FTerms*)
FEq[preEq___,Plus[FTerm[a__],FTerm[b__],c___],postEq___]:=FEq[preEq,FTerm[a],Plus[FTerm[b],c],postEq]

(*Sums of FEqs*)
FEq/:Plus[preEq___,FEq[terms1___],midEq___,FEq[terms2___],postEq___]:=Plus[preEq,midEq,postEq,FEq[terms1,terms2]]

(*Multiplication of FEqs*)
FEq/:Times[pre___,FEq[a__],post___]:=(Message[FEq::TimesError];Abort[])
FEq/:NonCommutativeMultiply[FTerm[b__],FEq[c__]]:=FEq[Map[FTerm[b]**#&,FEq[c]]]
FEq/:NonCommutativeMultiply[FEq[a__],FEq[b__]]:=FEq@@(Flatten@Table[FEq[{a}[[i]]**{b}[[j]]],{i,1,Length[{a}]},{j,1,Length[{b}]}])

(*Reduction of immediately nested FEqs*)
FEq[pre___,FEq[in___],post___]:=FEq[pre,in,post]
FEq[pre___,FTerm[],post___]:=FEq[pre,post]

Protect[FEq,FTerm];


(* ::Input::Initialization:: *)
FTermQ[expr_]:=Head[expr]===FTerm;
FTerm::notFTerm="The term `1` is not an FTerm.";
AssertFTerm[expr_]:=If[Not@FTermQ[expr],Message[FTerm::notFTerm,expr];Abort[]];

FEqQ[expr_]:=Head[expr]===FEq;
FEq::notFEq="The term `1` is not an FEq.";
AssertFEq[expr_]:=If[Not@FEqQ[expr],Message[FEq::notFEq,expr];Abort[]];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldDefQ[expr_]:=Module[{},
If[Head[expr]===List,
If[Length[expr]=!=2,
Print["A field definition must be either of form f[x...] or {af[x...],f[x...]}. \"",expr,"\" does not fit."];Return[False]];

If[Head[expr[[1]]]===Head[expr[[2]]],
Print["A field definition {af[x...],f[x...]} must have different field names af and f. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(List@@(expr[[1]])===List@@(expr[[2]])),
Print["A field definition {af[x...],f[x...]} must have identical indices. \"",expr,"\" does not fit."];
Return[False]];

Do[
If[Not@(MatchQ[expr[[i]],_Symbol[_,{__Symbol}]]||MatchQ[expr[[i]],_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr[[i]],"\" does not fit."];
Return[False]],
{i,1,2}
];

Return[True];
];

If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

Return[True];
];

FieldDef::invalidFieldDefinition="The given field definition `1` is not valid.";

AssertFieldDef[expr_]:=If[Not@FieldDefQ[expr],
Message[FieldDefinition::invalidFieldDefinition];
Abort[]];


(* ::Input::Initialization:: *)
(* Check if a given field space definition is valid *)
FieldSpaceDefQ[fieldSpace_]:=Module[{},
If[Head[fieldSpace]=!=Association,Print["An FSetup must be an association"];Return[False]];

If[Not@(Keys[fieldSpace]==={"cField","Grassmann"}),
Print["fields must contain the two keys {\"cField\",\"Grassmann\"}!"];
Return[False]];

If[Not@ListQ[fieldSpace["cField"]],
Print["fields[\"cField\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["cField"]]),
Print["fields[\"cField\"] must contain valid fields!"];
Return[False]];

If[Not@ListQ[fieldSpace["Grassmann"]],
Print["fields[\"Grassmann\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["Grassmann"]]),
Print["fields[\"Grassmann\"] must contain valid fields!"];
Return[False]];

Return[True];
];

FieldSpaceDefinition::invalidFieldDefinition="The given field space definition is invalid.";

AssertFieldSpaceDef[fields_]:=If[Not@FieldSpaceDefQ[fields],
Message[FieldSpaceDefinition::invalidFieldDefinition];Abort[]];


(* ::Input::Initialization:: *)
FSetup::notFSetup="The given setup is not valid!";

FSetupQ[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Return[False]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Return[False]];

If[Not@FieldSpaceDefQ[setup["FieldSpace"]],
Return[False]];

Return[True];
];

AssertFSetup[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Message[FSetup::notFSetup];
Abort[]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Message[FSetup::notFSetup];
Abort[]];

AssertFieldSpaceDef[setup["FieldSpace"]];
];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldQ[setup_,expr_]:=Module[{},
If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(MemberQ[Map[Head,setup["FieldSpace"]//Values//Flatten],Head[expr]]),
Print["The field \"",expr,"\" is not contained in the field space."];
Return[False]];

Return[True];
];

Field::invalidField="The given field `1` does not exist.";

AssertField[setup_,expr_]:=If[Not@FieldQ[setup,expr],
Message[FieldDefinition::invalidField];
Abort[]];


(* ::Input::Initialization:: *)
(*Check a derivative list for correct formatting.*)
DerivativeListQ[setup_,derivativeList_]:=Module[{},

If[Not@(Head[derivativeList]===List),
Print["A valid derivativeList must be an List!"];
Return[False]];

If[Not@AllTrue[derivativeList,FieldQ[setup,#]&],
Print["A valid derivativeList must be an List of fields f_[p_,{___}] of f_[p_] which have been defined in the setup!"];
Return[False]];

Return[True];
];

DeriveEquation::invalidDerivativeList="The given derivativeList `1` is not valid.";

AssertDerivativeList[setup_,expr_]:=If[Not@DerivativeListQ[setup,expr],
Message[DeriveEquation::invalidDerivativeList];
Abort[]];


(* ::Input::Initialization:: *)
Protect[GammaN,Propagator,AnyField,ABasis,VBasis];


(* ::Input::Initialization:: *)
exclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power}
GetAllSymbols[expr_]:=DeleteDuplicates@Cases[
Flatten[{expr}//.Times[a_,b__]:>{a,b}//.a_Symbol[b__]/;exclusions[a]:>{a,b}],
_Symbol,
Infinity]


(* ::Input::Initialization:: *)
FunctionalD[expr_,v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=Internal`InheritedBlock[{f,GammaN,Propagator,nonConst},

nonConst={f,GammaN,Propagator};

(*Rule for normal functional derivatives*)
f/:D[f[x_],f[y_],NonConstants->nonConst]:=\[Gamma][-y,x];
(*Ignore fields without indices. These are usually tags*)
f/:D[f,f[y_],NonConstants->nonConst]:=0;(*\[Delta][#,y]&;*)

Unprotect[GammaN,Propagator];

(*Derivative rule for GammaN*)
GammaN/:D[GammaN[{a__},{b__}],f[y_],NonConstants->nonConst]:=GammaN[{f,a},{y,b}];

(*Derivative rule for Propagators*)
Propagator/:D[Propagator[{b_,a_},{ib_,ia_}],f[if_],NonConstants->nonConst]:=Module[
{ic,id,ie},
Propagator[{b,AnyField},{ib,ic}]GammaN[{f,AnyField,AnyField},{-if,-ic,-id}]Propagator[{AnyField,a},{id,ie}]
(-1)\[Gamma][ia,-ie]
];

Protect[GammaN,Propagator];

D[expr,v,NonConstants->nonConst]
];

FunctionalD::badArgumentFTerm="Cannot take derivative of an FTerm. Use DeriveFunctional instead.";
FunctionalD[FTerm[expr_],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFTerm];Abort[]);

FunctionalD::badArgumentFEq="Cannot take derivative of an FEq. Use DeriveFunctional instead.";
FunctionalD[FEq[___],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFEq];Abort[]);



(* ::Input::Initialization:: *)
GetcFields[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["cField"]
];
GetAnticFields[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["cField"]
],#=!={}&];

GetGrassmanns[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["Grassmann"]
];
GetAntiGrassmanns[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["Grassmann"]
],#=!={}&];


(* ::Input::Initialization:: *)
GetFieldPairs[setup_]:=Map[{Head[#[[1]]],Head[#[[2]]]}&,
Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]===List&
]
];

GetSingleFields[setup_]:=Map[Head[#]&,Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]=!=List&
]
];

GetAllFields[setup_]:=Join[Flatten@GetFieldPairs[setup],GetSingleFields[setup]];

HasPartnerField[setup_,field_]:=MemberQ[
Flatten@GetFieldPairs[setup],
field
];
HasPartnerField[setup_,field_[__]]:=HasPartnerField[setup,field];

IsGrassmann[setup_,field_]:=MemberQ[GetGrassmanns[setup],field,Infinity];
IsGrassmann[setup_,field_[__]]:=IsGrassmann[setup,field];

IsAntiGrassmann[setup_,field_]:=MemberQ[GetAntiGrassmanns[setup],field,Infinity];
IsAntiGrassmann[setup_,field_[__]]:=IsAntiGrassmann[setup,field];

IscField[setup_,field_]:=MemberQ[GetcFields[setup],field,Infinity];
IscField[setup_,field_[__]]:=IscField[setup,field];

IsAnticField[setup_,field_]:=MemberQ[GetAnticFields[setup],field,Infinity];
IsAnticField[setup_,field_[__]]:=IsAnticField[setup,field];


(* ::Input::Initialization:: *)
GetPartnerField[setup_,field_Symbol]:=Module[{pairs,sel},
If[Not@HasPartnerField[setup,field],Return[field]];

pairs=GetFieldPairs[setup];

sel=Select[pairs,MemberQ[#,field,Infinity]&][[1]];
sel=DeleteCases[sel,field];
If[Length[sel]>0,Return[sel[[1]]]];

Print["field ",field," not found!"];Abort[];
];
GetPartnerField[setup_,field_Symbol[i__]]:=GetPartnerField[setup,field][i]


(* ::Input::Initialization:: *)
ExtractFields[setup_Association,expr_]:=Module[{symbols},
symbols=GetAllSymbols[expr];
Return@Select[symbols,MemberQ[GetAllFields[setup],#]&];
];
ExtractFieldsWithIndex[setup_Association,expr_]:=Module[{fields,extracted},
fields=ExtractFields[setup,expr];
extracted={};
expr//.{a_[b_]/;MemberQ[fields,a]:>(AppendTo[extracted,a[b]];1)};
Return[extracted]
];


(* ::Input::Initialization:: *)
ContainsGrassmann[setup_Association,expr_]:=Module[{fields},
fields=ExtractFields[setup,expr];
Return[
AnyTrue[fields,IsGrassmann[setup,#]||IsAntiGrassmann[setup,#]&]
];
]
GrassmannCount[setup_Association,expr_]:=Module[{fields},
fields=ExtractFieldsWithIndex[setup,expr];
Return[Length@
Select[fields,IsGrassmann[setup,Head[#]]||IsAntiGrassmann[setup,Head[#]]&]
];
]


(* ::Input::Initialization:: *)
$indexedObjects={ABasis,VBasis,GammaN,Propagator};


(* ::Input::Initialization:: *)
(*Get a list of all unique super-indices within the expression expr*)
GetAllSuperIndices[setup_,expr_]:=Module[{fields,indices},
fields=ExtractFieldsWithIndex[setup,expr];
indices={};
fields//.
p_[Times[-1,a_]]/;exclusions[p]:>(AppendTo[indices,a];1)//.
p_[a_]/;exclusions[p]:>(AppendTo[indices,a];1);
Do[
expr//.{
extObj[[i]][{f__},{\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];extObj[[i]][{f},{b}]),
extObj[[i]][{f__},{\!\(\*
TagBox[
StyleBox["a_Symbol",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___}]:>(AppendTo[indices,a];extObj[[i]][{f},{b}])
},
{i,1,Length[$indexedObjects]}
];
expr//.{
\[Delta][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Delta][b]),
\[Delta][a_Symbol,b___]:>(AppendTo[indices,a];\[Delta][b])
};
expr//.{
\[Gamma][\!\(\*
TagBox[
StyleBox[
RowBox[{"Times", "[", 
RowBox[{
RowBox[{"-", "1"}], ",", "a_Symbol"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),b___]:>(AppendTo[indices,a];\[Gamma][b]),
\[Gamma][a_Symbol,b___]:>(AppendTo[indices,a];\[Gamma][b])
};
Return[indices//DeleteDuplicates];
];


(* ::Input::Initialization:: *)
ExtractObjectsWithIndex[setup_Association,expr_]:=Module[{
indices,flattened,objects
},
indices=GetAllSuperIndices[Setup,expr];

If[FTermQ[expr],
flattened=Times@@expr;

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[{b},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[b]];1);

Return[objects];
];

If[FEqQ[expr],
flattened=Times@@(Join@@Map[List@@#&,expr]);

objects={};
flattened//.a_Symbol[b__]/;ContainsAny[{b},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[b]];1);
flattened//.a_Symbol[{f__},{i__}]/;ContainsAny[{i},indices\[Union](-indices)]&&exclusions[a]:>(AppendTo[objects,a[{f},{i}]];1);
Return[objects];
];

Print["Expression \"",expr,"\" is neither an FTerm nor an FEq!"];Abort[];
];


(* ::Input::Initialization:: *)
(*Get a list of all open super-indices within the expression expr*)
GetOpenSuperIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
pick=Table[If [Mod[count[[i]],2]==0,False,True],{i,1,Length[indices]}];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Abort[]];

Return[Pick[indices,pick]];
];

(*Get a list of all closed super-indices within the expression expr*)
GetClosedSuperIndices[setup_,expr_]:=Module[{objects,indices,count,pick},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Abort[]];

pick=Table[If [Mod[count[[i]],2]!=0,False,True],{i,1,Length[indices]}];
Return[Pick[indices,pick]];
];

(*Get a list of all open super-indices within the expression expr*)
SuperIndicesValid[setup_,expr_]:=Module[{objects,indices,count},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
If[AnyTrue[count,#>2&],Print["There are indices with count > 2. This is not allowed for valid terms/equations!"];Return[False]];
Return[True];
];


(* ::Input::Initialization:: *)
(*Check whether all indices are closed within expr. 
This disallows also multiple use of a single index name, !anywhere!*)
AllIndicesClosed[setup_,expr_]:=Module[{objects,indices,count,valid},
objects=ExtractObjectsWithIndex[setup,expr];
indices=GetAllSuperIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
valid=AllTrue[count,#==2&];
Return[valid];
];


(* ::Input::Initialization:: *)
$CanonicalOrdering="f>af>b";
$AvailableCanonicalOrderings={"f>af>b","af>f>b","b>f>af","b>af>f"};

CanonicalOrdering::unknownInteger="The integer `1` should be between 1 and 4.";
CanonicalOrdering::unknownString="The expression `1` should be one of "<>ToString[$AvailableCanonicalOrderings];

SetCanonicalOrdering[a_Integer]:=Module[{},
Switch[a,
1,$CanonicalOrdering="f>af>b",

2,$CanonicalOrdering="af>f>b",

3,$CanonicalOrdering="b>f>af",

4,$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownInteger,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];

SetCanonicalOrdering[a_]:=Module[{},
Switch[a,
"f>af>b",$CanonicalOrdering="f>af>b",

"af>f>b",$CanonicalOrdering="af>f>b",

"b>f>af",$CanonicalOrdering="b>f>af",

"b>af>f",$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownString,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];


(* ::Input::Initialization:: *)
(*Returns true if f1 < f2, and false if f1 > f2*)
FieldOrderLess[setup_,f1_Symbol,f2_Symbol]:=Module[
{kind1,kind2,
idxOrder,
n1,n2},

kind1={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#]}&[f1];
kind2={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#]}&[f2];

Switch[$CanonicalOrdering,
"f>af>b",
idxOrder={4,3,2,1},
"af>f>b",
idxOrder={3,4,1,2},
"b>f>af",
idxOrder={2,1,4,3},
"b>af>f",
idxOrder={1,2,3,4},
_,
Print["Order failure: order \""<>$CanonicalOrdering<>"\" unknown."];Abort[];
];

n1=Pick[idxOrder,kind1][[1]];
n2=Pick[idxOrder,kind2][[1]];

Return[n1<n2]
];


(* ::Input::Initialization:: *)
(*Returns the sign that results from exchanging the two fields f1 and f2*)
CommuteSign[setup_,f1_,f2_]:=Module[
{kind1,kind2},

kind1={IsGrassmann[setup,#]||IsAntiGrassmann[setup,#],IscField[setup,#]||IsAnticField[setup,#]}&[f1];
kind2={IsGrassmann[setup,#]||IsAntiGrassmann[setup,#],IscField[setup,#]||IsAnticField[setup,#]}&[f2];

Return[If[kind1[[1]]&&kind2[[1]],-1,1]];
];


(* ::Input::Initialization:: *)
(*Find all instances of $OrderedObjects and order their field value according to the canonical scheme*)
$OrderedObjects={Propagator,GammaN};
OrderObject[setup_,expr_]:=expr;
OrderObject[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{i,j,curi,prefactor,pref,reverse,
nfields=fields,nindices=indices,
trackedField},

(*The propagator gets a reverse ordering*)
reverse=If[obj===Propagator,True,False];
pref=If[reverse,Identity,Not];
prefactor=1;

(*Always compare the ith field with all previous fields and put it in the right place.
Iterate until one reaches the end of the array, then it is sorted.*)
For[i=1,i<=Length[nfields],i++,
curi=i;
(*Check if we should switch curi and curi-1*)
While[curi>=2&&pref@FieldOrderLess[setup,nfields[[curi]],nfields[[curi-1]]],
nfields[[{curi,curi-1}]]=nfields[[{curi-1,curi}]];
nindices[[{curi,curi-1}]]=nindices[[{curi-1,curi}]];
prefactor*=CommuteSign[setup,nfields[[curi]],nfields[[curi-1]]];
curi--;
];
];

Return[prefactor*obj[nfields,nindices]];
];
OrderFields[setup_,expr_]:=Map[OrderObject[setup,#]&,expr,Infinity];


(* ::Input::Initialization:: *)
(*Compatibility: Output any expression in a Form which looks like QMeS output*)
QMeSNaming[setup_,expr_]:=expr;
QMeSNaming[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{oldCanonicalOrdering,transf,prefactor,
mobj,mfields,mindices,
prefix,fieldPart,indexPart},

(*QMeS follows b>af>f, so we switch temporarily!*)
Block[{$CanonicalOrdering},
$CanonicalOrdering="b>af>f";
transf=OrderObject[setup,obj[fields,indices]];
];

prefactor=1;
If[MatchQ[transf,Times[-1,a_]],prefactor=-1;transf=-transf;];
mobj=Head[transf];
mfields=(List@@transf)[[1]];
mindices=(List@@transf)[[2]];

prefix=Switch[obj,
Propagator,"G",
GammaN,"\[CapitalGamma]"
];
fieldPart=StringJoin[Map[ToString,mfields]];
indexPart=Flatten[mindices];
Return[prefactor*Symbol[prefix<>fieldPart][indexPart]];
];
QMeSForm[setup_,expr_]:=Map[QMeSNaming[setup,#]&,expr,{1,3}]//.{FEq:>List,FTerm:>List};


(* ::Input::Initialization:: *)
(*Given a user-defined term or master equation, give all (closed) indices unique names.*)
FixIndices[setup_,expr_]:=Module[{
indices,newIndices,replacements,indexedObjects
},
AssertFSetup[setup];

Print[FTermQ[expr]];

If[FEqQ[expr],
Return[FixIndices[setup,#]&/@expr];
];
If[FTermQ[expr],
Print["hi"];
If[Not@TermSuperIndicesValid[setup,expr],Print["oi"];Abort[]];
Print["df"];

indices=GetClosedSuperIndices[setup,expr];
newIndices=Map[Unique[ToString[#]]&,indices];
replacements=Thread[indices->newIndices];

Return[expr/.replacements];
];

Print["Expression \"",expr,"\" is neither a term nor a master equation!"];Abort[];
];

FEq[FTerm[a],FTerm[b,c+d]]
Map[FixIndices[Setup,#]&,%]


(* ::Input::Initialization:: *)
(* Simplify a term appearing in an equation. Remove all parts that are multiplied with 0 and try to merge as many factors as possible, while not changing the Grassmann structure of the term.
Returns {0} if the term is trivial.
*)
ReduceTerm[setup_,term_]:=Module[{reduced=List@@term,mergeGrassmanFactors,i},
AssertFSetup[setup];
AssertFTerm[term];

If[MemberQ[reduced,Plus[a_,b__],Infinity],Print[reduced," is not a valid term! A term cannot contain a Plus[___]."];Abort[]];

If[Length[reduced]===0,Return[{0}]];
If[MemberQ[reduced,0],Return[{0}]];

(*Merge scalar terms with the closest Grassman term*)
If[GrassmannCount[setup,reduced[[1]]]>1,Print["Grassmann count is > 1, error!"];Abort[]];
While[(GrassmannCount[setup,reduced[[1]]]===0)&&Length[reduced]>1,
reduced=Join[{reduced[[1]]*reduced[[2]]},reduced[[3;;]]];
];

i=2;
While[i<=Length[reduced],
If[GrassmannCount[setup,reduced[[i]]]>1,Print["Grassmann count is > 1, error!"];Abort[]];
If[GrassmannCount[setup,reduced[[i]]]==0,
reduced=Join[reduced[[;;i-2]],{reduced[[i]]*reduced[[i-1]]},reduced[[i+1;;]]];
,
i++;
];
];

reduced=OrderEquation[setup,reduced];

Return[FTerm@@reduced];
];


(* ::Input::Initialization:: *)
ReduceEquation[setup_,equation_]:=Module[
{reduced=equation},

AssertFSetup[setup];
AssertFEq[equation];

(*Make sure all terms are reduced*)
reduced=ReduceTerm[setup,#]&/@reduced;

(*Remove all terms that are 0*)
reduced=Select[reduced,#=!={0}&];

If[Length[reduced]===0,Return[{{0}}]];

(*Amend the index structure*)
reduced=FixIndices[setup,reduced];

Return[reduced];
];
ReduceEquation[Setup,FEq[FTerm[a,b]]]


(* ::Input::Initialization:: *)
(* Perform a single functional derivative on a term.*)
TermDerivative[setup_,term_,field_]:=Module[{newTerms,prefactor,splitTerms},
(*Simplify the input and copy it as many times as the product rule will be applied*)
newTerms=ReduceTerm[setup,term];
newTerms=Table[newTerms,{i,1,Length[term]}];

(*Perform the product rule. Each factor in the term contains one Grassmann, so appropriately add the minus signs*)
Do[
prefactor=If[IsGrassmann[setup,field],(-1)^(i+1),1];
newTerms[[i,i]]=prefactor FunctionalD[newTerms[[i,i]],field],
{i,1,Length[term]}
];

Return[newTerms];
];

(* Perform a single functional derivative on an equation.*)
EquationDerivative[setup_,equation_,field_]:=Module[
{newTerms},
If[Not@IsMasterEq[equation],Print["The expression \"",equation,"\" is not a master equation!"];Abort[]];

(*Take derivatives of all terms in the equation*)
newTerms=TermDerivative[setup,#,field]&/@equation;
(*A term derivative yields an equation; join these equations to obtain the full equation*)
newTerms=Join@@newTerms;

(*Simplify the resulting equation*)
Return[ReduceEquation[setup,newTerms]];
];


(* ::Input::Initialization:: *)


(* Perform a single functional derivative on a term.*)
TermDerivative[setup_,term_,field_]:=Module[{newTerms,prefactor,splitTerms},
If[Not@FEqQ[term],Message[FEq::notFEq,term];Abort[]];

(*Simplify the input and copy it as many times as the product rule will be applied*)
newTerms=ReduceTerm[setup,term];
newTerms=Table[newTerms,{i,1,Length[term]}];

(*Perform the product rule. Each factor in the term contains one Grassmann, so appropriately add the minus signs*)
Do[
prefactor=If[IsGrassmann[setup,field],(-1)^(i+1),1];
newTerms[[i,i]]=prefactor FunctionalD[newTerms[[i,i]],field],
{i,1,Length[term]}
];

Return[newTerms];
];

(* Perform a single functional derivative on an equation.*)
EquationDerivative[setup_,equation_,field_]:=Module[
{newTerms},
If[Not@IsMasterEq[equation],Print["The expression \"",equation,"\" is not a master equation!"];Abort[]];

(*Take derivatives of all terms in the equation*)
newTerms=TermDerivative[setup,#,field]&/@equation;
(*A term derivative yields an equation; join these equations to obtain the full equation*)
newTerms=Join@@newTerms;

(*Simplify the resulting equation*)
Return[ReduceEquation[setup,newTerms]];
];


(* ::Input::Initialization:: *)
Protect[OutputLevel,SuperIndexForm];
Options[DeriveFunctionalEquation]={OutputLevel->SuperIndexForm};


(* ::Input::Initialization:: *)
(* Perform multiple functional derivatives on a master equation.*)
DeriveFunctionalEquation[setup_,expr_,derivativeList_,OptionsPattern[]]:=Module[
{result,
externalIndexNames,outputReplacements,
derivativeListSIDX
},

If[Not@IsValidSetup[setup],Print["The expression \"",setup,"\" is not a valid setup!"];Abort[]];
If[Not@IsValidMasterEq[expr],Print["The expression \"",expr,"\" is not a master equation!"];Abort[]];
If[Not@IsValidDerivativeList[setup,derivativeList],Print["The expression \"",derivativeList,"\" is not a derivative list!"];Abort[]];

(*While doing the derivatives, we want to use super-indices. Afterwards, we can replace these again with the given indices*)
externalIndexNames=Map[Unique["eI"]&,derivativeList];
outputReplacements=Thread[externalIndexNames->Map[FieldIndices@@Join[Head[#],List@@#]&,derivativeList]];
derivativeListSIDX=Table[Head[derivativeList[[i]]][externalIndexNames[[i]]],{i,1,Length[derivativeList]}];

(*We take them in reverse order.*)
derivativeListSIDX=Reverse[derivativeListSIDX];

(*First, fix the indices in the input equation, i.e. make everything have unique names*)
result=FixIndices[setup,expr];
(*Perform all the derivatives, one after the other*)
Do[
result=EquationDerivative[setup,result,derivativeListSIDX[[pass]]]
,
{pass,1,Length[derivativeList]}
];

If[OptionValue[OutputLevel]===SuperIndexForm,
Return[ {result,outputReplacements}];
];

Return[result//.outputReplacements];
];

DeriveFunctionalEquation[Setup,{{c[x],GammaN[{c,cb},{x,y}]c[y]}},{c[-f,{a}],cb[f,{a}]}]



