(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"FEDeriK","FunKit"];
Abort[];
];

ModuleLoaded[FEDeriK]=True;


(* ::Input::Initialization:: *)
$userCorrelationFunctions={};
$userIndexedObjects={};

$CorrelationFunctions:={Propagator,GammaN}\[Union]$userCorrelationFunctions;
$OrderedObjects:=$CorrelationFunctions\[Union]{Rdot,S};
$indexedObjects:=$OrderedObjects\[Union]{ABasis,VBasis,\[Gamma]}\[Union]$userIndexedObjects;
$allObjects:={FMinus}\[Union]$indexedObjects

$MaxDerivativeIterations=500;
$CanonicalOrdering="f>af>b";

Protect@@$allObjects;


(* ::Input::Initialization:: *)
AddIndexedObject[name_Symbol]:=Module[{},
AppendTo[$userIndexedObjects,name];
$userIndexedObjects=DeleteDuplicates[$userIndexedObjects];
Protect@@$allObjects;
];


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
type::error="The expression given is neither an FEq nor an FTerm.";


(* ::Input::Initialization:: *)
Unprotect[FTerm];
ClearAll[FTerm];

FTimesPowerPatternaToFTermb=\!\(\*
TagBox[
StyleBox[
RowBox[{"Power", "[", 
RowBox[{"a", ",", 
RowBox[{"FTerm", "[", "b_", "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);
FTimesPowerPatternFTermbtoa=\!\(\*
TagBox[
StyleBox[
RowBox[{"Power", "[", 
RowBox[{"a", ",", 
RowBox[{"FTerm", "[", "b_", "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);

FTerm::TimesError="An FTerm cannot be multiplied using Times[__]. To multiply FTerms, use term1**term2, also with scalars, a**term. Error in expression
`1`";
FTerm::FTermPowerError="An FTerm cannot be taken to a power of an FTerm.";

(*Multiplication of FTerms*)
FTerm/:NonCommutativeMultiply[FTerm[a__],FTerm[b__]]:=FTerm[a,b]
FTerm/:NonCommutativeMultiply[FTerm[],FTerm[b__]]:=FTerm[b]
FTerm/:NonCommutativeMultiply[FTerm[b__],FTerm[]]:=FTerm[b]
FTerm/:NonCommutativeMultiply[a_,FTerm[b__]]/;NumericQ[a]:=FTerm[a,b]

FTerm[pre___,NonCommutativeMultiply[in___],post___]:=FTerm[pre,in,post]
FTerm[pre___,Times[inpre__,NonCommutativeMultiply[in___],inpost__],post___]:=FTerm[pre,inpre*inpost,in,post]
FTerm[1,post___]:=FTerm[post]

FTerm[first_,pre___,Times[a_,other2_],post___]/;NumericQ[first]&&NumericQ[a]&&Head[first]=!=FDOp:=FTerm[first*a,pre,other2,post]
FTerm[first_,pre___,Times[a_,other2_],post___]/;Not[NumericQ[first]]&&NumericQ[a]&&Head[first]=!=FDOp:=FTerm[a,first,pre,other2,post]
FTerm[first_,pre___,a_,post___]/;NumericQ[first]&&NumericQ[a]:=FTerm[first*a,pre,post]
FTerm[first_,pre___,a_,post___]/;Not[NumericQ[first]]&&NumericQ[a]:=FTerm[a,first,pre,post]

(*Pre-reduction of zero FTerms*)
FTerm[___,0,___]:=FTerm[0]

(*Reduction of immediately nested FTerms*)
FTerm[pre___,FTerm[in__],post___]:=FTerm[pre,in,post] 

FTerm/:Power[FTerm[a___],FTerm[b___]]:=(Message[FTerm::FTermPowerError];Abort[]);

Protect[FTerm];


(* ::Input::Initialization:: *)
Unprotect[FEq];
ClearAll[FEq];

FEq::TimesError="A FEq cannot be multiplied using Times[__]. To multiply FEqs, use eq1**eq2, also with scalars, a**eq. Error in expression
`1`";

(*Removal of zero FTerms*)
FEq[pre___,FTerm[___,0,___],post___]:=FEq[pre,post]

(*Sum splitting of FTerms*)
FEq[preEq___,FTerm[preTerm___,Plus[a_,b__],postTerm___],postEq___]:=FEq[preEq,FTerm[preTerm,a,postTerm],FTerm[preTerm,Plus[b],postTerm],postEq]

(*Sums of FTerms*)
FEq[preEq___,Plus[FTerm[a__],FTerm[b__],c___],postEq___]:=FEq[preEq,FTerm[a],Plus[FTerm[b],c],postEq]
FEq/:Plus[FEq[a___],FTerm[b__]]:=FEq[a,FTerm[b]]

(*Sums of FEqs*)
FEq/:Plus[preEq___,FEq[terms1___],midEq___,FEq[terms2___],postEq___]:=Plus[preEq,midEq,postEq,FEq[terms1,terms2]]

(*Multiplication of FEqs*)
FEq/:Times[pre___,FEq[a__],post___]:=(Message[FEq::TimesError,{pre,FEq[a],post}];Abort[])
FEq[prefeq__,Times[pre___,FTerm[a__],post___],postfeq__]:=(Message[FTerm::TimesError,{pre,FTerm[a],post}];Abort[])

FEq/:NonCommutativeMultiply[FTerm[b__],FEq[c__]]:=FEq[Map[FTerm[b]**#&,FEq[c]]]
FEq/:NonCommutativeMultiply[FEq[a__],FEq[b__]]:=FEq@@(Flatten@Table[FEq[{a}[[i]]**{b}[[j]]],{i,1,Length[{a}]},{j,1,Length[{b}]}])
FEq/:NonCommutativeMultiply[FTerm[b___],FEq[]]:=FEq[]
FEq/:NonCommutativeMultiply[FTerm[],FEq[b___]]:=FEq[]
FEq/:NonCommutativeMultiply[FTerm[0],FEq[b___]]:=FEq[]
FEq/:FTerm[FEq[a__]]:=FEq[a];
FEq/:FTerm[FEq[a__],FEq[b__]]:=FEq@@(Flatten@Table[FEq[{a}[[i]]**{b}[[j]]],{i,1,Length[{a}]},{j,1,Length[{b}]}])

(*Reduction of immediately nested FEqs*)
FEq[pre___,FEq[in___],post___]:=FEq[pre,in,post]

(*Expand nested FEq in sub-terms*)
FEq[pre___,FTerm[prein___,FEq[in___],postin___],post___]:=FEq[pre,NonCommutativeMultiply[prein,Plus[in],postin],post]

Protect[FEq];


(* ::Input::Initialization:: *)
FTermQ[expr_]:=Head[expr]===FTerm;
FTerm::notFTerm="The term `1` is not an FTerm.";
AssertFTerm[expr_]:=If[Not@FTermQ[expr],Message[FTerm::notFTerm,expr];Abort[]];

FEqQ[expr_]:=Head[expr]===FEq;
FEq::notFEq="The term `1` is not an FEq.";
AssertFEq[expr_]:=If[Not@FEqQ[expr],Message[FEq::notFEq,expr];Abort[]];


(* ::Input::Initialization:: *)
Unprotect[FMinus];
ClearAll[FMinus];

(*Grassmann minus signs do not care about index positioning. We force them always up*)
FMinus[{a_,b_},{Times[-1,ia_],ib_}]:=FMinus[{a,b},{ia,ib}]
FMinus[{a_,b_},{ia_,Times[-1,ib_]}]:=FMinus[{a,b},{ia,ib}]

(*Powers are simple*)
FMinus/:Power[FMinus[{a_,b_},{ia_,ib_}],n_Integer]/;EvenQ[n]:=1
FMinus/:Power[FMinus[{a_,b_},{ia_,ib_}],n_Integer]/;OddQ[n]:=FMinus[{a,b},{ia,ib}]

Protect[FMinus];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldDefQ[expr_]:=Module[{},
If[Head[expr]===List,
If[Length[expr]=!=2,
Print["A field definition must be either of form f[x...] or {af[x...],f[x...]}. \"",expr,"\" does not fit."];Return[False]];

If[Head[expr[[1]]]===Head[expr[[2]]],
Print["A field definition {af[x...],f[x...]} must have different field names af and f. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(List@@(expr[[1]])===List@@(expr[[2]])),
Print["A field definition {af[x...],f[x...]} must have identical indices. \"",expr,"\" does not fit."];
Return[False]];

Do[
If[Not@(MatchQ[expr[[i]],_Symbol[_,{__Symbol}]]||MatchQ[expr[[i]],_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr[[i]],"\" does not fit."];
Return[False]],
{i,1,2}
];

Return[True];
];

If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field definition f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

Return[True];
];

FieldDef::invalidFieldDefinition="The given field definition `1` is not valid.";

AssertFieldDef[expr_]:=If[Not@FieldDefQ[expr],
Message[FieldDefinition::invalidFieldDefinition];
Abort[]];


(* ::Input::Initialization:: *)
(* Check if a given field space definition is valid *)
FieldSpaceDefQ[fieldSpace_]:=Module[{},
If[Head[fieldSpace]=!=Association,Print["An FSetup must be an association"];Return[False]];

If[Not@(Keys[fieldSpace]==={"cField","Grassmann"}),
Print["fields must contain the two keys {\"cField\",\"Grassmann\"}!"];
Return[False]];

If[Not@ListQ[fieldSpace["cField"]],
Print["fields[\"cField\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["cField"]]),
Print["fields[\"cField\"] must contain valid fields!"];
Return[False]];

If[Not@ListQ[fieldSpace["Grassmann"]],
Print["fields[\"Grassmann\"] must be a list!"];
Return[False]];

If[Not@(And@@Map[FieldDefQ,fieldSpace["Grassmann"]]),
Print["fields[\"Grassmann\"] must contain valid fields!"];
Return[False]];

Return[True];
];

FieldSpaceDefinition::invalidFieldDefinition="The given field space definition is invalid.";

AssertFieldSpaceDef[fields_]:=If[Not@FieldSpaceDefQ[fields],
Message[FieldSpaceDefinition::invalidFieldDefinition];Abort[]];


(* ::Input::Initialization:: *)
FSetup::notFSetup="The given setup is not valid!";

FSetupQ[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Return[False]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Return[False]];

If[Not@FieldSpaceDefQ[setup["FieldSpace"]],
Return[False]];

Return[True];
];

AssertFSetup[setup_]:=Module[{},
If[Not@(Head[setup]===Association),
Print["A valid setup must be an Association!"];
Message[FSetup::notFSetup];
Abort[]];

If[Not@MemberQ[Keys[setup],"FieldSpace"],
Print["A valid setup must have the key \"FieldSpace\"!"];
Message[FSetup::notFSetup];
Abort[]];

AssertFieldSpaceDef[setup["FieldSpace"]];
];


(* ::Input::Initialization:: *)
(* Check if a given field definition is valid. Can be either its own anti-field or a pair {af,f} *)
FieldQ[setup_,expr_]:=Module[{},
If[Not@(MatchQ[expr,_Symbol[_,{__Symbol}]]||MatchQ[expr,_Symbol[_]]),
Print["A field f[x...] must have indices f[p] or f[p,{a,b,...}]. \"",expr,"\" does not fit."];
Return[False]];

If[Not@(MemberQ[Map[Head,setup["FieldSpace"]//Values//Flatten],Head[expr]]),
Print["The field \"",expr,"\" is not contained in the field space."];
Return[False]];

Return[True];
];

Field::invalidField="The given field `1` does not exist.";

AssertField[setup_,expr_]:=If[Not@FieldQ[setup,expr],
Message[FieldDefinition::invalidField];
Abort[]];


(* ::Input::Initialization:: *)
(*Check a derivative list for correct formatting.*)
DerivativeListQ[setup_,derivativeList_]:=Module[{},

If[Not@(Head[derivativeList]===List),
Print["A valid derivativeList must be an List!"];
Return[False]];

If[Not@AllTrue[derivativeList,FieldQ[setup,#]&],
Print["A valid derivativeList must be an List of fields f_[p_,{___}] of f_[p_] which have been defined in the setup!"];
Return[False]];

Return[True];
];

DeriveEquation::invalidDerivativeList="The given derivativeList `1` is not valid.";

AssertDerivativeList[setup_,expr_]:=If[Not@DerivativeListQ[setup,expr],
Message[DeriveEquation::invalidDerivativeList];
Abort[]];


(* ::Input::Initialization:: *)
Unprotect[FDOp];
ClearAll[FDOp];

FDOp::invalid="`1` is not a valid FDOp.";
FDOp::invalidArguments="`1` is not a valid FDOp. FDOp takes a single field with an index as argument.";
FDOp::arithmetic="An FDOp cannot be included as anything but a factor in an FTerm. Error in 
  `1`";

FDOp/:Times[a___,FDOp[b___],c___]:=(Message[FDOp::arithmetic,StringTake[ToString@(Hold@Times[a,FDOp[b],c]),{6,-2}]];Abort[])
FDOp/:Plus[a___,FDOp[b___],c___]:=(Message[FDOp::arithmetic,StringTake[ToString@(Hold@Plus[a,FDOp[b],c]),{6,-2}]];Abort[])

FDOp[a_,b__]:=(Message[FDOp::invalidArguments,StringTake[ToString@(Hold@FDOp[a,b]),{6,-2}]];Abort[])

FDOpQ[setup_,expr_]:=(Head[expr]===FDOp)&&MatchQ[expr,(_[_,{__}]|_[_])]&&FieldQ[setup,#]&@@expr;
AssertFDOp[setup_,expr_]:=If[Not@FDOpQ[setup,expr],Message[FDOp::invalid,expr];Abort[]];

Protect[FDOp];


(* ::Input::Initialization:: *)
exclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power,a=!=Times}
GetAllSymbols[expr_]:=DeleteDuplicates@Cases[
Flatten[{expr}//.Times[a_,b__]:>{a,b}//.a_Symbol[b__]/;exclusions[a]:>{a,b}],
_Symbol,
Infinity]


(* ::Input::Initialization:: *)
FunctionalD::malformed="Cannot take a derivative of `1`. Expression is either malformed or this is a bug.";

ClearAll[FunctionalD]
FunctionalD[expr_,v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=Internal`InheritedBlock[
{f,GammaN,Propagator,nonConst,FTerm,FEq,AnyField},

nonConst=Sort@{f,GammaN,Propagator,Power};

Unprotect[GammaN,Propagator,FTerm,FEq,AnyField];

(*Rule for normal functional derivatives*)
f/:D[f[x_],f[y_],NonConstants->nonConst]:=\[Gamma][{f,f},{-y,x}];
(*Rule for normal functional derivatives, but AnyField*)
AnyField/:D[AnyField[x_],f[y_],NonConstants->nonConst]:=\[Gamma][{f,AnyField},{-y,x}];
(*Ignore fields without indices. These are usually tags*)
f/:D[f,f[y_],NonConstants->nonConst]:=0;(*\[Delta][#,y]&;*)

(*Derivative rule for GammaN*)
GammaN/:D[GammaN[{a__},{b__}],f[if_],NonConstants->nonConst]:=GammaN[{f,a},{-if,b}];

(*Derivative rule for Propagators*)
Propagator/:D[Propagator[{b_,a_},{ib_,ia_}],f[if_],NonConstants->nonConst]:=Module[
{ic,id,ie,ig},
((-1)FMinus[{a,a},{id,id}]FMinus[{f,b},{if,ib}])**
Propagator[{b,AnyField},{ib,ic}]**
GammaN[{AnyField,f,AnyField},{-ic,-if,-id}]**
Propagator[{AnyField,a},{id,ia}]
];

(*No derivatives of FTerm, FEq*)
FTerm/:D[FTerm[a___],f[y_],NonConstants->nonConst]:=(Message[FunctionalD::malformed,FTerm[a]];Abort[]);
FEq/:D[FEq[a___],f[y_],NonConstants->nonConst]:=(Message[FunctionalD::malformed,FEq[a]];Abort[]);

(*Chain rules*)
f/:D[g_[FTerm[a___]],f[y_],NonConstants->nonConst]:=(FTerm[g'[FTerm[a]]]**FTerm[FDOp[f[y]],a]);
f/:D[Power[FTerm[a___],b_],f[y_],NonConstants->nonConst]:=(FTerm[b,Power[FTerm[a],b-1]]**FTerm[FDOp[f[y]],a]);
f/:D[Power[a_,FTerm[b___]],f[y_],NonConstants->nonConst]:=(FTerm[Log[a],Power[a,FTerm[b]]]**FTerm[FDOp[f[y]],b]);

Protect[GammaN,Propagator,FTerm,FEq,AnyField];

D[expr,v,NonConstants->nonConst]
];

FunctionalD::badArgumentFTerm="Cannot take derivative of an FTerm. Use TakeDerivatives instead.";
FunctionalD[FTerm[expr_],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFTerm];Abort[]);

FunctionalD::badArgumentFEq="Cannot take derivative of an FEq. Use TakeDerivatives instead.";
FunctionalD[FEq[___],v:(f_[_]|{f_[_],_Integer})..,OptionsPattern[]]:=(Message[FunctionalD::badArgumentFEq];Abort[]);



(* ::Input::Initialization:: *)
GetcFields[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["cField"]
];
GetAnticFields[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["cField"]
],#=!={}&];

GetGrassmanns[setup_]:=Map[
If[Head[#]===List,Head[#[[2]]],Head[#]]&,
setup["FieldSpace"]["Grassmann"]
];
GetAntiGrassmanns[setup_]:=Select[Map[
If[Head[#]===List,Head[#[[1]]],{}]&,
setup["FieldSpace"]["Grassmann"]
],#=!={}&];


GetCommuting[setup_]:=Flatten@Select[Map[
If[Head[#]===List,{Head[#[[1]]],Head[#[[2]]]},Head[#]]&,
setup["FieldSpace"]["cField"]
],#=!={}&];

GetAntiCommuting[setup_]:=Flatten@Select[Map[
If[Head[#]===List,{Head[#[[1]]],Head[#[[2]]]},Head[#]]&,
setup["FieldSpace"]["Grassmann"]
],#=!={}&];


(* ::Input::Initialization:: *)
GetFieldPairs[setup_]:=Map[{Head[#[[1]]],Head[#[[2]]]}&,
Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]===List&
]
];

GetSingleFields[setup_]:=Map[Head[#]&,Select[
Join[setup["FieldSpace"]["Grassmann"],setup["FieldSpace"]["cField"]],
Head[#]=!=List&
]
];

GetAllFields[setup_]:=Join[Flatten@GetFieldPairs[setup],GetSingleFields[setup]];

HasPartnerField[setup_,field_]:=MemberQ[
Flatten@GetFieldPairs[setup],
field
];
HasPartnerField[setup_,field_[__]]:=HasPartnerField[setup,field];

IsGrassmann[setup_,field_]:=MemberQ[GetGrassmanns[setup],field];
IsGrassmann[setup_,field_[__]]:=IsGrassmann[setup,field];

IsAntiGrassmann[setup_,field_]:=MemberQ[GetAntiGrassmanns[setup],field];
IsAntiGrassmann[setup_,field_[__]]:=IsAntiGrassmann[setup,field];

IscField[setup_,field_]:=MemberQ[GetcFields[setup],field];
IscField[setup_,field_[__]]:=IscField[setup,field];

IsAnticField[setup_,field_]:=MemberQ[GetAnticFields[setup],field];
IsAnticField[setup_,field_[__]]:=IsAnticField[setup,field];


(* ::Input::Initialization:: *)
GetPartnerField[setup_,field_Symbol]:=Module[{pairs,sel},
If[Not@HasPartnerField[setup,field],Return[field]];

pairs=GetFieldPairs[setup];

sel=Select[pairs,MemberQ[#,field,Infinity]&][[1]];
sel=DeleteCases[sel,field];
If[Length[sel]>0,Return[sel[[1]]]];

Print["field ",field," not found!"];Abort[];
];
GetPartnerField[setup_,field_Symbol[i__]]:=GetPartnerField[setup,field][i]


(* ::Input::Initialization:: *)
ExtractFields[setup_Association,expr_]:=Module[{},
Return@(DeleteDuplicates[Head/@Cases[{expr},
Alternatives@@Map[Blank,GetAllFields[setup]],
Infinity
]]);
];
ExtractFieldsWithIndex[setup_Association,expr_]:=Module[{},
Return@Cases[{expr},
Alternatives@@Map[Blank,GetAllFields[setup]],
Infinity
];
];


(* ::Input::Initialization:: *)
ContainsGrassmann[setup_Association,expr_]:=Module[{},
Return@
AnyTrue[ExtractFields[setup,expr],IsGrassmann[setup,#]||IsAntiGrassmann[setup,#]&];
]
GrassmannCount[setup_Association,expr_]:=Module[{},
Return[Length@
Select[ExtractFieldsWithIndex[setup,expr],IsGrassmann[setup,Head[#]]||IsAntiGrassmann[setup,Head[#]]&]
];
]


(* ::Input::Initialization:: *)
(*Get a list of all unique super-indices within the expression expr*)
GetAllSuperIndices[setup_,expr_FTerm]:=Module[{idxO,idxF},
idxO=Cases[expr,
Alternatives@@(Map[Blank[#]&,$indexedObjects]),
{1,2}];
idxF=Cases[expr,
Alternatives@@(Map[Blank[#]&,GetAllFields[setup]]),
{1,2}];
Return[makePosIdx/@(idxF[[All,1]]\[Union]Flatten[idxO[[All,2]]])//DeleteDuplicates]
];
GetAllSuperIndices[setup_Association,expr_FEq]:=Module[{},
Return@(GetAllSuperIndices[setup,#]&/@(List@@expr))
];


(* ::Input::Initialization:: *)
ExtractObjectsWithIndex[setup_Association,expr_FTerm]:=Module[{},
Return@Cases[expr,
Alternatives@@(Map[Blank[#]&,$indexedObjects\[Union]GetAllFields[setup]]),
{1,2}];
];
ExtractObjectsWithIndex[setup_Association,expr_FEq]:=Module[{},
Return@(
(ExtractObjectsWithIndex[setup,#]&/@(List@@expr))
)
];


(* ::Input::Initialization:: *)
ExtractObjectsAndIndices[setup_,expr_FTerm]:=Module[{idxO,idxF},
idxO=Cases[expr,
Alternatives@@(Map[Blank[#]&,$indexedObjects]),
{1,2}];
idxF=Cases[expr,
Alternatives@@(Map[Blank[#]&,GetAllFields[setup]]),
{1,2}];
Return[{idxO\[Union]idxF,
(makePosIdx/@(idxF[[All,1]]\[Union]Flatten[idxO[[All,2]]])//DeleteDuplicates)}]
];
ExtractObjectsAndIndices[setup_Association,expr_FEq]:=Module[{},
Return@DeleteDuplicates@({Flatten[#[[All,1]]],Flatten[#[[All,2]]]}&@
(ExtractObjectsAndIndices[setup,#]&/@(List@@expr))
)
];


(* ::Input::Initialization:: *)
SuperIndices::undeterminedSums="There are indices with count > 2 in the expression
    `1`
This is not allowed for valid terms/equation. Problematic indices:
    `2`";


(* ::Input::Initialization:: *)
(*Get a list of all closed super-indices within the expression expr*)
GetClosedSuperIndices[setup_,expr_]:=Module[{objects,indices,count},
{objects,indices}=ExtractObjectsAndIndices[setup,expr];
count=Map[Count[objects,#,{1,5}]&,indices];

Return[
Pick[indices,
Map[Mod[#,2]===0&,count]
]
];
];


(* ::Input::Initialization:: *)
(*Get a list of all open super-indices within the expression expr*)
GetOpenSuperIndices[setup_,expr_]:=Module[{objects,indices,count},
{objects,indices}=ExtractObjectsAndIndices[setup,expr];
count=Map[Count[objects,#,Infinity]&,indices];

Return[
Pick[indices,
Map[Mod[#,2]=!=0&,count]
]
];
];


(* ::Input::Initialization:: *)
(*Check whether all indices are closed within expr. 
This disallows also multiple use of a single index name, !anywhere!*)
AllIndicesClosed[setup_,expr_FTerm]:=Module[{objects,indices,count},
{objects,indices}=ExtractObjectsAndIndices[setup,expr];

count=Map[Count[objects,#,Infinity]&,indices];
Return[AllTrue[count,#==2&]];
];
AllIndicesClosed[setup_,expr_FEq]:=And@@(AllIndicesClosed[setup,#]&/@expr)
AllIndicesClosed[setup_,expr_]:=(Message[type::error];Abort[])

SuperIndicesValid[setup_,expr_FTerm]:=Module[{objects,indices,count},
{objects,indices}=ExtractObjectsAndIndices[setup,expr];
count=Map[Count[objects,#,Infinity]&,indices];

If[AnyTrue[count,#>2&],Message[SuperIndices::undeterminedSums,expr,Pick[indices,#>2&/@count]];Return[False]];
Return[True];
];
SuperIndicesValid[setup_,expr_FEq]:=SuperIndicesValid[setup,#]&/@expr
SuperIndicesValid[setup_,expr_]:=(Message[type::error];Abort[])



(* ::Input::Initialization:: *)
$AvailableCanonicalOrderings={"f>af>b","af>f>b","b>f>af","b>af>f"};

CanonicalOrdering::unknownInteger="The integer `1` should be between 1 and 4.";
CanonicalOrdering::unknownString="The expression `1` should be one of "<>ToString[$AvailableCanonicalOrderings];

SetCanonicalOrdering[a_Integer]:=Module[{},
Switch[a,
1,$CanonicalOrdering="f>af>b",

2,$CanonicalOrdering="af>f>b",

3,$CanonicalOrdering="b>f>af",

4,$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownInteger,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];

SetCanonicalOrdering[a_]:=Module[{},
Switch[a,
"f>af>b",$CanonicalOrdering="f>af>b",

"af>f>b",$CanonicalOrdering="af>f>b",

"b>f>af",$CanonicalOrdering="b>f>af",

"b>af>f",$CanonicalOrdering="b>af>f",

_,Message[CanonicalOrdering::unknownString,a]
];
Print["Canonical ordering set to ",$CanonicalOrdering];
];


(* ::Input::Initialization:: *)
(*Returns true if f1 < f2, and false if f1 > f2*)
FieldOrderLess[setup_,f1_Symbol,f2_Symbol]:=Module[
{kind1,kind2,
idxOrder,
n1,n2},

kind1={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#],#===AnyField}&[f1];
kind2={IsGrassmann[setup,#],IsAntiGrassmann[setup,#],IscField[setup,#],IsAnticField[setup,#],#===AnyField}&[f2];

Switch[$CanonicalOrdering,
"f>af>b",
idxOrder={4,3,2,1,0},
"af>f>b",
idxOrder={3,4,1,2,0},
"b>f>af",
idxOrder={2,1,4,3,0},
"b>af>f",
idxOrder={1,2,3,4,0},
_,
Print["Order failure: order \""<>$CanonicalOrdering<>"\" unknown."];Abort[];
];

n1=Pick[idxOrder,kind1][[1]];
n2=Pick[idxOrder,kind2][[1]];

If[n1===n2,
Return[OrderedQ[{f1,f2}]]
];
Return[n1<n2]
];


(* ::Input::Initialization:: *)
(*Returns the sign that results from exchanging the two fields f1 and f2*)
CommuteSign[setup_,f1_,f2_]:=Module[{},
Return[
-2*Boole[MemberQ[GetAntiCommuting[setup],f1]&&MemberQ[GetAntiCommuting[setup],f2]]+1
];
];


(* ::Input::Initialization:: *)
(*Find all instances of $OrderedObjects and order their field value according to the canonical scheme*)
OrderObject[setup_,expr_]:=expr;
OrderObject[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{i,curi,prefactor,pref,reverse,
nfields=fields,nindices=indices},

(*Do not order if there is an undetermined field!*)
If[MemberQ[nfields,AnyField]||FreeQ[$indexedObjects,obj],Return[obj[nfields,nindices]]];

(*The propagator gets a reverse ordering*)
reverse=If[obj===Propagator,True,False];
pref=If[reverse,Identity,Not];
prefactor=1;

(*Always compare the ith field with all previous fields and put it in the right place.
Iterate until one reaches the end of the array, then it is sorted.*)
For[i=1,i<=Length[nfields],i++,
curi=i;
(*Check if we should switch curi and curi-1*)
While[curi>=2&&pref@FieldOrderLess[setup,nfields[[curi]],nfields[[curi-1]]],
nfields[[{curi,curi-1}]]=nfields[[{curi-1,curi}]];
nindices[[{curi,curi-1}]]=nindices[[{curi-1,curi}]];
prefactor*=CommuteSign[setup,nfields[[curi]],nfields[[curi-1]]];
curi--;
];
];

Return[prefactor*obj[nfields,nindices]];
];
OrderFieldList[setup_,fields_List]:=Module[
{i,curi,nfields=fields},

(*Always compare the ith field with all previous fields and put it in the right place.
Iterate until one reaches the end of the array, then it is sorted.*)
For[i=1,i<=Length[nfields],i++,
curi=i;
(*Check if we should switch curi and curi-1*)
While[curi>=2&&Not@FieldOrderLess[setup,nfields[[curi]],nfields[[curi-1]]],
nfields[[{curi,curi-1}]]=nfields[[{curi-1,curi}]];
curi--;
];
];

Return[nfields];
];
OrderFields[setup_,expr_]:=Map[OrderObject[setup,#]&,expr,Infinity];


(* ::Input::Initialization:: *)
(*Compatibility: Output any expression in a Form which looks like QMeS output*)
QMeSNaming[setup_,expr_]:=expr;
QMeSNaming[setup_,obj_[fields_List,indices_List]/;MemberQ[$OrderedObjects,obj]]:=Module[
{oldCanonicalOrdering,transf,prefactor,
mobj,mfields,mindices,
prefix,fieldPart,indexPart},

(*QMeS follows b>af>f, so we switch temporarily!*)
Block[{$CanonicalOrdering},
$CanonicalOrdering="b>af>f";
transf=OrderObject[setup,obj[fields,indices]];
];

prefactor=1;
If[MatchQ[transf,Times[-1,a_]],prefactor=-1;transf=-transf;];
mobj=Head[transf];
mfields=(List@@transf)[[1]];
mindices=(List@@transf)[[2]];

prefix=Switch[obj,
Propagator,"G",
GammaN,"\[CapitalGamma]",
Rdot,"Rdot"
];
fieldPart=StringJoin[Map[ToString,mfields]];
indexPart=Flatten[mindices];
Return[prefactor*Symbol[prefix<>fieldPart][indexPart]];
];
QMeSForm[setup_,expr_]:=Map[QMeSNaming[setup,#]&,expr,{1,3}]//.{FEq:>List,FTerm:>List};


(* ::Input::Initialization:: *)
(*Is an index down?*)
isNeg[-i_]:=True;
isNeg[i_]:=False;
makePosIdx[-i_]:=i;
makePosIdx[i_]:=i;

(*AntiGrassmann-Grassmann gives 1, otherwise -1*)
GrassOrder[setup_,f1_,f2_,sign_]:=Module[{},
(2*Boole[IsGrassmann[setup,f1]]-1)^Boole[!(sign===1)]
];

(*Return Subscript[\[Gamma], ab] = \[Gamma]^ab = (0	-1
1	0

) and ordering (\[Psi], Overscript[\[Psi], _])*)
metric[setup_,a_,b_]:=Module[
{f1=makePosIdx[a],f2=makePosIdx[b],f2p,
lower,sign},
f2p=GetPartnerField[setup,f2];
If[(f1=!=f2p&&f1=!=f2),Return[0]];

(*Subscript[\[Gamma], a]^b = Subscript[\[Delta], a]^b*)
lower=Map[isNeg,{a,b}];
If[f1===f2&&lower[[1]]&&Not[lower[[2]]],Return[1]];

(*Subscript[\[Gamma]^a, b] = (-1)^abSubscript[\[Delta]^a, b]*)
sign=CommuteSign[setup,f1,f2];
If[f1===f2&&Not[lower[[1]]]&&lower[[2]],Return[sign]];

(*Subscript[\[Gamma], ab]=\[Gamma]^ab and fields fit with partners*)
If[f1===f2p&&Not[Xor@@lower],Return@GrassOrder[setup,f1,f2,sign]];

(*Otherwise, 0*)
Return[0]
];


(* ::Input::Initialization:: *)
ReduceIndices::FTermFEq="The given expression is neither an FTerm nor an FEq:
`1`";
ReduceIndices[setup_,term_]:=(Message[ReduceIndices::FTermFEq,term];Abort[]);

ReduceIndices[setup_,term_FTerm]:=Module[
{closedSIndices,cases,closed,
i,both,result=term,casesFMinus},

closedSIndices=GetClosedSuperIndices[setup,term];

cases=Cases[term,\[Gamma][__]|FMinus[__],{1,3}];
cases=Select[cases,FreeQ[#[[1]],AnyField]&];
casesFMinus=Select[cases,Head[#]===FMinus&];
cases=Select[cases,Head[#]===\[Gamma]&];
closed=Map[MemberQ[closedSIndices,makePosIdx[#]]&,cases[[All,2]],{2}];

cases=Pick[cases,Map[#[[1]]||#[[2]]&,closed]];
closed=Pick[closed,Map[#[[1]]||#[[2]]&,closed]];

(*replace the terms in question by the evaluated metric factor*)
result=result/.Map[#:>metric[setup,
(-2*Boole[isNeg[#[[2,1]]]]+1)#[[1,1]],
(-2*Boole[isNeg[#[[2,2]]]]+1)#[[1,2]]
]&,cases];

(*replace the remaining indices. If both are up or both or down, the remaining indices change signs.*)
result=result/.Table[
both=If[!Xor[isNeg[cases[[i,2,1]]],isNeg[cases[[i,2,2]]]],-1,1];
If[closed[[i,1]],
makePosIdx[cases[[i,2,1]]]->both*makePosIdx[cases[[i,2,2]]],
makePosIdx[cases[[i,2,2]]]->both*makePosIdx[cases[[i,2,1]]]
]
,{i,1,Length[cases]}
];

(*Resolve all FMinus factors*)
result=result/.Map[#->CommuteSign[setup,#[[1,1]],#[[1,2]]]&,casesFMinus];

Return[result];
];
ReduceIndices[setup_,eq_FEq]:=Module[{},
Map[ReduceIndices[setup,#]&,eq]
];


(* ::Input::Initialization:: *)
truncationPass[setup_,expr_FEq]:=Module[{},
truncationPass[Setup,#]&/@expr
]

truncationPass[setup_,expr_FTerm]:=Module[
{ret=expr,i,corrF},

(*Get rid of any truncated ordered functions*)
ret=ret/.Map[
#[f_,i_]/;FreeQ[f,AnyField]:>If[
FreeQ[Sort/@setup["Truncation"][#],Sort@f],
0,#[f,i]
]&,$OrderedObjects];

(*Finally, remove the metric factors*)
ret=ReduceIndices[setup,ret];

Return[ret];
];


(* ::Input::Initialization:: *)
Truncate::wrongExpr="Cannot truncate an expression which is neither an FEq nor an FTerm.";
Truncate::noTruncation="The given setup does not have a key \"Truncation\"";
Truncate::missingCorrF="The given truncation misses a truncation table for the correlation function `1`";
Truncate::missing="The given truncation misses a truncation table for `1`";
Truncate::FDOp="The given expression contains unresolved derivative operators! Cannot truncate before resolving all FDOp.";

indices::inconsistentContractions="The index `1` has been contracted in an inconsistent way in the expression
    `2`";

indices::inconsistentFieldContractions="The fields `1` have been contracted in an inconsistent way in the expression
    `2`";
ClearAll[LTrunc];
LTrunc[setup_,expr_]:=(Print[expr];Message[Truncate::wrongExpr];Abort[])

LTrunc[setup_,expr_FEq]:=Module[{},
Map[LTrunc[setup,#]&,expr]
]

LTrunc[setup_,expr_FTerm]:=Module[
{ret=List@@expr,curi,
allObj,closedIndices,i,allFields=GetAllFields[setup],
idx,subObj,idxOccur,idxPos,ignore,notFoundCuri
},

(*Start off with the nested FTerms*)
ret=ret/.FTerm[a__]:>LTrunc[setup,FTerm[a]];
(*Abort if there is nothing to do*)
If[FreeQ[ret,AnyField,Infinity],Return[FTerm@@ret]];

(*Get all closed indices*)
closedIndices=GetClosedSuperIndices[setup,FTerm@@(ret/.FTerm[__]:>ignore)];
(*Abort if there is nothing to do*)
If[Length[closedIndices]===0||FreeQ[ret,AnyField,Infinity],Return[FTerm@@ret]];

(*We have to update these global quantities after each iteration*)
allObj=ExtractObjectsWithIndex[setup,FTerm@@(ret/.FTerm[__]:>ignore)];

(*Next, try to find the first factor that needs to be expanded*)
notFoundCuri=True;
curi=1;
While[notFoundCuri,
If[curi>Length[closedIndices],Return[FTerm@@ret]];

idx=closedIndices[[curi]];
subObj=Select[allObj,MemberQ[#[[2]],idx,{1,3}]&];
idxOccur={
If[MemberQ[subObj[[1]],-idx,{2}],-idx,idx],
If[MemberQ[subObj[[2]],-idx,{2}],-idx,idx]
};
If[Sort@idxOccur=!=Sort@{idx,-idx},Message[indices::inconsistentContractions,idx,expr];Abort[]];
idxPos={FirstPosition[subObj[[1,2]],idxOccur[[1]]][[1]],FirstPosition[subObj[[2,2]],idxOccur[[2]]][[1]]};

If[subObj[[1,1,idxPos[[1]]]]=!=AnyField&&subObj[[2,1,idxPos[[2]]]]=!=AnyField,
curi++;
Continue[]
];

notFoundCuri=False;
];

If[subObj[[1,1,idxPos[[1]]]]===AnyField&&subObj[[2,1,idxPos[[2]]]]===AnyField,
ret=FEq@@Map[
Module[{s1=subObj[[1]],s2=subObj[[2]],t},
s1[[1,idxPos[[1]]]]=#;
s2[[1,idxPos[[2]]]]=#;
truncationPass[setup,FTerm@@(ret/.{
subObj[[1]]:>s1,
subObj[[2]]:>s2,

FMinus[{a_,a_},{s1[[2,idxPos[[1]]]],s1[[2,idxPos[[1]]]]}]:>FMinus[{#,#},{s1[[2,idxPos[[1]]]],s1[[2,idxPos[[1]]]]}],
FMinus[{a_,a_},{s2[[2,idxPos[[2]]]],s2[[2,idxPos[[2]]]]}]:>FMinus[{#,#},{s2[[2,idxPos[[2]]]],s2[[2,idxPos[[2]]]]}],

FMinus[{a_,b_},{s1[[2,idxPos[[1]]]],ib_}]:>FMinus[{#,b},{s1[[2,idxPos[[1]]]],ib}],
FMinus[{a_,b_},{s2[[2,idxPos[[2]]]],ib_}]:>FMinus[{#,b},{s2[[2,idxPos[[2]]]],ib}],

FMinus[{a_,b_},{ia_,s1[[2,idxPos[[1]]]]}]:>FMinus[{a,#},{ia,s1[[2,idxPos[[1]]]]}],
FMinus[{a_,b_},{ia_,s2[[2,idxPos[[2]]]]}]:>FMinus[{a,#},{ia,s2[[2,idxPos[[2]]]]}]
})]
]&
,allFields];
Return[LTrunc[setup,ret]];
];
If[subObj[[1,1]][[idxPos[[1]]]]=!=GetPartnerField[subObj[[2,1]][[idxPos[[2]]]]],Message[indices::inconsistentFieldContractions,{subObj[[1,1]][[idxPos[[1]]]],subObj[[2,1]][[idxPos[[2]]]]},expr];Abort[]];
Abort[];
];

Truncate[setup_,expr_]:=Module[{ret,
mmap=If[Total[Length/@(List@@FEq[expr])]>10,ParallelMap,Map]
},
AssertFSetup[setup];
If[KeyFreeQ[setup,"Truncation"],Message[Truncate::noTruncation];Abort[]];
If[MemberQ[expr,FDOp[__],Infinity],Message[Truncate::FDOp];Abort[]];

ret=mmap[LTrunc[setup,#]&,FEq[expr]];
ret=ReduceIndices[setup,ret];
OrderFields[setup,FixIndices[setup,#]&/@ret]
];


(* ::Input::Initialization:: *)
(*Given a user-defined term or master equation, give all (closed) indices unique names.*)
FixIndices[setup_,expr_]:=Module[{
indices,newIndices,replacements,indexedObjects,
ret=expr
},
AssertFSetup[setup];

(*Indices should be fixed on a per-term basis to ensure we do not mess up things*)
If[FEqQ[ret],
Return[FixIndices[setup,#]&/@ret];
];

If[FTermQ[ret],

(*First, take care of nested sub-terms*)
ret=FTerm@@((List@@ret)/.FTerm[a__]:>FixIndices[setup,FTerm[a]]);

(*Now check if everything is alright*)
If[Not@SuperIndicesValid[setup,ret],Print["Invalid superindices: ",ret];Abort[]];

indices=GetClosedSuperIndices[setup,ret];
newIndices=Map[
Unique[
StringReplace[ToString[#],i:DigitCharacter..:>""]
]&,
indices];
replacements=Thread[indices->newIndices];

Return[ret/.replacements];
];

Print["Expression \"",expr,"\" is neither a term nor a master equation!"];Abort[];
];


(* ::Input::Initialization:: *)
FDOp::cannotProcess="The FDOp in `1` cannot be processed. Please expand the term first";
FDOpCount[expr_]:=Module[{i},
expr//.Power[FDOp[a__],n_Integer]/;n<0:>(Message[FDOp::cannotProcess,expr];Abort[]);
expr//.Power[FDOp[a__],n_Integer]:>NonCommutativeMultiply@@(Table[FDOp[a],{i,1,n}])//Count[{#},FDOp[___],Infinity]&
];


(* ::Input::Initialization:: *)
FTerm::GrassmannCountError="The factor `1` has multiple Grassmanns in a single factor.";
FTerm::FDOpCountError="The factor `1` has multiple FDOps in a single factor.";FTerm::GrassmannOpen="The factor `1` has open Grassmann factors.";

(* Simplify a term appearing in an equation. Try to merge as many factors as possible, while not changing the Grassmann structure of the term.
*)
ReduceFTerm[setup_,term_]:=Module[
{reduced=List@@term,
mergeGrassmanFactors,
curRedIg,nextRedIg,curGCount,nextGCount,
i,ignore},

AssertFSetup[setup];
AssertFTerm[term];

(*Reduce nested FTerms and such first*)
reduced=reduced/.FEq[a__]:>ReduceFEq[setup,FEq[a]];
(*TODO: find a way to not reduce terms twice*)
reduced=reduced/.FTerm[a__]:>ReduceFTerm[setup,FTerm[a]];
(*TODO: Ensure that nested terms are Grassmann-neutral*)
reduced/.FTerm[a__]:>If[Mod[GrassmannCount[setup,FTerm[a]],2]=!=0,Message[FTerm::GrassmannOpen,FTerm[a]];Abort[]];

(*Merge scalar terms with the closest Grassman term. We need to "vanish" nested FTerms, to make sure we do not overcount.*)
i=1;
While[i<Length[reduced],
curRedIg=reduced[[-i]]/.FTerm[__]:>ignore;
nextRedIg=reduced[[-i-1]]//.FTerm[__]:>1;
curGCount=GrassmannCount[setup,curRedIg];
nextGCount=GrassmannCount[setup,nextRedIg];

If[FDOpCount[curRedIg]>1,
Message[FTerm::FDOpCountError,curRedIg];Abort[]];
If[curGCount>1,
Message[FTerm::GrassmannCountError,reduced[[-i]]];Abort[]];

If[(curGCount==0||nextGCount==0)&&
(FDOpCount[curRedIg]==0&&FDOpCount[nextRedIg]==0)&&
(And@@Map[FreeQ[curRedIg,#,{1,5}]&,$OrderedObjects])&&
(And@@Map[FreeQ[nextRedIg,#,{1,5}]&,$OrderedObjects]),
reduced=Join[reduced[[;;-i-2]],{reduced[[-i-1]]*reduced[[-i]]},reduced[[-i+1;;]]],
i++
];
];

If[FDOpCount[reduced[[1]]//.FTerm[__]:>1]>1,
Message[FTerm::FDOpCountError,reduced[[1]]];Abort[]];
If[GrassmannCount[setup,reduced[[1]]//.FTerm[__]:>1]>1,
Message[FTerm::GrassmannCountError,reduced[[1]]];Abort[]];

reduced=OrderFields[setup,reduced];

Return[FTerm@@reduced];
];


(* ::Input::Initialization:: *)
ReduceFEq[setup_,equation_]:=Module[
{reduced=equation},

AssertFSetup[setup];
AssertFEq[reduced];

(*Amend the index structure*)
reduced=FixIndices[setup,reduced];

(*Make sure all terms are reduced*)
reduced=ReduceFTerm[setup,#]&/@reduced;

Return[reduced];
];


(* ::Input::Initialization:: *)
FExpand[setup_,expr_,order_Integer]:=Module[{ret=expr,n,i},
ret=ret//.Power[a_FTerm,b_]/;FreeQ[a,FDOp[__]]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{a,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,a],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_,b_FTerm]/;FreeQ[b,FDOp[__]]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{b,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,b],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_FEq,b_]/;FreeQ[a,FDOp[__],{2}]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{a,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,a],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_,b_FEq]/;FreeQ[b,FDOp[__],{2}]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{b,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,b],{i,1,n}]
]
,{n,0,order}];
ret
];


(* ::Input::Initialization:: *)
DExpand[setup_,expr_,order_Integer]:=Module[{ret=expr,n,i},
(*We need to block the FDOp definitions to use SeriesCoefficient with FDOp*)
Block[{FDOp},
ret=ret//.Power[a_FTerm,b_]/;MemberQ[{a},FDOp[__],Infinity]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{a,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,a],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_,b_FTerm]/;MemberQ[{b},FDOp[__],Infinity]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{b,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,b],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_FEq,b_]/;MemberQ[{a},FDOp[__],Infinity]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{a,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,a],{i,1,n}]
]
,{n,0,order}];
ret=ret//.Power[a_,b_FEq]/;MemberQ[{b},FDOp[__],Infinity]:>FEq@@Table[FTerm[
SeriesCoefficient[a^b,{b,0,n}]**NonCommutativeMultiply@@Table[FixIndices[setup,b],{i,1,n}]
]
,{n,0,order}];
];
ret
];


(* ::Input::Initialization:: *)
ResolveFDOp::nested="The given term contains nested FDOp. Before proceeding, you need to expand these with DExpand. 
Error in `1`";

$t={0,0,0,0,0,0,0};

(*Resolve a single occurence of FDOp*)
ResolveFDOp[setup_,feq_FEq]:=Module[
{},
Return[FEq@@Map[ResolveFDOp[setup,#]&,List@@feq]];
];
ResolveFDOp[setup_,term_FTerm]:=Module[
{rTerm=term,
FDOpPos,
termsNoFDOp,dF,
idx,i,obj,ind,a,
dTerms,nPre,nPost,ret,cTerm,doFields,
$s={0,0,0,0,0,0,0,0}
},

(*We cannot proceed if any nested FDOp are present*)
If[MemberQ[(List@@rTerm),FTerm[pre___,FDOp[__],post___],{1,5}],Message[ResolveFDOp::nested,term];Abort[]];

(*If no derivatives are present, do nothing*)
If[FreeQ[rTerm,FDOp[__]],Return[rTerm]];

FDOpPos=Length[rTerm]-FirstPosition[Reverse@(List@@rTerm),FDOp[_]][[1]]+1;
termsNoFDOp=rTerm[[1;;FDOpPos-1]]**rTerm[[FDOpPos+1;;]];

(*If the derivative operator is trailing, simply remove it*)
If[FDOpPos>=Length[rTerm],Return[termsNoFDOp]];

dF=rTerm[[FDOpPos,1]];

(*Perform the product rule*)
nPre=FDOpPos-1;
nPost=Length[rTerm]-FDOpPos;

(*commuting it past*)
cTerm=1;
dTerms=Table[0,{idx,1,nPost}];
doFields=Thread[(#[a__]&/@GetAllFields[setup])->(#[{#},{a}]&/@GetAllFields[setup])];
Do[
dTerms[[idx]]=termsNoFDOp[[;;nPre+idx-1]]**FTerm[cTerm*FunctionalD[termsNoFDOp[[nPre+idx]],dF]]**termsNoFDOp[[nPre+idx+1;;]];

obj=ExtractObjectsWithIndex[setup,FTerm[termsNoFDOp[[nPre+idx]]]];
obj=Select[obj,MemberQ[$OrderedObjects,Head[#]]||MatchQ[#,_Symbol[_]]&];
obj=obj/.doFields;
(*Commuting the next derivative past the objects in the current part*)
cTerm=cTerm*Times@@Map[
FMinus[{Head[dF],#[[1]]},{dF[[1]],#[[2]]}]&,
Transpose[{Flatten[obj[[All,1]]],Flatten[obj[[All,2]]]}]
];

,{idx,1,nPost}
];

Return[ReduceFEq[setup,FEq@@dTerms]];
];


(* ::Input::Initialization:: *)
ResolveDerivatives::argument="The given argument is neither an FTerm nor a FEq.
The argument was `1`";
(*Iteratively resolve all derivative operators in an FTerm or FEq*)
ResolveDerivatives[setup_,expr_]:=Module[{ret=expr,i=1,mmap},
AssertFSetup[setup];

If[FreeQ[ret,FDOp[__],Infinity],Return[ReduceFEq[setup,FEq[ret]]]];

If[FTermQ[ret],
While[MemberQ[ret,FDOp[__],Infinity]&&i<$MaxDerivativeIterations,
ret=ResolveFDOp[setup,ret];
i++;
];
Return[ret];
];

If[FEqQ[ret],
mmap=If[Total[Length/@(List@@FEq[expr])]>10,ParallelMap,Map];
Return[FEq@@mmap[ResolveDerivatives[setup,#]&,List@@ret]];
];

Message[ResolveDerivatives::argument,ret];Abort[];
];


(* ::Input::Initialization:: *)
Protect[OutputLevel,SuperIndexForm,FieldIndices];
Options[TakeDerivatives]={OutputLevel->SuperIndexForm};


(* ::Input::Initialization:: *)
(* Perform multiple functional derivatives on a master equation.*)
TakeDerivatives[setup_,expr_,derivativeList_,OptionsPattern[]]:=Module[
{result,
externalIndexNames,outputReplacements,
derivativeListSIDX
},

AssertFSetup[setup];
AssertFEq[expr];
AssertDerivativeList[setup,derivativeList];

(*While doing the derivatives, we want to use super-indices. Afterwards, we can replace these again with the given indices*)
externalIndexNames=Map[Unique["eI"]&,derivativeList];
outputReplacements=Thread[externalIndexNames->Map[#[[1]]&,derivativeList]];
derivativeListSIDX=Table[Head[derivativeList[[i]]][externalIndexNames[[i]]],{i,1,Length[derivativeList]}];

(*We take them in reverse order.*)
derivativeListSIDX=Reverse[derivativeListSIDX];

(*First, fix the indices in the input equation, i.e. make everything have unique names*)
result=FixIndices[setup,expr];
(*Perform all the derivatives, one after the other*)
Do[
result=ResolveDerivatives[setup,FTerm[FDOp[derivativeListSIDX[[pass]]]]**result]
,
{pass,1,Length[derivativeList]}
];

If[OptionValue[OutputLevel]===SuperIndexForm,
Return[ {result,outputReplacements}];
];

Return[result//.outputReplacements];
];


(* ::Input::Initialization:: *)
WetterichEquation:=Module[{a,b},
FEq[FTerm[Propagator[{AnyField,AnyField},{a,b}],Rdot[{AnyField,AnyField},{-a,-b}]/2]]
];



