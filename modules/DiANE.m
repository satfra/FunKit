(* ::Package:: *)

(* ::Input:: *)
(*SetOptions[EvaluationNotebook[],AutoGeneratedPackage->"DiANE.m"]*)


(* ::Title:: *)
(*DiANE - Diagram Arts and Notation of Equations*)


(* ::Section:: *)
(*Exports*)


(* ::Input::Initialization:: *)
FPrint::usage="";

FTex::usage="";

FPlot::usage="";

AddTexStyles::usage="";

SetTexStyles::usage="";


(* ::Section:: *)
(*Begin Private*)


Begin["`Private`"]


(* ::Section:: *)
(*Global setup redefinitions*)


(* ::Input::Initialization:: *)
FPrint[expr_]/;Head[$GlobalSetup]=!=Symbol:=FPrint[$GlobalSetup,expr];

FTex[expr_]/;Head[$GlobalSetup]=!=Symbol:=FTex[$GlobalSetup,expr];

FPlot[expr_]/;Head[$GlobalSetup]=!=Symbol:=FPlot[$GlobalSetup,expr];


(* ::Section:: *)
(*Global variables*)


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FEDeriK"];
Abort[];
];

If[ModuleLoaded[AnSEL]=!=True,
Message[ModuleLoaded::dependency,"DiANE","AnSEL"];
Abort[];
];

ModuleLoaded[DiANE]=True;


(* ::Section:: *)
(*Pretty printing and LaTeX*)


(* ::Subsection::Closed:: *)
(*Index list formatting*)


(* ::Input::Initialization:: *)
MakeTexIndexList[{i__}]:=Module[
{
ni=Length[{i}],
isLower,
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];
indices=Table[If[isLower[[idx]],-indices[[idx]],indices[[idx]]],{idx,1,ni}];

lowerList=Table[
If[isLower[[idx]],
ToString@TeXForm[indices[[idx]]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}",
ToString@TeXForm[indices[[idx]]]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
MakeIdxField[f_,i_,up]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],-i,i]]
MakeIdxField[f_,i_,down]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],i,-i]]
MakeIdxField[f_,i_]:=Module[{isLower,idx},
isLower=MatchQ[i,Times[-1,_]];
idx=If[isLower,-i,i];
If[f===AnyField,Return[ToString[TeXForm[idx]]]];
If[isLower,Return[ToString@TeXForm[Subscript[f,idx]]]];
Return[ToString@TeXForm[Superscript[f,idx]]]
]

MakeTexIndexList[{f__},{i__}]:=Module[
{
ni=Length[{f}],
isLower,
fields={f},
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];

lowerList=Table[
If[isLower[[idx]],
MakeIdxField[fields[[idx]],indices[[idx]],up],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}",
MakeIdxField[fields[[idx]],indices[[idx]],up]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Subsection::Closed:: *)
(*Prettify closed indices*)


(* ::Input::Initialization:: *)
$availableIndices=Join[Alphabet["English"],Alphabet["English","CommonAlphabetUpper"],Alphabet["Greek"]];


(* ::Input::Initialization:: *)
ClearAll[prettySuperIndices,prettyExplicitIndices];
prettySuperIndices::type="Unknown type `1`";

prettySuperIndices[setup_,expr_FEx]:=Map[prettySuperIndices[setup,#]&,expr];
prettySuperIndices[setup_,expr_FTerm]:=Module[{closedIndices,openIndices,repl,indices},
closedIndices=GetClosedSuperIndices[setup,expr];
openIndices=GetOpenSuperIndices[setup,expr];
indices=$availableIndices;
Do[
indices=Select[indices,#=!=ToString[openIndices[[i]]]&],
{i,1,Length[openIndices]}
];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]];
Return[expr//.repl]
];
prettySuperIndices[setup_,expr_Association]/;isLoopAssociation[expr]:=Association[Normal[expr]/.FEx[a___]:>prettySuperIndices[setup,Print[1];FEx[a]]]
prettySuperIndices[setup_,expr_List]:=Map[prettySuperIndices[setup,#]&,Print[3];expr];
prettySuperIndices[setup_,expr_Association]/;isRoutedAssociation[expr]:=Association@Map[prettySuperIndices[setup,#]&,Print[2];Normal@expr];
prettySuperIndices[setup_,a_]:=(Message[prettySuperIndices::type,Head@a];Abort[])



(* ::Input::Initialization:: *)
prettyExplicitIndices::type="Unknown type `1`";

prettyExplicitIndices[setup_,expr_FEx]:=Map[prettyExplicitIndices[setup,#]&,expr];
prettyExplicitIndices[setup_,expr_FTerm]:=Module[{allIndices,closedIndices,openIndices,repl,indices,ret=expr},
allIndices=Select[ExtractObjectsAndIndices[setup,expr][[2]],Head[#]===List&];
allIndices=Map[
If[Length[#]===2,
#,
ret=ret/.#->Join[#,{Hash[Sort@{#,-#}]}];
Join[#,{Hash[Sort@{#,-#}]}]
]&,allIndices];
allIndices=allIndices[[All,2]];
closedIndices=Pick[allIndices,Count[allIndices,#]===2&/@allIndices];
openIndices=Pick[allIndices,Count[allIndices,#]=!=2&/@allIndices];
indices=$availableIndices;
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]]\[Union]Thread[openIndices->indices[[Length[closedIndices]+1;;Length[closedIndices]+Length[openIndices]]]];
Return[ret//.repl]
];
prettyExplicitIndices[setup_,expr_Association]/;isLoopAssociation[expr]:=Association[Normal[expr]/.FEx[a___]:>prettyExplicitIndices[setup,FEx[Print[1];a]]]
prettyExplicitIndices[setup_,expr_List]:=Map[prettyExplicitIndices[setup,#]&,expr];
prettyExplicitIndices[setup_,expr_Association]/;isRoutedAssociation[expr]:=Association@Map[prettyExplicitIndices[setup,#]&,Print[2];Normal@expr];
prettyExplicitIndices[setup_,a_]:=(Message[prettyExplicitIndices::type,Head@a];Abort[])



(* ::Subsection:: *)
(*General formatting definitions*)


(* ::Input::Initialization:: *)
$TexStyles={};
$Fields={};


(* ::Input::Initialization:: *)
AddTexStyles::invalidRule="The given set of style rules does not follow the pattern Symbol->String.";

AddTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[Join[$TexStyles,{a}]];
]

SetTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[{a}];
]

SetTexStyles[]:=Module[{},
$TexStyles={};
]


(* ::Input::Initialization:: *)
isLoopAssociation[expr_]:=Module[{},
If[Head[expr]=!=Association,Return[False]];
If[FreeQ[Keys[expr],"Expression"],Return[False]];
If[FreeQ[Keys[expr],"ExternalIndices"],Return[False]];
If[FreeQ[Keys[expr],"LoopMomenta"],Return[False]];
Return[True];
];
isRoutedAssociation[expr_]:=Module[{},
If[Head[expr]=!=Association,Return[False]];
Return@AllTrue[expr,isLoopAssociation]
];


(* ::Input::Initialization:: *)
RenewFormatDefinitions[]:=Module[{},

Unprotect[FDOp,GammaN,Propagator,Rdot,FTerm,FEx,\[Gamma],\[Delta],FMinus,S];
Unprotect@@$allObjects;

(*Field formatting with superindices*)
Map[
(
Format[Keys[#][any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>arg]
];
Format[Superscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>"^{"<>arg<>"}"]
];
Format[Subscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>"_{"<>arg<>"}"]
];
)&,
$TexStyles\[Union]Select[$Fields,FreeQ[Keys[$TexStyles],Keys[#]]&]];

(*Field formatting with explicit indices*)
Map[
(
Format[Keys[#][{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>arg<>"("<>ToString[TeXForm[p]]<>")"]
];
Format[Superscript[Keys[#],{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>"^{"<>arg<>"}("<>ToString[TeXForm[p]]<>")"]
];
Format[Subscript[Keys[#],{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXUtilities`TeXVerbatim[head<>"_{"<>arg<>"}("<>ToString[TeXForm[p]]<>")"]
];
)&,
$TexStyles\[Union]Select[$Fields,FreeQ[Keys[$TexStyles],Keys[#]]&]];

(*Other formatting*)
Format[FDOp[f_],TeXForm]:=Module[{},
TeXUtilities`TeXDelimited["\\frac{\\delta}{\\delta",f,"}"]
];

Map[
(Format[#[{f__},{i__}],TeXForm]:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[(#//.$TexStyles)=!=#,ret=(#//.$TexStyles)];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXUtilities`TeXVerbatim[ret]
])&,
$allObjects];

Map[
(Format[#[{f__},{i__}],TeXForm]/;AllTrue[{i},(Head[#]===List)&]:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},-{i}[[All,2]]];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[(#//.$TexStyles)=!=#,ret=(#//.$TexStyles)];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXUtilities`TeXVerbatim[ret<>"("<>StringRiffle[Map[ToString@TeXForm[#]&,{i}[[All,1]]],","]<>")"]
])&,
$allObjects];

Format[FTerm[a__],TeXForm]:=Module[{obj,integrals,replNames,idx,prefix,postfix,body={a}},
integrals=Pick[$availableLoopMomenta,Map[MemberQ[{a},#,Infinity]&,$availableLoopMomenta]];
replNames=Thread[$availableLoopMomenta->Table[Subscript[Symbol[$loopMomentumName],idx],{idx,1,Length[$availableLoopMomenta]}]];
prefix=StringJoin[Map["\\int_{"<>ToString[TeXForm[#]]<>"}"&,integrals//.replNames]];
postfix="";

If[MatchQ[{a}[[1]],b_/;NumericQ[b]&&b<0],
If[{a}[[1]]===-1,
prefix=prefix<>"(-";
postfix=")"<>postfix;
body=body[[2;;]];
,
prefix=prefix<>"(";
postfix=")"<>postfix;
]
];

body=body//.replNames;
body=body//.Map[#->Subscript[Symbol[StringTake[SymbolName[#],{1}]],ToExpression@StringTake[SymbolName[#],{2,-1}]]&,
Select[GetAllSymbols[body],StringMatchQ[SymbolName[#],LetterCharacter~~DigitCharacter..]&]
];

TeXUtilities`TeXDelimited[prefix,##,postfix,
"DelimSeparator"->"","BodySeparator"->"\\,",
(*It is not clear why the call to RenewFormatDefinitions[] is necessary here. However, removing it leads to TeXForm ignoring all custom TeXStyles.*)
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)
]&@@body
];

Format[FTerm[],TeXForm]:=Module[{},
TeXUtilities`TeXVerbatim["1"]
];

Format[FEx[a___],TeXForm]:=If[Length[Flatten[(List@@#&)/@{a}]]<=9,
TeXUtilities`TeXDelimited["",a,"",
"DelimSeparator"->"","BodySeparator"->"\n\\,+\\,",
"BodyConverter"->(ToString[Format[#,TeXForm]]&)],
TeXUtilities`TeXDelimited["\\begin{aligned}\\  &",a,"\n\\end{aligned}",
"DelimSeparator"->"","BodySeparator"->"\n\\\\ &\\,+\\,",
"BodyConverter"->(ToString[Format[#,TeXForm]]&)]
];

Unprotect[Association];
Format[Association[a__],TeXForm]/;isRoutedAssociation[Association[a]]:=Module[{parts},
parts=(List@@Association[a])[[All,Key["Expression"]]];
parts=ToString[TeXForm[FEx[#]]]&/@parts;

parts=Join[
{parts[[1]]},
Map[
If[StringTake[#,{1,17}]==="\\begin{aligned}&\n",
StringJoin[{"\\begin{aligned}&\n\\,+\\,",StringTake[#,{18,-1}]}],
StringJoin[{"\\,+\\,",#}]]&,
parts[[2;;]]]
];

TeXUtilities`TeXVerbatim["\\begin{aligned}&\n"<>
StringRiffle[parts,"\n \\\&\n"]<>
"\n\\end{aligned}"]
];
Protect[Association];


Protect[FDOp,GammaN,Propagator,Rdot,FTerm,FEx,\[Gamma],\[Delta],FMinus,S];
Protect@@$allObjects;
];


(* ::Subsection::Closed:: *)
(*FPrint and FTex commands*)


(* ::Input::Initialization:: *)
(*Turn a given expression into LaTeX code*)
FTex[setup_,expr_]:=Module[
{prExp=expr,fields},
AssertFSetup[setup];
fields=GetAllFields[setup];

FunKitDebug[1,"Creating LaTeX expression"];

(*update the formatting definitions for TeXForm*)
$Fields=Thread[fields->Map[ToString[TeXForm[#]]&,fields]];
RenewFormatDefinitions[];

(*Assign human-readable superindices*)
prExp=prettySuperIndices[setup,prExp];
prExp=prettyExplicitIndices[setup,prExp];

(*make fields with indices to sub-/super-script*)
prExp=prExp//.Map[#[Times[-1,a_]]:>Subscript[#,a]&,fields]//.Map[#[a_]:>Superscript[#,a]&,fields];

(*For correct rendering, fully expand any FTerms*)
prExp=prExp//.FTerm[pre___,Times[a_,b_],post___]:>FTerm[pre,a,b,post];

Return[prExp//TeXForm//ToString];
];

FTex[setup_,expr_List]/;AllTrue[expr,(Head[#]===FEx||Head[#]===FTerm)&]:=FTex[setup,FEx@@expr];

(*For the output of a full routing*)
FTex[setup_,expr_Association]/;isRoutedAssociation@expr:=FTex[setup,(List@@expr)[[All,Key["Expression"]]]];
FTex[setup_,expr_Association]/;isLoopAssociation@expr:=FTex[setup,expr["Expression"]];

(*For direct printing*)
FPrint[setup_,expr_]:=(Print[FTex[setup,expr]//MaTeX`MaTeX];Return[expr]);



(* ::Section:: *)
(*Diagram drawing*)


(* ::Input::Initialization:: *)
MakeEdgeRule[setup_,obj_]:=Module[{},
If[IsAntiFermion[setup,obj[[1,1]]]&&IsFermion[setup,obj[[1,2]]],Return [makePosIdx@obj[[2,1]]->makePosIdx@obj[[2,2]]]];
If[IsFermion[setup,obj[[1,1]]]&&IsAntiFermion[setup,obj[[1,2]]],Return [makePosIdx@obj[[2,2]]->makePosIdx@obj[[2,1]]]];
Return [makePosIdx@obj[[2,1]]<->makePosIdx@obj[[2,2]]];
];


(* ::Input::Initialization:: *)
 crosscircle[r_] := Graphics[{Thick, Line[{{r / Sqrt[2], r / Sqrt[2]
            }, {-r / Sqrt[2], -r / Sqrt[2]}}], Line[{{r / Sqrt[2], -r / Sqrt[2]},
             {-r / Sqrt[2], r / Sqrt[2]}}], Circle[{0, 0}, r]}];
 cross[r_] := Graphics[{ Line[{{r / Sqrt[2], r / Sqrt[2]
            }, {-r / Sqrt[2], -r / Sqrt[2]}}], Line[{{r / Sqrt[2], -r / Sqrt[2]},
             {-r / Sqrt[2], r / Sqrt[2]}}]}];
$standardVertexStyles={
GammaN->Graphics@Style[Disk[{0,0},0.5],Gray],
S->Graphics@Style[Disk[{0,0}],Black],
Rdot->crosscircle[1],
Field->cross[1],
R->Graphics@Style[Disk[{0,0},2],Blue]
};
$standardVertexSize={
GammaN->0.15,
S->0.05,
Rdot->0.25,
Field->0.1,
R->0.2
};


(* ::Input::Initialization:: *)
arcFunc[g_,r_:1.5][list_,DirectedEdge[x_,x_]]:=With[{v=DynamicLocation["VertexID$"<>ToString[VertexIndex[g,x]],Automatic,Center]},Arrow[BezierCurve[Join[{v},ScalingTransform[r {1,1},list[[1]]][list[[{5,8,10,16,18,21}]]],{v}],SplineDegree->7]]]
arcFuncUn[g_,r_:1.5][list_,UndirectedEdge[x_,x_]]:=With[{v=DynamicLocation["VertexID$"<>ToString[VertexIndex[g,x]],Automatic,Center]},Arrow[BezierCurve[Join[{v},ScalingTransform[r {1,1},list[[1]]][list[[{5,8,10,16,18,21}]]],{v}],SplineDegree->7]]]


(* ::Input::Initialization:: *)
FPlot::FDOp="Cannot plot diagrams with unresolved derivative operators!";

GetDiagram[setup_,expr_FTerm]:=Module[
{PossibleVertices,PossibleEdges,Styles,diag,
allObj,fieldObj,vertices,edges,vertexReplacements,graph,phantomVertices,edgeFields,
fieldVertices,fieldEdges,fieldEdgeFields,oidx,
externalVertices,externalEdges,externalFields,idx,prefactor,doFields,eWeights,addVertexSizes={}},
If[MemberQ[expr,FDOp[__],Infinity],Message[FPlot::FDOp];Abort[]];

diag=FUnroute[setup,expr];

doFields=replFields[setup];

PossibleVertices=Join[{GammaN,S,Rdot,Field,R},
If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Vertices"],
setup["DiagramStyling"]["Vertices"],{}]];
PossibleEdges=Join[{Propagator},
If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Edges"],
setup["DiagramStyling"]["Edges"],{}]];
Styles=If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Styles"],
setup["DiagramStyling"]["Styles"],
Thread[(#->ColorData[97,"ColorList"][[1;;Length[#]]])&@DeleteDuplicates[GetAllFields[setup]/.Map[#[[1]]->#[[2]]&,GetFieldPairs[setup]]]]
];
Styles=Join[Styles,Map[GetPartnerField[setup,#[[1]]]->#[[2]]&,Select[Styles,HasPartnerField[setup,#[[1]]]&]]];
If[FreeQ[Keys[Styles],AnyField],Styles=Join[Styles,{AnyField->{Blue,Dotted}}]];

allObj=ExtractObjectsWithIndex[setup,diag]//.doFields;
fieldObj=Flatten[Select[allObj,Head[#]===Field&]/.Field[{f_},{i_}]:>Module[{oi},{Propagator[{f,GetPartnerField[setup,f]},{oi,i}],Field[{f},{oi}]}]];
allObj=Select[allObj,Head[#]=!=Field&];

(*prepare vertices*)
vertices=Select[allObj,
MemberQ[PossibleVertices,Head[#]]&&
(FreeQ[PossibleEdges,Head[#]]||Length[#[[2]]]=!=2)&
];
vertexReplacements=Flatten@Module[{v},Map[(v=Unique["v"];Map[(makePosIdx[#]->v)&,#[[2]]])&,vertices]];
vertices=Map[Head[#]@@((makePosIdx/@#[[2]]/.vertexReplacements)//DeleteDuplicates)&,vertices];

(*Props and vertices for attached fields*)
fieldVertices=Select[fieldObj,(Head[#]===Field)&];
fieldVertices=Map[Head[#]@@((makePosIdx/@#[[2]]/.vertexReplacements)//DeleteDuplicates)&,fieldVertices];
fieldEdges=Select[fieldObj,(Head[#]=!=Field)&];
fieldEdgeFields=Table[SelectFirst[fieldEdges[[idx,1]],MemberQ[Styles,#,Infinity]&],{idx,1,Length[fieldEdges]}];
fieldEdges=Map[MakeEdgeRule[setup,#]&,fieldEdges/.vertexReplacements];
fieldEdges=Table[Style[fieldEdges[[idx]],##]&@@Flatten@{fieldEdgeFields[[idx]]/.Styles},{idx,1,Length[fieldEdges]}];

(*prepare edges*)
edges=Select[allObj,
MemberQ[PossibleEdges,Head[#]]&&
Length[#[[2]]]===2&
];
edgeFields=Table[SelectFirst[edges[[idx,1]],MemberQ[Styles,#,Infinity]&],{idx,1,Length[edges]}];
edges=Map[MakeEdgeRule[setup,#]&,edges/.vertexReplacements];
edges=Table[Style[edges[[idx]],##]&@@Flatten@{edgeFields[[idx]]/.Styles},{idx,1,Length[edges]}];

(*Add additional vertices for external indices*)
externalVertices=GetOpenSuperIndices[setup,diag];
externalFields=Table[SelectFirst[allObj,MemberQ[makePosIdx/@#[[2]],externalVertices[[idx]]]&],{idx,1,Length[externalVertices]}];
externalFields=Table[
externalFields[[idx,1,FirstPosition[makePosIdx/@externalFields[[idx,2]],externalVertices[[idx]]][[1]]]]
,{idx,1,Length[externalVertices]}];
externalVertices=Unique/@externalVertices;
externalEdges=Table[
MakeEdgeRule[setup,Propagator[{GetPartnerField[setup,externalFields[[idx]]],externalFields[[idx]]},{externalVertices[[idx]],GetOpenSuperIndices[setup,diag][[idx]]/.vertexReplacements}]]
,{idx,1,Length[externalVertices]}];
externalEdges=Table[Style[externalEdges[[idx]],##]&@@Flatten@{externalFields[[idx]]/.Styles},{idx,1,Length[externalEdges]}];

phantomVertices=Table[Symbol["phantom"<>ToString[idx]],{idx,1,Length[edges]}];
(*edges=Flatten@Table[{Head[edges[[idx]]][edges[[idx,1]],phantomVertices[[idx]]],Head[edges[[idx]]][phantomVertices[[idx]],edges[[idx,2]]]},{idx,1,Length[edges]}];*)

(*get the prefactor*)
prefactor=Times@@(diag/.doFields/.Map[Blank[#]->1&,Join[{Field},$allObjects]]);

oidx=GetOpenSuperIndices[setup,diag];
Do[
If[MemberQ[externalEdges,oidx[[idx]],Infinity],
AppendTo[addVertexSizes,oidx[[idx]]->0.00001]
];
,{idx,1,Length[GetOpenSuperIndices[setup,diag]]}];

graph=Graph[Join[vertices[[All,1]],externalVertices,fieldVertices[[All,1]]],Join[edges,externalEdges,fieldEdges],
VertexShape->Join[
Thread[vertices[[All,1]]->(vertices[[All,0]]/.$standardVertexStyles)],
Thread[externalVertices->Map[Graphics@Style[Disk[{0,0},0.0],Gray]&,externalVertices]],
Thread[fieldVertices[[All,1]]->(fieldVertices[[All,0]]/.$standardVertexStyles)]
],
VertexSize->Join[
Thread[vertices[[All,1]]->(vertices[[All,0]]/.$standardVertexSize)],
addVertexSizes
],
GraphLayout->{"SpringElectricalEmbedding"},
PerformanceGoal->"Quality",
ImageSize->Small,
EdgeStyle->Arrowheads[{{.07,.6}}]
];

prefactor*Graph[graph,
EdgeShapeFunction->{x_\[DirectedEdge]x_:>arcFunc[graph,20.0],x_\[UndirectedEdge]x_:>arcFuncUn[graph,20.0]}]
];

FPlot[setup_,expr_FTerm]:=Module[{},
Print[GetDiagram[setup,expr]];
Return@expr
];

FPlot[setup_,expr_FEx]:=Module[{},
Print[Plus@@(GetDiagram[setup,#]&/@expr)];
Return@expr
];

FPlot[setup_,expr_Association]/;isLoopAssociation[expr]:=Module[{},
FPlot[setup,expr["Expression"]];
Return@expr
];

FPlot[setup_,expr_Association]/;isRoutedAssociation@expr:=Module[{},
FPlot[setup,(List@@routedAssociation)[[All,Key["Expression"]]]];
Return@expr
];

FPlot::type="Unknown type `1`";
FPlot[setup_,a_]:=(Message[FPlot::type,Head[a]];Abort[])



(* ::Section:: *)
(*End Private*)


End[];
