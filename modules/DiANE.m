(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
FPrint::usage=""
FPrint[expr_]/;Head[$GlobalSetup]=!=Symbol:=FPrint[$GlobalSetup,expr];

FTex::usage=""
FTex[expr_]/;Head[$GlobalSetup]=!=Symbol:=FTex[$GlobalSetup,expr];


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FEDeriK"];
Abort[];
];

ModuleLoaded[DiANE]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
If[Length@PacletFind["MaTeX"]===0,
ResourceFunction["MaTeXInstall"][]
]
Get["MaTeX`"]
Import[$FunKitDirectory<>"/utils/MathematicaTeXUtilities.m"]


(* ::Input::Initialization:: *)
MakeTexIndexList[{i__}]:=Module[
{
ni=Length[{i}],
isLower,
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];
indices=Table[If[isLower[[idx]],-indices[[idx]],indices[[idx]]],{idx,1,ni}];

lowerList=Table[
If[isLower[[idx]],
ToString@TeXForm[indices[[idx]]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}",
ToString@TeXForm[indices[[idx]]]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
MakeIdxField[f_,i_,up]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],-i,i]]
MakeIdxField[f_,i_,down]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],i,-i]]
MakeIdxField[f_,i_]:=Module[{isLower,idx},
isLower=MatchQ[i,Times[-1,_]];
idx=If[isLower,-i,i];
If[f===AnyField,Return[ToString[TeXForm[idx]]]];
If[isLower,Return[ToString@TeXForm[Subscript[f,idx]]]];
Return[ToString@TeXForm[Superscript[f,idx]]]
]

MakeTexIndexList[{f__},{i__}]:=Module[
{
ni=Length[{f}],
isLower,
fields={f},
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];

lowerList=Table[
If[isLower[[idx]],
MakeIdxField[fields[[idx]],indices[[idx]],up],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}",
MakeIdxField[fields[[idx]],indices[[idx]],up]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
prettySuperIndices[setup_,expr_FEq]:=Map[prettySuperIndices[setup,#]&,expr];
prettySuperIndices[setup_,expr_FTerm]:=Module[{closedIndices,openIndices,repl,indices},
closedIndices=GetClosedSuperIndices[setup,expr];
openIndices=GetOpenSuperIndices[setup,expr];
indices=Alphabet[];
Do[
indices=Select[indices,#=!=ToString[openIndices[[i]]]&],
{i,1,Length[openIndices]}
];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]];
Return[expr//.repl]
];


(* ::Input::Initialization:: *)
prettyExplicitIndices[setup_,expr_FEq]:=Map[prettyExplicitIndices[setup,#]&,expr];
prettyExplicitIndices[setup_,expr_FTerm]:=Module[{allIndices,closedIndices,openIndices,repl,indices},
allIndices=Select[ExtractObjectsAndIndices[setup,expr][[2]],Head[#]===List&];
allIndices=allIndices[[All,2]];
closedIndices=Pick[allIndices,Count[allIndices,#]===2&/@allIndices];
openIndices=Pick[allIndices,Count[allIndices,#]=!=2&/@allIndices];
indices=Alphabet[];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]]\[Union]Thread[openIndices->indices[[Length[closedIndices]+1;;Length[closedIndices]+Length[openIndices]]]];
Return[expr//.repl]
];


(* ::Input::Initialization:: *)
$TexStyles={};


(* ::Input::Initialization:: *)
AddTexStyles::invalidRule="The given set of style rules does not follow the pattern Symbol->String.";

AddTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[Join[$TexStyles,{a}]];
]

SetTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[{a}];
]

SetTexStyles[]:=Module[{},
$TexStyles={};
]


(* ::Input::Initialization:: *)
RenewFormatDefinitions[]:=Module[{},

Unprotect[FDOp,GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta],FMinus,S];
Unprotect@@$allObjects;

(*Field formatting*)

Map[
(Format[Keys[#][any__],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>arg]
])&,
$TexStyles];

Map[
(Format[Superscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>"^"<>arg]
])&,
$TexStyles];

Map[
(Format[Subscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>"_"<>arg]
])&,
$TexStyles];

(*Other formatting*)

Format[FDOp[f_],TeXForm]:=Module[{},
TeXDelimited["\\frac{\\delta}{\\delta",f,"}"]
];

Format[FTerm[a___],TeXForm]:=If[MatchQ[{a}[[1]],b_/;NumericQ[b]&&b<0],
If[{a}[[1]]===-1,
TeXDelimited["(-",##,")",
"DelimSeparator"->"","BodySeparator"->"",
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)
]&@@{a}[[2;;]],
TeXDelimited["(",a,")",
"DelimSeparator"->"","BodySeparator"->"",
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)]
],
TeXDelimited["",a,"",
"DelimSeparator"->"","BodySeparator"->"",
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)]
];
Format[FEq[a___],TeXForm]:=If[Length[{a}]<=3,
TeXDelimited["",a,"",
"DelimSeparator"->"","BodySeparator"->"\,+\,",
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)],
TeXDelimited["\\begin{aligned}&",a,"\\end{aligned}",
"DelimSeparator"->"","BodySeparator"->"\\\\ &\,+\,",
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)]
];

Map[
(Format[#[{f__},{i__}],TeXForm]/;Head[{i}[[1]]]=!=List:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
])&,
$indexedObjects];

Map[
(Format[#[{f__},{i__}],TeXForm]/;Head[{i}[[1]]]===List:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},-{i}[[All,2]]];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret<>"("<>StringRiffle[Map[ToString@TeXForm[#]&,{i}[[All,1]],","],","]<>")"]
])&,
$indexedObjects];

Protect[FDOp,GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta],FMinus,S];
Protect@@$allObjects;
];


(* ::Input::Initialization:: *)
FTex[setup_,expr_]:=Module[{prExp=expr,fields},
AssertFSetup[setup];
RenewFormatDefinitions[];

prExp=prettySuperIndices[setup,prExp];
prExp=prettyExplicitIndices[setup,prExp];
fields=GetAllFields[setup];
prExp=prExp//.Map[#[Times[-1,a_]]:>Subscript[#,a]&,fields]//.Map[#[a_]:>Superscript[#,a]&,fields];
(*For correct rendering, fully expand any FTerms*)
prExp=prExp//.FTerm[pre___,Times[a_,b_],post___]:>FTerm[pre,a,b,post];
Return[prExp//TeXForm];
]

FPrint[setup_,expr_]:=FTex[setup,expr]//MaTeX

(MakeDSE[A[x]]//.A[_]:>0)[[4]]//Truncate;
%//FPrint
RouteIndices[Setup,%%][[1]];
prettyExplicitIndices[Setup,%[[1]]]
%//FPrint


(* ::Input::Initialization:: *)
GetEdgeRule[setup_,vertices_,fields_]:=Module[{fermions,bosons,sel},
If[Length[obj]!=Length[fields]||Length[obj]!=2,Print["Mismatch!"];Abort[]];
fermions=GetFermionPairs[setup];
bosons=GetBosons[setup];

If[MemberQ[fermions,fields[[1]],Infinity]&&MemberQ[fermions,fields[[2]],Infinity],
sel=Select[fermions,MemberQ[#,fields[[1]],Infinity]&][[1]];
If[fields===sel,
Return[obj[[1]]->obj[[2]]],
Return[obj[[2]]->obj[[1]]];
]
];

If[MemberQ[bosons,fields[[1]],Infinity]&&MemberQ[bosons,fields[[2]],Infinity],
Return[obj[[1]]<->obj[[2]]]
];

Print["fields ",fields," not found!"];
Abort[];
];


(* ::Input::Initialization:: *)
MakeEdgeStyle[style_,setup_]:=Module[{corStyle,havePairs,allPairs,missingPairs},
corStyle=style/.{
a_[c_,d_]/;
a===Rule&&Head[c]=!=List:>
Sort[{c,GetPartnerField[c,setup]}]->d};
corStyle=corStyle/.{a_[{c__},d_]/;a===Rule:>Sort[{c}]->d};

havePairs=corStyle/.{a_[{c__},d_]/;a===Rule:>{c}};
allPairs=Join[Map[{#,#}&,GetBosons[setup]],Map[Sort,GetFermionPairs[setup]]];
missingPairs=DeleteCases[allPairs,Alternatives@@havePairs];
corStyle=Join[corStyle,Thread[missingPairs->ColorData[97,"ColorList"][[1;;Length[missingPairs]]]]];
Return[corStyle]
];


(* ::Input::Initialization:: *)
PlotOneSuperindexDiagram[diag_,setup_,OptionsPattern[]]:=Module[
{ShowEdgeLabels,EdgeStyle,
transformedDiag,vertices,edges,prefactor,
externalLegs,externalIndices,idx,field,partnerField,outerIdx,externalLeg,
regulatorVertex,curVertex,rules,corStyle,cross,
explVertices,explEdges,vertexShapes,vertexLabels,edgeLabels,
graph},

AssertIsSuperindexDiagram[diag];

EdgeStyle=OptionValue["EdgeStyle"];
ShowEdgeLabels=OptionValue["ShowEdgeLabels"];

transformedDiag=Map[
If[Head[#]===Association,
If[#["type"]=="Propagator",
<|
"Rule"->GetEdgeRule[{#["indices"][[1,2]],#["indices"][[2,2]]},{#["indices"][[1,1]],#["indices"][[2,1]]},setup],
"Style"->Sort[{#["indices"][[1,1]],#["indices"][[2,1]]}]
|>,
<|
"Vertex"->#["indices"][[All,2]],
"Style"->#["type"]
|>],
#]&
,diag];

vertices=Select[transformedDiag,MemberQ[Keys[#],"Vertex",Infinity]&];
edges=Select[transformedDiag,MemberQ[Keys[#],"Rule",Infinity]&];
prefactor=("Prefactor"/.transformedDiag[[1]])[[1]];

externalLegs=GetExternalIndices[diag];
externalIndices={};
For[idx=1,idx<=Length[externalLegs],idx++,
field=externalLegs[[idx,1]];
partnerField=GetPartnerField[field,setup];
outerIdx=Unique[externalLeg];
externalIndices=Join[externalIndices,{outerIdx}];
vertices=vertices\[Union]{<|
"Vertex"->{{outerIdx}},
"Style"->externalLeg[field]
|>};
edges=edges\[Union]{<|
"Rule"->GetEdgeRule[{externalLegs[[idx,2]],{outerIdx}},{field,partnerField},setup],"Style"->Sort[{field,partnerField}]
|>};
];

regulatorVertex=0;
For[idx=1,idx<=Length[vertices],idx++,
curVertex=vertices[[idx]]["Vertex"];
If[Length[curVertex]>1,
rules=Map[#->curVertex[[1]]&,curVertex[[2;;]]];
vertices=vertices/.rules;
edges=edges/.rules;
];
vertices[[idx]]=<|"Vertex"->vertices[[idx]]["Vertex"][[1]],"Style"->vertices[[idx]]["Style"]|>;
If[vertices[[idx]]["Style"]=="Regulatordot",regulatorVertex=vertices[[idx]]["Vertex"]];
];

corStyle=MakeEdgeStyle[EdgeStyle,setup];

 cross[r_] := Graphics[{Thick, Line[{{r / Sqrt[2], r / Sqrt[2]
            }, {-r / Sqrt[2], -r / Sqrt[2]}}], Line[{{r / Sqrt[2], -r / Sqrt[2]},
             {-r / Sqrt[2], r / Sqrt[2]}}], Circle[{0, 0}, r]}];

explVertices=Map[#["Vertex"]&,vertices];
vertexShapes=Join[
{regulatorVertex->cross[1]}
];
vertexLabels=Map[
#["Vertex"]->(#["Style"]/.a_[b_]:>b)&
,
Select[vertices,Head[#["Style"]]===externalLeg&]
];
explEdges=Map[Style[#["Rule"],#["Style"]/.corStyle]&,edges];
edgeLabels=If[ShowEdgeLabels,
Map[#["Rule"]->ToString[#["Style"][[1]]]<>ToString[#["Style"][[2]]]&,edges],
{}
];

Return[
{prefactor,
graph=Graph[explVertices,explEdges];
Graph[graph,
VertexShape->vertexShapes,
VertexLabels->vertexLabels,
VertexSize -> {regulatorVertex -> Medium},
EdgeLabels->edgeLabels,
EdgeShapeFunction->{x_\[DirectedEdge]x_:>arcFunc[graph,20.0],x_\[UndirectedEdge]x_:>arcFuncUn[graph,20.0]},
PerformanceGoal->"Quality"
]
}
];
];
Options[PlotOneSuperindexDiagram]={"ShowEdgeLabels"->False,"EdgeStyle"->{}};

PlotSuperindexDiagram[diags_List,setup_,a___]:=Module[{},
If[AllTrue[diags,TestIsSuperindexDiagram],
Return[Map[PlotOneSuperindexDiagram[#,setup,a]&,diags]];
];
If[TestIsSuperindexDiagram[diags],
Return[PlotOneSuperindexDiagram[diags,setup,a]];
];
Print["PlotSuperindexDiagram: diagram argument is not a superindex diagram or a list thereof!"];
Abort[];
];



