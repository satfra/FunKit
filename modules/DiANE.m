(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
FPrint::usage="";
FPrint[expr_]/;Head[$GlobalSetup]=!=Symbol:=FPrint[$GlobalSetup,expr];

FTex::usage="";
FTex[expr_]/;Head[$GlobalSetup]=!=Symbol:=FTex[$GlobalSetup,expr];

PlotDiagrams::usage="";
PlotDiagrams[expr_]/;Head[$GlobalSetup]=!=Symbol:=PlotDiagrams[$GlobalSetup,expr];


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"DiANE","FEDeriK"];
Abort[];
];

ModuleLoaded[DiANE]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
If[Length@PacletFind["MaTeX"]===0,
ResourceFunction["MaTeXInstall"][]
]
Get["MaTeX`"]
Import[$FunKitDirectory<>"/utils/MathematicaTeXUtilities.m"]


(* ::Input::Initialization:: *)
MakeTexIndexList[{i__}]:=Module[
{
ni=Length[{i}],
isLower,
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];
indices=Table[If[isLower[[idx]],-indices[[idx]],indices[[idx]]],{idx,1,ni}];

lowerList=Table[
If[isLower[[idx]],
ToString@TeXForm[indices[[idx]]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>ToString@TeXForm[indices[[idx]]]<>"}",
ToString@TeXForm[indices[[idx]]]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
MakeIdxField[f_,i_,up]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],-i,i]]
MakeIdxField[f_,i_,down]:=MakeIdxField[f,If[MatchQ[i,Times[-1,_]],i,-i]]
MakeIdxField[f_,i_]:=Module[{isLower,idx},
isLower=MatchQ[i,Times[-1,_]];
idx=If[isLower,-i,i];
If[f===AnyField,Return[ToString[TeXForm[idx]]]];
If[isLower,Return[ToString@TeXForm[Subscript[f,idx]]]];
Return[ToString@TeXForm[Superscript[f,idx]]]
]

MakeTexIndexList[{f__},{i__}]:=Module[
{
ni=Length[{f}],
isLower,
fields={f},
indices={i},
lowerList,
upperList,
removeTrailingPhantoms
},

isLower=Map[MatchQ[#,Times[-1,_]]&,{i}];

lowerList=Table[
If[isLower[[idx]],
MakeIdxField[fields[[idx]],indices[[idx]],up],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}"
],
{idx,1,ni}];

upperList=Table[
If[isLower[[idx]],
"\\phantom{"<>MakeIdxField[fields[[idx]],indices[[idx]],up]<>"}",
MakeIdxField[fields[[idx]],indices[[idx]],up]
],
{idx,1,ni}];

removeTrailingPhantoms[l_]:=Module[{ret=l},
While[StringContainsQ[ret[[-1]],"\\phantom"],
ret=Delete[ret,-1];
If[Length[ret]===0,Return[{""}]];
];
Return[ret];
];

upperList=removeTrailingPhantoms@upperList;
lowerList=removeTrailingPhantoms@lowerList;

Return[{StringJoin@@lowerList,StringJoin@@upperList}]
]


(* ::Input::Initialization:: *)
prettySuperIndices[setup_,expr_FEq]:=Map[prettySuperIndices[setup,#]&,expr];
prettySuperIndices[setup_,expr_FTerm]:=Module[{closedIndices,openIndices,repl,indices},
closedIndices=GetClosedSuperIndices[setup,expr];
openIndices=GetOpenSuperIndices[setup,expr];
indices=Alphabet[];
Do[
indices=Select[indices,#=!=ToString[openIndices[[i]]]&],
{i,1,Length[openIndices]}
];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]];
Return[expr//.repl]
];
prettySuperIndices[setup_,expr_]:=expr/.FEq[a___]:>prettySuperIndices[setup,FEq[a]]


(* ::Input::Initialization:: *)
prettyExplicitIndices[setup_,expr_FEq]:=Map[prettyExplicitIndices[setup,#]&,expr];
prettyExplicitIndices[setup_,expr_FTerm]:=Module[{allIndices,closedIndices,openIndices,repl,indices},
allIndices=Select[ExtractObjectsAndIndices[setup,expr][[2]],Head[#]===List&];
allIndices=allIndices[[All,2]];
closedIndices=Pick[allIndices,Count[allIndices,#]===2&/@allIndices];
openIndices=Pick[allIndices,Count[allIndices,#]=!=2&/@allIndices];
indices=Alphabet[];
repl=Thread[closedIndices->indices[[1;;Length[closedIndices]]]]\[Union]Thread[openIndices->indices[[Length[closedIndices]+1;;Length[closedIndices]+Length[openIndices]]]];
Return[expr//.repl]
];
prettyExplicitIndices[setup_,expr_]:=expr/.FEq[a___]:>prettyExplicitIndices[setup,FEq[a]]


(* ::Input::Initialization:: *)
$TexStyles={};
$Fields={};


(* ::Input::Initialization:: *)
AddTexStyles::invalidRule="The given set of style rules does not follow the pattern Symbol->String.";

AddTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[Join[$TexStyles,{a}]];
]

SetTexStyles[a__Rule]:=Module[{},
If[Or@@Map[Head[#]=!=String&,Values[{a}]],
Message[AddTexStyles::invalidRule];Abort[]];
$TexStyles=DeleteDuplicates[{a}];
]

SetTexStyles[]:=Module[{},
$TexStyles={};
]


(* ::Input::Initialization:: *)
isRoutedAssociation[expr_]:=Module[{},
If[Head[expr]=!=Association,Return[False]];
If[FreeQ[Keys[expr],"result"],Return[False]];
If[FreeQ[Keys[expr],"externalIndices"],Return[False]];
If[FreeQ[Keys[expr],"loopMomenta"],Return[False]];
Return[True];
]
Protect[routedContainer];


(* ::Input::Initialization:: *)
RenewFormatDefinitions[]:=Module[{},

Unprotect[FDOp,GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta],FMinus,S,routedContainer];
Unprotect@@$allObjects;

(*Field formatting with superindices*)
Map[
(
Format[Keys[#][any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>arg]
];
Format[Superscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>"^"<>arg]
];
Format[Subscript[Keys[#],any_],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[any,TeXForm]//ToString;
TeXVerbatim[head<>"_"<>arg]
];
)&,
$TexStyles\[Union]Select[$Fields,FreeQ[Keys[$TexStyles],Keys[#]]&]];

(*Field formatting with explicit indices*)
Map[
(
Format[Keys[#][{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXVerbatim[head<>arg<>"("<>ToString[TeXForm[p]]<>")"]
];
Format[Superscript[Keys[#],{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXVerbatim[head<>"^"<>arg<>"("<>ToString[TeXForm[p]]<>")"]
];
Format[Subscript[Keys[#],{p_,indices_}],TeXForm]:=Module[{head,arg},
head=Keys[#]//.$TexStyles//.$Fields;
arg=Format[indices,TeXForm]//ToString;
TeXVerbatim[head<>"_"<>arg<>"("<>ToString[TeXForm[p]]<>")"]
];
)&,
$TexStyles\[Union]Select[$Fields,FreeQ[Keys[$TexStyles],Keys[#]]&]];

(*Other formatting*)
Format[FDOp[f_],TeXForm]:=Module[{},
TeXDelimited["\\frac{\\delta}{\\delta",f,"}"]
];

Map[
(Format[#[{f__},{i__}],TeXForm]/;Head[{i}[[1]]]=!=List:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},{i}];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret]
])&,
$indexedObjects];

Map[
(Format[#[{f__},{i__}],TeXForm]/;Head[{i}[[1]]]===List:=Module[{sub,sup,ret},
{sub,sup}=MakeTexIndexList[{f},-{i}[[All,2]]];
ret=Switch[#,
Propagator,"G",
FMinus,"(-1)",
Rdot,"\\partial_t R",
GammaN,"\\Gamma",
S,"S",
_,TeXForm[#]//ToString
];
If[StringLength[sub]=!=0,ret=ret<>"_{"<>sub<>"}"];
If[StringLength[sup]=!=0,ret=ret<>"^{"<>sup<>"}"];
TeXVerbatim[ret<>"("<>StringRiffle[Map[ToString@TeXForm[#]&,{i}[[All,1]]],","]<>")"]
])&,
$indexedObjects];

Format[FTerm[a___],TeXForm]:=Module[{obj,integrals,replNames,idx,prefix,postfix,body={a}},
integrals=Pick[$availableLoopMomenta,Map[MemberQ[{a},#,Infinity]&,$availableLoopMomenta]];
replNames=Thread[$availableLoopMomenta->Table[Subscript[Symbol[$loopMomentumName],idx],{idx,1,Length[$availableLoopMomenta]}]];
prefix=StringJoin[Map["\\int_{"<>ToString[TeXForm[#]]<>"}"&,integrals//.replNames]];
postfix="";

If[MatchQ[{a}[[1]],b_/;NumericQ[b]&&b<0],
If[{a}[[1]]===-1,
prefix=prefix<>"(-";
postfix=")"<>postfix;
body=body[[2;;]];
,
prefix=prefix<>"(";
postfix=")"<>postfix;
]
];

body=body//.replNames;
body=body//.Map[#->Subscript[Symbol[StringTake[SymbolName[#],{1}]],ToExpression@StringTake[SymbolName[#],{2,-1}]]&,
Select[GetAllSymbols[body],StringMatchQ[SymbolName[#],LetterCharacter~~DigitCharacter..]&]
];

TeXDelimited[prefix,##,postfix,
"DelimSeparator"->"","BodySeparator"->"\\,",
(*It is not clear why the call to RenewFormatDefinitions[] is necessary here. However, removing it leads to TeXForm ignoring all custom TeXStyles.*)
"BodyConverter"->(ToString[RenewFormatDefinitions[];Format[#,TeXForm]]&)
]&@@body
];

Format[FEq[a___],TeXForm]:=If[Length[Flatten[(List@@#&)/@{a}]]<=8,
TeXDelimited["",a,"",
"DelimSeparator"->"\n","BodySeparator"->"\n\\,+\\,\n",
"BodyConverter"->(ToString[Format[#,TeXForm]]&)],
TeXDelimited["\\begin{aligned}&",a,"\\end{aligned}",
"DelimSeparator"->"\n","BodySeparator"->"\n\\\\ &\\,+\\,\n",
"BodyConverter"->(ToString[Format[#,TeXForm]]&)]
];

Format[routedContainer[a__],TeXForm]/;(And@@(isRoutedAssociation/@{a})):=Module[{parts},
parts={a}[[All,Key["result"]]];
parts=ToString[TeXForm[FEq[#]]]&/@parts;

parts=Join[
{parts[[1]]},
Map[
If[StringTake[#,{1,17}]==="\\begin{aligned}&\n",
StringJoin[{"\\begin{aligned}&\n\\,+\\,",StringTake[#,{18,-1}]}],
StringJoin[{"\\,+\\,",#}]]&,
parts[[2;;]]]
];

TeXVerbatim["\\begin{aligned}&\n"<>
StringRiffle[parts,"\n \\\&\n"]<>
"\n\\end{aligned}"]
];


Protect[FDOp,GammaN,Propagator,Rdot,FTerm,FEq,\[Gamma],\[Delta],FMinus,S,routedContainer];
Protect@@$allObjects;
];

TakeDerivatives[MakeDSE[c[x]],{A[z],cb[y]}]//.{A[_]:>0,c[_]:>0,cb[_]:>0}//Truncate;
RouteIndices[Setup,%];
%//FPrint


(* ::Input::Initialization:: *)
(*Turn a given expression into LaTeX code*)
FTex[setup_,expr_]:=Module[
{prExp=expr,fields},
AssertFSetup[setup];
fields=GetAllFields[setup];

(*update the formatting definitions for TeXForm*)
$Fields=Thread[fields->Map[ToString[TeXForm[#]]&,fields]];
RenewFormatDefinitions[];

(*Assign human-readable superindices*)
prExp=prettySuperIndices[setup,prExp];
prExp=prettyExplicitIndices[setup,prExp];

(*make fields with indices to sub-/super-script*)
prExp=prExp//.Map[#[Times[-1,a_]]:>Subscript[#,a]&,fields]//.Map[#[a_]:>Superscript[#,a]&,fields];

(*For correct rendering, fully expand any FTerms*)
prExp=prExp//.FTerm[pre___,Times[a_,b_],post___]:>FTerm[pre,a,b,post];

Return[prExp//TeXForm];
];

(*For the output of a full routing*)
FTex[setup_,expr_List]/;(And@@(isRoutedAssociation/@expr)):=FTex[setup,routedContainer@@expr];

(*For direct printing*)
FPrint[setup_,expr_]:=Print[FTex[setup,expr]//MaTeX];


(* ::Input::Initialization:: *)
MakeEdgeRule[setup_,obj_]:=Module[{},
If[IsAntiFermion[setup,obj[[1,1]]]&&IsFermion[setup,obj[[1,2]]],Return [obj[[2,1]]->obj[[2,2]]]];
If[IsFermion[setup,obj[[1,1]]]&&IsAntiFermion[setup,obj[[1,2]]],Return [obj[[2,2]]->obj[[2,1]]]];
Return [obj[[2,1]]<->obj[[2,2]]];
];


(* ::Input::Initialization:: *)
 crosscircle[r_] := Graphics[{Thick, Line[{{r / Sqrt[2], r / Sqrt[2]
            }, {-r / Sqrt[2], -r / Sqrt[2]}}], Line[{{r / Sqrt[2], -r / Sqrt[2]},
             {-r / Sqrt[2], r / Sqrt[2]}}], Circle[{0, 0}, r]}];
 cross[r_] := Graphics[{ Line[{{r / Sqrt[2], r / Sqrt[2]
            }, {-r / Sqrt[2], -r / Sqrt[2]}}], Line[{{r / Sqrt[2], -r / Sqrt[2]},
             {-r / Sqrt[2], r / Sqrt[2]}}]}];
$standardVertexStyles={
GammaN->Graphics@Style[Disk[{0,0},0.5],Gray],
S->Graphics@Style[Disk[{0,0}],Black],
Rdot->crosscircle[1],
Field->cross[1]
};
$standardVertexSize={
GammaN->0.15,
S->0.05,
Rdot->0.25,
Field->0.1
};


(* ::Input::Initialization:: *)
PlotDiagrams[setup_,diag_FTerm]:=Module[
{PossibleVertices,PossibleEdges,Styles,
allObj,fieldObj,vertices,edges,vertexReplacements,graph,phantomVertices,edgeFields,
fieldVertices,fieldEdges,fieldEdgeFields,
externalVertices,externalEdges,externalFields,idx,prefactor,doFields,eWeights},
doFields=replFields[setup];

PossibleVertices=Join[{GammaN,S,Rdot,Field},
If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Vertices"],
setup["DiagramStyling"]["Vertices"],{}]];
PossibleEdges=Join[{Propagator},
If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Edges"],
setup["DiagramStyling"]["Edges"],{}]];
Styles=If[KeyExistsQ[setup,"DiagramStyling"]&&KeyExistsQ[setup["DiagramStyling"],"Styles"],
setup["DiagramStyling"]["Styles"],
Thread[(#->ColorData[97,"ColorList"][[1;;Length[#]]])&@DeleteDuplicates[GetAllFields[setup]/.Map[#[[1]]->#[[2]]&,GetFieldPairs[setup]]]]
];
Styles=Join[Styles,Map[GetPartnerField[setup,#[[1]]]->#[[2]]&,Select[Styles,HasPartnerField[setup,#[[1]]]&]]];

allObj=ExtractObjectsWithIndex[setup,diag]//.doFields;
fieldObj=Flatten[Select[allObj,Head[#]===Field&]/.Field[{f_},{i_}]:>Module[{oi},{Propagator[{f,GetPartnerField[setup,f]},{oi,i}],Field[{f},{oi}]}]];
allObj=Select[allObj,Head[#]=!=Field&];

(*prepare vertices*)
vertices=Select[allObj,
MemberQ[PossibleVertices,Head[#]]&&
(FreeQ[PossibleEdges,Head[#]]||Length[#[[2]]]=!=2)&
];
vertexReplacements=Flatten@Module[{v},Map[(v=Unique["v"];Map[(makePosIdx[#]->v)&,#[[2]]])&,vertices]];
vertices=Map[Head[#]@@((makePosIdx/@#[[2]]/.vertexReplacements)//DeleteDuplicates)&,vertices];

(*Props and vertices for attached fields*)
fieldVertices=Select[fieldObj,(Head[#]===Field)&];
fieldVertices=Map[Head[#]@@((makePosIdx/@#[[2]]/.vertexReplacements)//DeleteDuplicates)&,fieldVertices];
fieldEdges=Select[fieldObj,(Head[#]=!=Field)&];
fieldEdgeFields=Table[SelectFirst[fieldEdges[[idx,1]],MemberQ[Styles,#,Infinity]&],{idx,1,Length[fieldEdges]}];
fieldEdges=Map[MakeEdgeRule[setup,#]&,fieldEdges/.vertexReplacements];
fieldEdges=Table[Style[fieldEdges[[idx]],##]&@@Flatten@{fieldEdgeFields[[idx]]/.Styles},{idx,1,Length[fieldEdges]}];

(*prepare edges*)
edges=Select[allObj,
MemberQ[PossibleEdges,Head[#]]&&
Length[#[[2]]]===2&
];
edgeFields=Table[SelectFirst[edges[[idx,1]],MemberQ[Styles,#,Infinity]&],{idx,1,Length[edges]}];
edges=Map[MakeEdgeRule[setup,#]&,edges/.vertexReplacements];
edges=Table[Style[edges[[idx]],##]&@@Flatten@{edgeFields[[idx]]/.Styles},{idx,1,Length[edges]}];

(*Add additional vertices for external indices*)
externalVertices=GetOpenSuperIndices[setup,diag];
externalFields=Table[SelectFirst[allObj,MemberQ[makePosIdx/@#[[2]],externalVertices[[idx]]]&],{idx,1,Length[externalVertices]}];
externalFields=Table[
externalFields[[idx,1,FirstPosition[makePosIdx/@externalFields[[idx,2]],externalVertices[[idx]]][[1]]]]
,{idx,1,Length[externalVertices]}];
externalEdges=Table[
MakeEdgeRule[setup,Propagator[{GetPartnerField[setup,externalFields[[idx]]],externalFields[[idx]]},{externalVertices[[idx]],externalVertices[[idx]]/.vertexReplacements}]]
,{idx,1,Length[externalVertices]}];
externalEdges=Table[Style[externalEdges[[idx]],##]&@@Flatten@{externalFields[[idx]]/.Styles},{idx,1,Length[externalEdges]}];

phantomVertices=Table[Symbol["phantom"<>ToString[idx]],{idx,1,Length[edges]}];
(*edges=Flatten@Table[{Head[edges[[idx]]][edges[[idx,1]],phantomVertices[[idx]]],Head[edges[[idx]]][phantomVertices[[idx]],edges[[idx,2]]]},{idx,1,Length[edges]}];*)

(*get the prefactor*)
prefactor=Times@@(diag/.doFields/.Map[Blank[#]->1&,Join[{Field},$allObjects]]);

prefactor*Graph[Join[vertices[[All,1]],externalVertices,fieldVertices[[All,1]]],Join[edges,externalEdges,fieldEdges],
VertexShape->Join[
Thread[vertices[[All,1]]->(vertices[[All,0]]/.$standardVertexStyles)],
Thread[externalVertices->Map[Graphics@Style[Disk[{0,0},0.0],Gray]&,externalVertices]],
Thread[fieldVertices[[All,1]]->(fieldVertices[[All,0]]/.$standardVertexStyles)]
],
VertexSize->Thread[vertices[[All,1]]->(vertices[[All,0]]/.$standardVertexSize)],
GraphLayout->{"SpringElectricalEmbedding"},
PerformanceGoal->"Quality",
ImageSize->Small,
EdgeStyle->Arrowheads[{{.07,.6}}]
]
];

PlotDiagrams[setup_,expr_FEq]:=Module[{},
Plus@@(PlotDiagrams[setup,#]&/@expr)
];



