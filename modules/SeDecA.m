(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

(* ::Input::Initialization:: *)
MakeSetup::usage="";
AddCField::usage="";
AddGrassmann::usage="";
AddVertex::usage="";
AddVertices::usage="";
AddVertexBasis::usage="";
AddVertexBases::usage="";


Begin["`Private`"]


(* ::Input::Initialization:: *)
AddCField[arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddCField[$GlobalSetup,arg];Protect[$GlobalSetup]);
AddGrassmann[arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddGrassmann[$GlobalSetup,arg];Protect[$GlobalSetup]);

AddVertex[obj_,arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddVertex[$GlobalSetup,obj,arg];Protect[$GlobalSetup]);
AddVertices[obj_,arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddVertices[$GlobalSetup,obj,arg];Protect[$GlobalSetup]);

AddVertexBasis[obj_,arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddVertexBasis[$GlobalSetup,obj,arg];Protect[$GlobalSetup]);
AddVertexBases[obj_,arg_]/;Head[$GlobalSetup]=!=Symbol:=(Unprotect[$GlobalSetup];AddVertexBases[$GlobalSetup,obj,arg];Protect[$GlobalSetup]);


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"DiRK","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"DiRK","FEDeriK"];
Abort[];
];

ModuleLoaded[SeDecA]=True;


(* ::Input::Initialization:: *)
MakeSetup[]:=Module[{fields,truncation,bases,diagramStyling,setup},
fields= <|
"cField"-> {},
"Grassmann"->{}
|>;
truncation=<||>;
bases=<||>;
diagramStyling=<|
"Styles"->{}
|>;
setup=<|
"FieldSpace"->fields,
"Truncation"->truncation,
"FeynmanRules"->bases,
"DiagramStyling"->diagramStyling
|>;
Return[setup]
];

SeDecA::FieldExists="The field `1` has been already defined!";


(* ::Input::Initialization:: *)
SeDecA::IncorrectFieldSpecification="Invalid specification:
            `1`
A field must be either of the shape \[Phi][p] or \[Phi][p, {i1,i2,...}], or a pair {\!\(\*OverscriptBox[\(\[Phi]\), \(_\)]\)[...], \[Phi][...]}";

AddCField[a___]:=(Message[SeDecA::IncorrectFieldSpecification,{a}];Abort[]);
AddCField[setup_,name_Symbol[p_Symbol]]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name[__],Infinity],Message[SeDecA::FieldExists,name];Abort[]];
AppendTo[setup["FieldSpace"]["cField"],name[p]];
setup
];
AddCField[setup_,name_Symbol[p_Symbol,{ind__Symbol}]]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name[__],Infinity],Message[SeDecA::FieldExists,name];Abort[]];
AppendTo[setup["FieldSpace"]["cField"],name[p,{ind}]];
setup
];
AddCField[setup_,{name1_Symbol[p_Symbol],name2_Symbol[p_Symbol]}]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name1[__]|name2[__],Infinity],Message[SeDecA::FieldExists,{name1,name2}];Abort[]];
AppendTo[setup["FieldSpace"]["cField"],{name1[p],name2[p]}];
setup
];
AddCField[setup_,{name1_Symbol[p_Symbol,{ind__Symbol}],name2_Symbol[p_Symbol,{ind__Symbol}]}]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name1[__]|name2[__],Infinity],Message[SeDecA::FieldExists,{name1,name2}];Abort[]];
AppendTo[setup["FieldSpace"]["cField"],{name1[p,{ind}],name2[p,{ind}]}];
setup
];
SetAttributes[AddCField,HoldFirst]

AddGrassmann[a___]:=(Message[SeDecA::IncorrectFieldSpecification,{a}];Abort[]);
AddGrassmann[setup_,name_Symbol[p_Symbol]]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name[__],Infinity],Message[SeDecA::FieldExists,name];Abort[]];
AppendTo[setup["FieldSpace"]["Grassmann"],name[p]];
setup
];
AddGrassmann[setup_,name_Symbol[p_Symbol,{ind__Symbol}]]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name[__],Infinity],Message[SeDecA::FieldExists,name];Abort[]];
AppendTo[setup["FieldSpace"]["Grassmann"],name[p,{ind}]];
setup
];
AddGrassmann[setup_,{name1_Symbol[p_Symbol],name2_Symbol[p_Symbol]}]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name1[__]|name2[__],Infinity],Message[SeDecA::FieldExists,{name1,name2}];Abort[]];
AppendTo[setup["FieldSpace"]["Grassmann"],{name1[p],name2[p]}];
setup
];
AddGrassmann[setup_,{name1_Symbol[p_Symbol,{ind__Symbol}],name2_Symbol[p_Symbol,{ind__Symbol}]}]:=Module[{},
If[MemberQ[Join[setup["FieldSpace"]["cField"],setup["FieldSpace"]["Grassmann"]],name1[__]|name2[__],Infinity],Message[SeDecA::FieldExists,{name1,name2}];Abort[]];
AppendTo[setup["FieldSpace"]["Grassmann"],{name1[p,{ind}],name2[p,{ind}]}];
setup
];
SetAttributes[AddGrassmann,HoldFirst];


(* ::Input::Initialization:: *)
SeDecA::InvalidVertex="The vertex `1` is not valid. A vertex must be a list of (existing) fields.";

AddVertex[a___]:=(Message[SeDecA::InvalidVertex,{a}];Abort[]);
AddVertex[setup_,obj_,{fields__Symbol}]:=Module[{exist},
(*Check if all fields exist*)
exist=And@@Map[FieldNameQ[setup,#]&,{fields}];
If[Not@exist,Message[SeDecA::InvalidVertex,{fields}];Abort[]];

If[KeyFreeQ[setup["Truncation"],obj],AppendTo[setup["Truncation"],obj->{}]];
AppendTo[setup["Truncation"][obj],{fields}];
setup
];
SetAttributes[AddVertex,HoldFirst];
AddVertices[setup_,obj_,{vertices__List}]:=Module[{},
Map[AddVertex[setup,obj,#]&,{vertices}];
setup
];
SetAttributes[AddVertices,HoldFirst];


(* ::Input::Initialization:: *)
SeDecA::InvalidVertexBasis="The basis `1` is not valid. A basis must be a rule assigning an existing vertex to a valid tensor basis.";SeDecA::NoBasis="The basis `1` has not been registered with TensorBases.";SeDecA::BasisLength="The chosen indices `1` for elements of the basis `2` exceed its length.";

AddVertexBasis[a___]:=(Message[SeDecA::InvalidVertex,{a}];Abort[]);
AddVertexBasis[setup_,obj_,{fields__Symbol}->basis_]:=Module[{exist,basisName,elements},
(*Check if all fields exist*)
exist=And@@Map[FieldNameQ[setup,#]&,{fields}];
If[Not@exist,Message[SeDecA::InvalidVertexBasis,{fields}->basis];Abort[]];
(*Check if the basis makes sense*)
basisName=If[ListQ[basis],basis[[1]],basis];
If[Not@TBBasisExists[basisName],Message[SeDecA::NoBasis,basisName];Message[SeDecA::InvalidVertexBasis,{fields}->basis];Abort[]];
If[ListQ[basis],
If[Length[basis]<2,Message[SeDecA::InvalidVertexBasis,{fields}->basis];Abort[]];
elements=If[ListQ[basis[[2]]],basis[[2]],{basis[[2]]}];
If[AnyTrue[elements,#>TensorBases`TBGetBasisSize[basisName]&],
Message[SeDecA::BasisLength,elements,basisName];Message[SeDecA::InvalidVertexBasis,{fields}->basis];Abort[]];
];

If[KeyFreeQ[setup["FeynmanRules"],obj],AppendTo[setup["FeynmanRules"],obj->{}]];
AppendTo[setup["FeynmanRules"][obj],{fields}->basis];
setup
];
SetAttributes[AddVertexBasis,HoldFirst];
AddVertexBases[setup_,obj_,{vertices__}]:=Module[{},
Map[AddVertexBasis[setup,obj,#]&,{vertices}];
setup
];
SetAttributes[AddVertexBases,HoldFirst];


End[]



