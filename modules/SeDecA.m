(* ::Package:: *)

(* ::Input:: *)

(*SetOptions[EvaluationNotebook[],AutoGeneratedPackage->"SeDecA.m"]*)

(* ::Title:: *)

(*SeDecA -  Setup Declaration Assistant*)

(* ::Section:: *)

(*Exports*)

(* ::Input::Initialization:: *)

MakeSetup::usage = "MakeSetup[]
Creates a new functional setup association for defining field theory calculations.
Initializes empty field spaces, truncation specifications, and basis definitions.
Returns a setup association that can be extended with AddCField, AddGrassmann, etc.
This is the starting point for building any functional field theory calculation.
Use SetGlobalSetup[setup] to make it available to all FunKit functions.";

AddCField::usage = "AddCField[setup, field]
AddCField[setup, {field1, field2}]
Adds classical (commuting) fields to the functional setup.
Single fields: AddCField[setup, φ[p]] or AddCField[setup, φ[p, {i, j}]]
Field pairs: AddCField[setup, {φ[p], φbar[p]}] for complex fields
Supports momentum arguments (p) and index structures ({i, j, ...})
Essential for defining the field content of your theory.";

AddGrassmann::usage = "AddGrassmann[setup, field]
AddGrassmann[setup, {field1, field2}]  
Adds Grassmann (anticommuting) fields to the functional setup.
Single fields: AddGrassmann[setup, ψ[p]] or AddGrassmann[setup, ψ[p, {α}]]
Field pairs: AddGrassmann[setup, {ψ[p], ψbar[p]}] for Dirac fermions
Supports momentum arguments (p) and spinor/index structures
Required for fermionic fields in quantum field theory calculations.";

AddVertex::usage = "AddVertex[setup, object, {field1, field2, ...}]
Defines a vertex structure in the truncation for the specified object.
The object (e.g., GammaN, Propagator) specifies the type of vertex.
The field list defines which fields participate in this vertex type.
Automatically handles field ordering and symmetry considerations.
Use this to specify the allowed interaction terms in your theory.";

AddVertices::usage = "AddVertices[setup, object, {{field1, field2}, {field3, field4}, ...}]
Adds multiple vertex structures simultaneously for the specified object.
Each sub-list represents one allowed vertex configuration.
More efficient than calling AddVertex multiple times.
Useful for setting up theories with many different interaction channels.";

AddVertexBasis::usage = "AddVertexBasis[setup, object, {field1, field2, ...} -> basis]
Defines both a vertex structure and its associated tensor basis.
The vertex specification works like AddVertex.
The basis should be a TensorBases tensor structure (e.g., TB[\"SO(3)\", {1, 1}]).
This combines truncation specification with basis assignment in one step.
Essential for calculations that require specific tensor structures.";

AddVertexBases::usage = "AddVertexBases[setup, object, {vertex1 -> basis1, vertex2 -> basis2, ...}]
Adds multiple vertex-basis pairs simultaneously for the specified object.
Each rule associates a vertex configuration with its tensor basis.
More efficient than calling AddVertexBasis multiple times.  
Useful for complex theories with many different tensor structures.";

(* ::Section:: *)

(*Begin Private*)

Begin["`Private`"]

(* ::Section:: *)

(*Global setup redefinitions*)

(* ::Input::Initialization:: *)

AddCField[arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddCField[$GlobalSetup, arg];
        Protect[$GlobalSetup]
    );

AddGrassmann[arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddGrassmann[$GlobalSetup, arg];
        Protect[$GlobalSetup]
    );

AddVertex[obj_, arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddVertex[$GlobalSetup, obj, arg];
        Protect[$GlobalSetup]
    );

AddVertices[obj_, arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddVertices[$GlobalSetup, obj, arg];
        Protect[$GlobalSetup]
    );

AddVertexBasis[obj_, arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddVertexBasis[$GlobalSetup, obj, arg];
        Protect[$GlobalSetup]
    );

AddVertexBases[obj_, arg_] /; Head[$GlobalSetup] =!= Symbol :=
    (
        Unprotect[$GlobalSetup];
        AddVertexBases[$GlobalSetup, obj, arg];
        Protect[$GlobalSetup]
    );

(* ::Section:: *)

(*Global variables*)

(* ::Input::Initialization:: *)

ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "DiRK", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "DiRK", "FEDeriK"];
    Abort[];
];

ModuleLoaded[SeDecA] = True;

(* ::Section:: *)

(*Defining a Setup*)

(* ::Input::Initialization:: *)

MakeSetup[] :=
    Module[{fields, truncation, bases, diagramStyling, setup},
        fields = <|"Commuting" -> {}, "Grassmann" -> {}|>;
        truncation = <||>;
        bases = <||>;
        diagramStyling = <|"Styles" -> {}|>;
        setup = <|"FieldSpace" -> fields, "Truncation" -> truncation,
             "FeynmanRules" -> bases, "DiagramStyling" -> diagramStyling|>;
        Return[setup]
    ];

SeDecA::FieldExists = "The field `1` has been already defined!";

(* ::Input::Initialization:: *)

SeDecA::IncorrectFieldSpecification = "Invalid specification:
            `1`
A field must be either of the shape \[Phi][p] or \[Phi][p, {i1,i2,...}], or a pair {\!\(\*OverscriptBox[\(\[Phi]\), \(_\)]\)[...], \[Phi][...]}";

AddCField[a___] :=
    (
        Message[SeDecA::IncorrectFieldSpecification, {a}];
        Abort[]
    );

AddCField[setup_, name_Symbol[p_Symbol]] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name[__], Infinity],
            Message[SeDecA::FieldExists, name];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Commuting"], name[p]];
        setup
    ];

AddCField[setup_, name_Symbol[p_Symbol, {ind__Symbol}]] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name[__], Infinity],
            Message[SeDecA::FieldExists, name];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Commuting"], name[p, {ind}]];
        setup
    ];

AddCField[setup_, {name1_Symbol[p_Symbol], name2_Symbol[p_Symbol]}] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name1[__] | name2[__], Infinity],
            Message[SeDecA::FieldExists, {name1, name2}];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Commuting"], {name1[p], name2[p
            ]}];
        setup
    ];

AddCField[setup_, {name1_Symbol[p_Symbol, {ind__Symbol}], name2_Symbol[
    p_Symbol, {ind__Symbol}]}] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name1[__] | name2[__], Infinity],
            Message[SeDecA::FieldExists, {name1, name2}];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Commuting"], {name1[p, {ind}], 
            name2[p, {ind}]}];
        setup
    ];

SetAttributes[AddCField, HoldFirst]

AddGrassmann[a___] :=
    (
        Message[SeDecA::IncorrectFieldSpecification, {a}];
        Abort[]
    );

AddGrassmann[setup_, name_Symbol[p_Symbol]] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name[__], Infinity],
            Message[SeDecA::FieldExists, name];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Grassmann"], name[p]];
        setup
    ];

AddGrassmann[setup_, name_Symbol[p_Symbol, {ind__Symbol}]] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name[__], Infinity],
            Message[SeDecA::FieldExists, name];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Grassmann"], name[p, {ind}]];
        setup
    ];

AddGrassmann[setup_, {name1_Symbol[p_Symbol], name2_Symbol[p_Symbol]}
    ] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name1[__] | name2[__], Infinity],
            Message[SeDecA::FieldExists, {name1, name2}];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Grassmann"], {name1[p], name2[p
            ]}];
        setup
    ];

AddGrassmann[setup_, {name1_Symbol[p_Symbol, {ind__Symbol}], name2_Symbol[
    p_Symbol, {ind__Symbol}]}] :=
    Module[{},
        If[MemberQ[Join[setup["FieldSpace"]["Commuting"], setup["FieldSpace"
            ]["Grassmann"]], name1[__] | name2[__], Infinity],
            Message[SeDecA::FieldExists, {name1, name2}];
            Abort[]
        ];
        AppendTo[setup["FieldSpace"]["Grassmann"], {name1[p, {ind}], 
            name2[p, {ind}]}];
        setup
    ];

SetAttributes[AddGrassmann, HoldFirst];

(* ::Input::Initialization:: *)

SeDecA::InvalidVertex = "The vertex `1` is not valid. A vertex must be a list of (existing) fields.";

AddVertex[a___] :=
    (
        Message[SeDecA::InvalidVertex, {a}];
        Abort[]
    );

AddVertex[setup_, obj_, {fields__Symbol}] :=
    Module[
        {exist}
        ,
        (*Check if all fields exist*)
        exist = And @@ Map[FieldNameQ[setup, #]&, {fields}];
        If[Not @ exist,
            Message[SeDecA::InvalidVertex, {fields}];
            Abort[]
        ];
        If[KeyFreeQ[setup["Truncation"], obj],
            AppendTo[setup["Truncation"], obj -> {}]
        ];
        AppendTo[setup["Truncation"][obj], {fields}];
        setup
    ];

SetAttributes[AddVertex, HoldFirst];

AddVertices[setup_, obj_, {vertices__List}] :=
    Module[{},
        Map[AddVertex[setup, obj, #]&, {vertices}];
        setup
    ];

SetAttributes[AddVertices, HoldFirst];

(* ::Input::Initialization:: *)

SeDecA::InvalidVertexBasis = "The basis `1` is not valid. A basis must be a rule assigning an existing vertex to a valid tensor basis."; SeDecA::NoBasis = "The basis `1` has not been registered with TensorBases."; SeDecA::BasisLength = "The chosen indices `1` for elements of the basis `2` exceed its length.";

AddVertexBasis[a___] :=
    (
        Message[SeDecA::InvalidVertex, {a}];
        Abort[]
    );

AddVertexBasis[setup_, obj_, {fields__Symbol} -> basis_] :=
    Module[
        {exist, basisName, elements}
        ,
        (*Check if all fields exist*)
        exist = And @@ Map[FieldNameQ[setup, #]&, {fields}];
        If[Not @ exist,
            Message[SeDecA::InvalidVertexBasis, {fields} -> basis];
            Abort[]
        ];
        (*Check if the basis makes sense*)
        basisName =
            If[ListQ[basis],
                basis[[1]]
                ,
                basis
            ];
        If[Not @ TBBasisExists[basisName],
            Message[SeDecA::NoBasis, basisName];
            Message[SeDecA::InvalidVertexBasis, {fields} -> basis];
            Abort[]
        ];
        If[ListQ[basis],
            If[Length[basis] < 2,
                Message[SeDecA::InvalidVertexBasis, {fields} -> basis
                    ];
                Abort[]
            ];
            elements =
                If[ListQ[basis[[2]]],
                    basis[[2]]
                    ,
                    {basis[[2]]}
                ];
            If[AnyTrue[elements, # > TensorBases`TBGetBasisSize[basisName
                ]&],
                Message[SeDecA::BasisLength, elements, basisName];
                Message[SeDecA::InvalidVertexBasis, {fields} -> basis
                    ];
                Abort[]
            ];
        ];
        If[KeyFreeQ[setup["FeynmanRules"], obj],
            AppendTo[setup["FeynmanRules"], obj -> {}]
        ];
        AppendTo[setup["FeynmanRules"][obj], {fields} -> basis];
        setup
    ];

SetAttributes[AddVertexBasis, HoldFirst];

AddVertexBases[setup_, obj_, {vertices__}] :=
    Module[{},
        Map[AddVertexBasis[setup, obj, #]&, {vertices}];
        setup
    ];

SetAttributes[AddVertexBases, HoldFirst];

(* ::Section:: *)

(*End Private*)

End[]

(* ::Input:: *)

(*Get["FunKit`"]*)

(* ::Input:: *)

(*set=MakeSetup[];*)

(**)

(*(*Set up field content*)*)

(*AddCField[set,A[p,{mu,a}]];*)

(*AddCField[set,\[Sigma][p]];*)

(*AddCField[set,\[CapitalPi][p,{f}]];*)

(*AddGrassmann[set,{qb[p,{d,F,A}],q[p,{d,F,A}]}];*)

(*AddGrassmann[set,{cb[p,{a}],c[p,{a}]}];*)

(**)

(*(*Set up truncation*)*)

(*AddVertices[set,Propagator,{{A,A},{qb,q},{cb,c}}];*)

(*AddVertices[set,GammaN,{{A,A,A},{A,A,A,A},{A,cb,c}}];*)

(*AddVertices[set,GammaN,{{A,qb,q}}];*)

(**)

(*(*Add bases*)*)

(*AddVertexBasis[set,Propagator,{cb,c}->"cbc"];*)

(*AddVertexBasis[set,Propagator,{A,A}->"AA"];*)

(*AddVertexBases[set,GammaN,{{A,A,A}->"AAAClass",{A,A,A,A}->"AAAAClass",{A,cb,c}->{"Acbc",1}}];*)

(*AddVertexBasis[set,GammaN,{A,qb,q}->"AqbqOpt"];*)

(* ::Input:: *)

(*MakeDiagrammaticRules[set]*)

(* ::Input:: *)

(*SetGlobalSetup[MakeSetup[]];*)

(**)

(*(*Set up field content*)*)

(*AddCField[A[p,{mu,a}]];*)

(*AddCField[\[Sigma][p]];*)

(*AddCField[\[CapitalPi][p,{f}]];*)

(*AddGrassmann[{qb[p,{d,F,A}],q[p,{d,F,A}]}];*)

(*AddGrassmann[{cb[p,{a}],c[p,{a}]}];*)

(**)

(*(*Set up truncation*)*)

(*AddVertices[Propagator,{{A,A},{qb,q},{cb,c}}];*)

(*AddVertices[GammaN,{{A,A,A},{A,A,A,A},{A,cb,c}}];*)

(*AddVertices[GammaN,{{A,qb,q}}];*)

(**)

(*(*Add bases*)*)

(*AddVertexBasis[Propagator,{cb,c}->"cbc"];*)

(*AddVertexBasis[Propagator,{A,A}->"AA"];*)

(*AddVertexBases[GammaN,{{A,A,A}->"AAAClass",{A,A,A,A}->"AAAAClass",{A,cb,c}->{"Acbc",1}}];*)

(*AddVertexBasis[GammaN,{A,qb,q}->"AqbqOpt"];*)

(* ::Input:: *)

(*MakeDiagrammaticRules[]*)
