(* ::Package:: *)

(* ::Input:: *)
(*SetOptions[EvaluationNotebook[],AutoGeneratedPackage->"TRACY.m"]*)


(* ::Title:: *)
(*TRACY -  Tracing Representations And Contractions Yourself*)


(* ::Section::Closed:: *)
(*Exports*)


(* ::Input::Initialization:: *)
FORMSimplify::usage="FORMSimplify[expr] tries to simplify the given expression using FORM's output optimization (O4) algorithms.
FORMSimplify[expr,preReplRules,postReplRules] one can specify additionally FORM preRepl and postRepl rules, see also the documentation of the FormTrace command.";

IterativelySum::usage="IterativelySum[list] tries to efficiently break up the list into subsets, and repeatedly sum and simplify these until only a single expression remains.
IterativelySum[list,finalSize] returns a list of size finalSize and tries to choose the terms such that all of these are equally sized.";

FormMomentumExpansion::usage="FormMomentumExpansion[] creates a FORM rule to expand out any scalar products. This can be passed as a postRepl or preRepl rule to FormTrace or FORMSimplify.";

FiniteTFormMomentumExpansion::usage="FiniteTFormMomentumExpansion[] creates a FORM rule to expand out any scalar products into spatial and temporal parts. This can be passed as a postRepl or preRepl rule to FormTrace or FORMSimplify.";

MakeP0FormRule::usage="MakeP0FormRule[{l1,...},{p1,...},{proj1,...}] creates a FORM rule to project the temporal components of an expression, i.e. set vec[p1,0], to the value of proj1, etc.";

MakeSPFormRule::usage="MakeSPFormRule[{l1,...},p,{p1,...}] creates a FORM rule to project the loop momenta l1... and legs p1... to the symmetric point configuration with average momentum p.";

MakeSPFiniteTFormRule::usage="MakeSPFiniteTFormRule[{l1,...},p,{p1,...}] creates a FORM rule to project the loop momenta l1... and legs p1... to the d-1 dimensional (spatial) symmetric point configuration with average momentum p.";

ClearTraceCache::usage="ClearTraceCache[] removes all files in the Trace Cache (usually /tmp/TraceCache).";

SetCacheDirectory::usage="SetCacheDirectory[folder] changes the directory where traced expressions are cached. Per default, the cache directory is set to /tmp/TraceCache/).
SetCacheDirectory[] resets the cache directory to /tmp/TraceCache/.";

DiagramSimplify::usage=""


(* ::Section::Closed:: *)
(*Begin Private*)


Begin["`Private`"]


(* ::Section::Closed:: *)
(*Global variables*)


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"TRACY","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"TRACY","FEDeriK"];
Abort[];
];

ModuleLoaded[TRACY]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
makeTemporaryFileName[]:=ToString[AbsoluteTime[]*10^6//Round]<>"_"<>ToString[RandomInteger[{10^6,10^7}]]


(* ::Input::Initialization:: *)
SetCacheDirectory::invalid="The directory \"`1` \"could not be created.";
SetCacheDirectory[str_String]:=Module[{mstr=str},
If[StringTake[mstr,{-1}]=!="/",mstr=StringJoin[mstr,"/"]];

CreateDirectory[mstr]//Quiet;
If[DirectoryQ[mstr],
Set[$TraceCacheDir,mstr],
Message[SetCacheDirectory::invalid,mstr];Abort[]
];
];
SetCacheDirectory[]:=SetCacheDirectory["/tmp/TraceCache/"];

SetCacheDirectory[];

ClearTraceCache[]:=(DeleteDirectory[$TraceCacheDir,DeleteContents->True];CreateDirectory[$TraceCacheDir])
ClearTraceCache[str_String]:=(DeleteDirectory[$TraceCacheDir<>str,DeleteContents->True])


(* ::Section:: *)
(*FORM*)


(* ::Subsection:: *)
(*FormTracer PostReplacement Code*)


(* ::Input::Initialization:: *)
finiteTFormExpansion:=Module[{depth=8},"
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0))^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"];
finiteTFormExpansionDis={finiteTFormExpansion};


(* ::Input::Initialization:: *)
RemoveFromExtraVars[obj_]:=Module[{extraVars,postExtraVars},
extraVars=FormTracer`GetExtraVars[];
postExtraVars=If[MemberQ[extraVars,obj],DeleteCases[extraVars,obj],extraVars];

If[extraVars=!=postExtraVars,
FormTracer`DefineExtraVars[postExtraVars];Print["Error: Momentum \""<>ToString[obj]<>"\" had been defined as an extra variable in FormTracer!"];
Abort[];
];
];


(* ::Input::Initialization:: *)
FormMomentumExpansion[momenta___]:=Module[{Defs,code,depth=8},
RemoveFromExtraVars/@{momenta};

Defs=If[Length[{momenta}]>0,"Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";",""];

code="
*** definitions ***
"<>Defs<>"

*** rewrite/expand SP scalar products
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=mom1.mom2;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsp(mom1,mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsp(mom1,mom2);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite/expand SPS scalar products
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)=mom1.mom2;\nid FTxvec(mom1?,0)=mom1(0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsps(mom1,mom2)^-1;\nid (mom1?(0))^-1=FTxvec(mom1,0)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsps(mom1,mom2);\nid mom1?(0)=FTxvec(mom1,0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";

Return[{code}];
];


(* ::Input::Initialization:: *)
FiniteTFormMomentumExpansion[momenta___]:=Module[{Defs,code},
RemoveFromExtraVars/@{momenta};

Defs=If[Length[{momenta}]>0,"Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";",""];

code=finiteTFormExpansion;

Return[{code}];
];


(* ::Input::Initialization:: *)
MakeP0FormRule[q_,{momenta__},{projections__}]:=Module[
{momentaList,projectionsList,qf,nPt,Defs,repRules,freqRules,
externalFreqRule,depth=8},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
projectionsList={projections};
qf=ToString[q]<>"f";

If[Length[momentaList]!=Length[projectionsList],Print["Momentum and projection list have differing length!"];Abort[]];

nPt=Length[momentaList];

Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"intMom,intMomf;";
repRules=Thread[
Join[Map["exMom"<>ToString[#]&,Range[1,nPt]],{"intMomf","intMom","FTxI"}]->Join[Map[ToString,momentaList],{qf,ToString[q],"i_"}]
];

freqRules=StringTake[StringJoin[Map["id exMom"<>ToString[#]<>"(0)="<>ToString[CForm[projectionsList[[#]]/.Complex[re_,im_]:>re+FTxI im/.Thread[FormTracer`GetExtraVarsSynonyms[][[All,1]]->FormTracer`GetExtraVarsSynonyms[][[All,2]]]]]<>";\n"&,Range[1,nPt]]],{1,-2}];

externalFreqRule=finiteTFormExpansion<>Defs<>"

"<>StringJoin[StringRepeat["id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";

externalFreqRule=StringReplace[externalFreqRule,repRules];
Return[{externalFreqRule}];
];


(* ::Input::Initialization:: *)
MakeFTCos[a_,b_]:=Module[{res},
res="cos"<>StringJoin[Map[ToString,Sort[{a,b}]]];
If[StringTake[res,-1]=="f",Return[Symbol[StringTake[res,{1,-2}]]],Return[Symbol[res]]]
];


(* ::Input::Initialization:: *)
GetFTSynonym[symbol_]:=Module[{},
If[symbol===I,Return[FTxI//ToString]];

If[Head[symbol]=!=Symbol,Print["The value \""<>ToString[symbol]<>"\" is not a symbol!"];Abort[]];

If[Not@MemberQ[FormTracer`GetExtraVarsSynonyms[],symbol,Infinity],FormTracer`AddExtraVars[symbol]];
ToString@Select[FormTracer`GetExtraVarsSynonyms[],#[[1]]==symbol&][[1,2]]
];


(* ::Input::Initialization:: *)
MakeSPFormRule[{loopMomenta__},p_,{momenta__}]:=Module[{momentaList,loopMomentaList,Defs,nPt,nLoops,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules,depth=8,i,j},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
loopMomentaList={loopMomenta};

nPt=Length[momentaList];
nLoops=Length[{loopMomenta}];

Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>StringJoin[Map["intMom"<>ToString[#]<>","&,Range[1,nLoops]]]<>"avMom;";

nPtId=StringJoin[
Map[
"id (exMom"<>ToString[#]<>".exMom"<>ToString[#]<>")^-1=(avMom.avMom)^-1;\n"<>
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];

nPtCrossId=StringJoin[
Map[
"id (exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>")^-1=(-avMom.avMom/"<>ToString[nPt-1]<>")^-1;\n"<>
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];

nPtqId=StringJoin[
Table[
"id (exMom"<>ToString[i]<>".intMom"<>ToString[j]<>")^-1=(sqrt(avMom.avMom)*sqrt(intMom"<>ToString[j]<>".intMom"<>ToString[j]<>")*cos(exMom"<>ToString[i]<>",intMom"<>ToString[j]<>"))^-1;\n"<>
"id exMom"<>ToString[i]<>".intMom"<>ToString[j]<>"=sqrt(avMom.avMom)*sqrt(intMom"<>ToString[j]<>".intMom"<>ToString[j]<>")*cos(exMom"<>ToString[i]<>",intMom"<>ToString[j]<>");\n"
,{i,1,nPt},{j,1,nLoops}
]
];

symmetricPointFiniteTFormRule4pt="
*** definitions ***
"<>Defs<>"
AutoDeclare CFunction cos;

*** rewrite/expand SP scalar products
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=(mom1.mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=mom1.mom2;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** simplification ***
"<>StringJoin[StringRepeat[nPtId<>nPtCrossId<>nPtqId<>"argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsp(mom1,mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsp(mom1,mom2);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
Map["intMom"<>ToString[#]&,Range[1,nLoops]],
{"avMom"}
]->
Join[
Map[ToString,momentaList],
Map[ToString,loopMomentaList],
{ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{symmetricPointFiniteTFormRule4pt}];
];


(* ::Input::Initialization:: *)
MakeSPFiniteTFormRule[q_,p_,momenta__]:=Module[{momentaList,qf,Defs,nPt,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules,depth=8},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
qf=ToString[q]<>"f";

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"avMom,intMom,intMomf;";
nPtId=StringJoin[
Map[
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];
nPtCrossId=StringJoin[
Map[
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];
nPtqId=StringJoin[Join[
Map[
"id exMom"<>ToString[#]<>".intMom=sqrt(avMom.avMom)*sqrt(intMom.intMom)*cos"<>ToString[#]<>";\n"&
,Range[1,nPt]
],
Map[
"id exMom"<>ToString[#]<>".intMomf=sqrt(avMom.avMom)*sqrt(intMom.intMom)*cos"<>ToString[#]<>";\n"&
,Range[1,nPt]
]
]];

symmetricPointFiniteTFormRule4pt=finiteTFormExpansion<>"

*** definitions ***
"<>Defs<>"
AutoDeclare CFunction cos;

*** rewrite/expand SPS scalar products
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)^-1=(mom1.mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)=mom1.mom2;\nid FTxvec(mom1?,0)=mom1(0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** simplification ***
"<>StringJoin[StringRepeat[nPtId<>nPtCrossId<>nPtqId<>"argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsps(mom1,mom2)^-1;\nid (mom1?(0))^-1=FTxvec(mom1,0)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsps(mom1,mom2);\nid mom1?(0)=FTxvec(mom1,0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
{"intMomf","intMom","avMom"}
]->
Join[
Map[ToString,momentaList],
{qf,ToString[q],ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{symmetricPointFiniteTFormRule4pt}];
];


(* ::Subsection:: *)
(*Tools*)


(* ::Input::Initialization:: *)
SafeReplaceTrace[expr_]:=Module[{allDressings,rule,reverse},
allDressings=Cases[expr,dressing[__]|_Real,Infinity]//DeleteDuplicates;
rule=Map[#->Unique["dressing"]&,allDressings];
reverse=Map[Values[#]->Keys[#]&,rule];

FormTracer`DefineFormAutoDeclareFunctions@@(FormTracer`Private`formCFunctionAutoDeclareList\[Union]{SymbolName@dressing});

Return[{rule,reverse}];
];


(* ::Input::Initialization:: *)
Protect@$dummy;
customExclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power,a=!=Times,a=!=Rational,a=!=Pattern,a=!=$dummy}
removeFORMTracerRule:=
Map[Head[#][__]:>$dummy[RandomInteger[10^12]]&,Values[FormTracer`Private`lorentzTensorReplacementRulesOutput//Normal]]\[Union]
Map[Head[#][__]:>$dummy[RandomInteger[10^12]]&,Values[FormTracer`Private`groupTensorReplacementRulesOutput//Normal]]\[Union]
Map[#[__]:>$dummy[RandomInteger[10^12]]&,FormTracer`Private`combinedTensorNames]\[Union]
Map[#:>$dummy[RandomInteger[10^12]]&,Global`GetFormTracerGroupConstants[]];
GetAllCustomSymbols[expr_]:=Module[{obj},
obj=DeleteDuplicates@Cases[expr/.removeFORMTracerRule,(a_Symbol/;customExclusions[a])|(a_Symbol[__]/;customExclusions[a]),Infinity];
obj=DeleteDuplicates@((#/.a_[__]:>a)&/@obj);
Return[obj];
];
GetAllMomenta[expr_]:=Module[{obj},
obj=DeleteDuplicates@Cases[expr,sp[__]|sps[__]|vec[__]|vecs[__],Infinity];
obj=obj/.{sp[a_,b_]:>{a,b},sps[a_,b_]:>{a,b},vecs[a_,_]:>{a},vec[a_,_]:>{a}}//Flatten;
obj//DeleteDuplicates
];


(* ::Input::Initialization:: *)
ClearAll[balancedBracesQ]
balancedBracesQ[str_String]:=Module[{cases,idx},
If[Not@(StringCount[str,"("]===StringCount[str,")"]),Return[False]];
cases=StringCases[str,"("|")"];
For[idx=1,idx<=Length[cases],idx++,
If[(Count[cases[[;;idx]],"("]<Count[cases[[;;idx]],")"]),Return[False]];
];
Return[True];
];
hasFortranOperator[a_]:=StringContainsQ[a,"*"]||StringContainsQ[a,"/"]||StringContainsQ[a,"+"]||StringContainsQ[a,"-"]||StringContainsQ[a,"**"]||StringContainsQ[a,"^"]||StringContainsQ[a,"="]||StringContainsQ[a,"("]||StringContainsQ[a,")"]||StringContainsQ[a," "];

fortranToMathematica[expr_String]:=Module[
{start,res,pres},

start=StringPosition[expr,"\n"];
start=If[Length[start]<=1,1,start[[2,1]]];
res=StringTake[expr,{start,-1}];
While[pres=!=res,
pres=res;
res=StringReplace[res,
{
Shortest[(a_/;Not@hasFortranOperator[a])~~"("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>a~~"["~~arg1~~"]",
Shortest["pow("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"Power["~~arg1~~"]",
Shortest["sqrt("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"Sqrt["~~arg1~~"]",
Shortest["FTxsp("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"sp["~~arg1~~"]",
Shortest["FTxsps("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"sps["~~arg1~~"]",
Shortest["FTxvec("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"vec["~~arg1~~"]",
Shortest["FTxvecs("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"vecs["~~arg1~~"]",
Shortest["FTxvecs("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"vecs["~~arg1~~"]",
Shortest["w("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"$w$["~~arg1~~"]",
"**"->"^",
" "->"",
"&\n&"->" ",
"i_"->"\!\(\*TagBox[
StyleBox[
RowBox[{\"Complex\", \"[\", 
RowBox[{\"0\", \",\", \"1\"}], \"]\"}],\nShowSpecialCharacters->False,\nShowStringCharacters->True,\nNumberMarks->True],
FullForm]\)",
"expr="~~a__:>a
}
];
];
StringReplace[res,";"->"\n"]
];


(* ::Input::Initialization:: *)
NormalizeIndices[expr_FTerm]:=Module[{cindices,orderingFunction},
cindices=FormTracer`GetClosedIndices[expr];
orderingFunction[e1_,e2_]:=Module[{p1,p2,idx},
p1=FirstPosition[expr,e1];
p2=FirstPosition[expr,e2];
For[idx=1,idx<=Min[Length[p1],Length[p2]],idx++,
If[p1[[idx]]<p2[[idx]],Return[True]];
If[p1[[idx]]>p2[[idx]],Return[False]];
];
Return[False];
];
cindices=Sort[cindices,orderingFunction];
expr/.Thread[cindices->Table[Symbol["nIdx"<>ToString[idx]],{idx,1,Length[cindices]}]]
];
NormalizeIndices[ex_List]:=Map[NormalizeIndices,ex];
NormalizeIndices[ex_FEx]:=Map[NormalizeIndices,ex];
NormalizeIndices[ex_]:=ex;

makeHashFile[expr_,subdir_:""]:=$TraceCacheDir<>subdir<>ToString@Hash[NormalizeIndices@expr,"SHA256"]<>".m"


(* ::Subsection:: *)
(*Tracing*)


(* ::Input::Initialization:: *)
CreateFormSet[]:=Module[{session},
If[FileExistsQ[Directory[]<>"/form.set"],Return[]];
session=StartExternalSession[{"Python","Evaluator"-><|"Dependencies"->{"formtools-formset"},"EnvironmentName"->"FunKit"|>}];
ExternalEvaluate[session,{"import formset","formset.main(['-o','"<>Directory[]<>"/form.set"<>"','-p','100'])"}];
DeleteObject[session];
];


(* ::Input::Initialization:: *)
Unprotect[FEx,FTerm,FormTracer`FormTrace];

FEx/:FormTracer`FormTrace[name_String,FEx[a__],preReplRules_:{},postReplRules_:{}]:=Module[{idx},
CreateFormSet[];
ParallelTable[FormTracer`FormTrace[makeHashFile[{{a}[[idx]],preReplRules,postReplRules},name<>"/"],{a}[[idx]],preReplRules,postReplRules],{idx,1,Length[{a}]}]
];

FTerm/:FormTracer`FormTrace[file_String,FTerm[a__],preReplRules_:{},postReplRules_:{}]:=Module[
{expr,origVars,tmpfileName,import,repl,formReps,result},
If[FileExistsQ[file],
FunKitDebug[1,"Result already exists, importing from file\n  "<>file];
result=Import[file];
Return[result]
];
result=FormTracer`FormTrace[FTerm[a],preReplRules,postReplRules];
Export[file,result];
Return[result];
];

FEx/:FormTracer`FormTrace[FEx[a__],preReplRules_:{},postReplRules_:{}]:=Module[{},
CreateFormSet[];
ParallelMap[FormTracer`FormTrace[makeHashFile[{#,preReplRules,postReplRules}],#,preReplRules,postReplRules]&,{a}]
];

FTerm/:FormTracer`FormTrace[FTerm[a__],preReplRules_:{},postReplRules_:{}]:=Module[
{expr,origVars,tmpfileName,import,repl,formReps,result,pref},

origVars=FormTracer`GetExtraVars[];
If[NumericQ[{a}[[1]]],
expr=Times@@({a}[[2;;]])//Rationalize;pref={a}[[1]],
expr=Times[a]//Rationalize;pref=1
];
Block[{Print},FormTracer`DisentangleLorentzStructures[True]];

repl=SafeReplaceTrace[expr];
tmpfileName="/tmp/FS_"<>makeTemporaryFileName[];
FormTracer`AddExtraVars@@GetAllCustomSymbols[expr/.repl[[1]]];
formReps=Map[#[[2]]->#[[1]]&,FormTracer`GetExtraVarsSynonyms[]];

FunKitDebug[2,"Custom symbols in expression: ",GetAllCustomSymbols[expr/.repl[[1]]]];

FormTracer`FormTrace[expr/.repl[[1]],preReplRules,Join[$standardFORMmomentumRules,postReplRules],{tmpfileName,"O4,saIter=5000,saMinT=10,saMaxT=10000","fortran90"}];
FormTracer`DefineExtraVars[origVars];
import=Import[tmpfileName,"Text"];

RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import=import//fortranToMathematica;

result=(ToExpression[import]//Rationalize)/.repl[[2]]/.formReps//DiagramSimplify;

Return[pref*result];
];

Protect[FEx,FTerm,FormTrace];


(* ::Subsection:: *)
(*Summing diagrams*)


(* ::Input::Initialization:: *)
$StandardQuickSimplify=Quiet@Simplify[#,TimeConstraint->0.1]&;
$StandardSimplify=Simplify[#]&;


(* ::Input::Initialization:: *)
IterativelySum[expr_List]:=Module[
{returnValue},

returnValue=expr;
If[Length[returnValue]==1,Return[returnValue]];

While[Length[returnValue]>1,
returnValue=ParallelMap[
$StandardQuickSimplify@FORMSimplify[Total[#]]&
,Partition[returnValue,UpTo[4]]]
];

Return[$StandardQuickSimplify[returnValue[[1]]]];
]


(* ::Input::Initialization:: *)
IterativelySum[expr_List,finalSize_Integer/;finalSize>=0]:=Module[
{processLists,returnValue,i},

If[finalSize==0,
Return[IterativelySum[expr][[1]]];
];

processLists=expr;
If[Length[processLists]==finalSize,Return[processLists]];

processLists=Sort[processLists,(ByteCount[#1]>ByteCount[#2])&];
processLists=Table[Downsample[processLists,finalSize,i],{i,1,finalSize}];

returnValue=Map[IterativelySum[#]&,processLists];

Return[Flatten[returnValue]]
];


(* ::Subsection:: *)
(*Simplification*)


findCouplings[expr_]:=Module[
{symbols},
FunKitDebug[2,"findCouplings: looking for custom symbols."];
symbols=GetAllCustomSymbols[expr];
symbols=Pick[symbols,
Map[MemberQ[{expr},#[__],Infinity]&,symbols]
];
symbols=DeleteDuplicates@Cases[expr,Alternatives@@Map[#[__]&,symbols],Infinity];
FunKitDebug[2,"findCouplings: found: ",symbols];
symbols=Pick[symbols,
Not/@Map[MemberQ[{expr},Power[a_,n_]/;(MemberQ[{a},#,Infinity]&&n<0),Infinity]&,symbols]
];
FunKitDebug[2,"findCouplings: picked: ",symbols];

Return@symbols
];

DiagramSimplify[expr_]:=Module[{collected,mSimplify,couplings},
mSimplify=Quiet@Simplify[Simplify[#,Trig->False,TimeConstraint->0.1],Trig->False,TimeConstraint->100]&;
couplings=findCouplings[expr];
FunKitDebug[2,"DiagramSimplify: Found the following couplings in the given expression: ",couplings];
collected=Collect[expr,Map[#[__]&,couplings]];
If[Head[collected]===Plus,collected=List@@collected,collected={collected}];
If[Length[collected]>1,collected=ParallelMap[mSimplify,collected],collected=mSimplify[collected]];
FunKitDebug[2,"DiagramSimplify: Finished"];
Return[Plus@@collected]
];


$standardFORMmomentumRules=FormMomentumExpansion[];
ClearAll[FORMSimplify]
FORMSimplify[obj_,preReplRules_:{},postReplRules_:{}]:=Module[
{file,
origVars,tmpfileName,import,repl,expr,
newSymbols,momenta,momRule,ret
},
file=makeHashFile[obj];
If[FileExistsQ[file],ret=Import[file];Return[ret]];

expr=obj//Rationalize;
origVars=FormTracer`GetExtraVars[];
repl=SafeReplaceTrace[expr];

momenta=expr//GetAllMomenta;
newSymbols=GetAllCustomSymbols[expr/.repl[[1]]];
newSymbols=Select[newSymbols,FreeQ[momenta,#]&];
momRule=If[Length@momenta>0,{{FormTracer`PreambleFormRule,"Vector "<>StringRiffle[momenta,","]<>";"}},{}];

FormTracer`AddExtraVars@@newSymbols;

tmpfileName="/tmp/FS_"<>makeTemporaryFileName[];

FormTracer`FormTrace[Rationalize[expr/.repl[[1]]],Join[momRule,preReplRules],Join[$standardFORMmomentumRules,postReplRules],{tmpfileName,"O4,saIter=5000,saMinT=10,saMaxT=10000","fortran90"}];
import=Import[tmpfileName,"Text"];

RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import=import//fortranToMathematica;

FormTracer`DefineExtraVars[origVars];

FunKitDebug[2,"FORMSimplify: FORM finished, continuing to DiagramSimplify"];

ret=(ToExpression[import]//Rationalize)/.repl[[2]]//DiagramSimplify;

Export[file,ret];
Return[ret];
];


(* ::Section::Closed:: *)
(*End Private*)


End[]


(* ::Title:: *)
(*Testing*)


(* ::Input:: *)
(*Get["FunKit`"]*)
(*fields= <|*)
(*"cField"-> {*)
(*A[p,{v, c}]*)
(*},*)
(*"Grassmann"->{*)
(*{cb[p,{c}],c[p,{c}]}*)
(*}*)
(*|>;*)
(*truncation=<|*)
(*GammaN->{*)
(*{A,A},{A,A,A},{A,A,A,A},*)
(*{A,cb,c},{cb,c}*)
(*},*)
(*Propagator->{*)
(*{A,A},{cb,c}*)
(*},*)
(*Rdot->{*)
(*{A,A},{cb,c}*)
(*},*)
(*S->{*)
(*{A,A},{A,A,A},{A,A,A,A},*)
(*{cb,c},{cb,c,A}*)
(*}*)
(*|>;*)
(*SetTexStyles[cb->"\\bar{c}"];*)
(*bases={*)
(*GammaN->{*)
(*{A,A}->{"AA",1},{A,A,A}->"AAAClass",{A,A,A,A}->"AAAAClass",*)
(*{A,cb,c}->{"Acbc",1},{cb,c}->"cbc"*)
(*},*)
(*Propagator->{*)
(*{A,A}->"AA",{cb,c}->"cbc"*)
(*},*)
(*Rdot->{*)
(*{A,A}->{"AA",1},{cb,c}->"cbc"*)
(*}*)
(*};*)
(*Setup:=<|*)
(*"FieldSpace"->fields,*)
(*"Truncation"->truncation,*)
(*"FeynmanRules"->bases*)
(*|>;*)
(*SetGlobalSetup[Setup];*)
(**)
(*landauGauge=(#/.dressing[GammaN,{A,A},2,{__}]:>1/\[Xi]//.\[Xi]->0)&;*)
(*dressingRules={*)
(*dressing[GammaN,{c,cb},1,{p1_,p2_}]:>ZA[Sqrt[sp[p2,p2]]]sp[p2,p2],*)
(*dressing[GammaN,{A,A},1,{p1_,p2_}]:>Zc[Sqrt[sp[p2,p2]]]sp[p2,p2],*)
(*dressing[GammaN,{c,cb,A},1,{p1_,p2_,p3_}]:>ZccbA[p1,p2], *)
(*dressing[GammaN,{A,A,A},1,{p1_,p2_,p3_}]:>ZA3[p1,p2], *)
(*dressing[GammaN,{A,A,A,A},1,{p1_,p2_,p3_,p4_}]:>ZA4[p1,p2,p3] ,*)
(**)
(*ZccbA[p1_,p2_]:>ZccbA[Sqrt[(sp[p1,p1]+sp[p2,p2]+sp[-p1-p2,-p1-p2])/3]],*)
(*ZA3[p1_,p2_]:>ZA3[Sqrt[(sp[p1,p1]+sp[p2,p2]+sp[-p1-p2,-p1-p2])/3]],*)
(*ZA4[p1_,p2_,p3_]:>ZA4[Sqrt[(sp[p1,p1]+sp[p2,p2]+sp[p3,p3]+sp[-p1-p2-p3,-p1-p2-p3])/4]],*)
(**)
(*nZA->6,*)
(*evP:>(k^nZA+1)^(1/nZA),*)
(*devP:>k^(-1+nZA) (1+k^nZA)^(-1+1/nZA),*)
(*dressing[Rdot,{A,A},1,{p1_,p2_}]:>ZA[evP]RBdot[k^2,sp[p2,p2]]+RB[k^2,sp[p2,p2]](dtZA[evP]+k*devP*(ZA[1.02evP]-ZA[evP])/(0.02*evP)),*)
(*dressing[Rdot,{c,cb},1,{p1_,p2_}]:>Zc[k]RBdot[k^2,sp[p2,p2]]+RB[k^2,sp[p2,p2]](dtZc[k]+k (Zc[1.02*k]-Zc[k])/(0.02*k))*)
(*};*)
(*PropParam[expr_]:=UseLorentzLinearity[expr]//.{sp[p1,p1]->p^2,sp[l1,l1]->l1^2,sp[l1,p1]->l1 p cos1,Sqrt[a_^2]:>a}//$StandardQuickSimplify;*)
(*SPParam[expr_]:=UseLorentzLinearity[expr]//.{sp[p,p]->p^2,sp[l1,l1]->l1^2,Sqrt[a_^2]:>a}//$StandardQuickSimplify;*)
(*SetNc[3]*)


(* ::Input:: *)
(*$Assumptions=k>0&&p>0&&l1>0&&-1<cos1<1-1<cos2<1&&-1<cos3<1*)


(* ::Title:: *)
(*Below*)


(* ::Input:: *)
(*DerivativeListcbc={cb[i1],c[i2]};*)
(*equationcbc=TakeDerivatives[Setup,WetterichEquation,DerivativeListcbc];*)
(*equationcbc=equationcbc//Truncate//FSimplify//Route;*)
(*traceExprcbc=F[TBGetProjector["cbc",1,{i1,i2}/.equationcbc["externalIndices"]],(equationcbc["result"]/.MakeDiagrammaticRules[Setup]//landauGauge)];*)
(*Flowcbc=FormTrace["cbc",traceExprcbc]//.dressingRules//FORMSimplify//PropParam*)


(* ::Input:: *)
(*DerivativeListAA={A[i1],A[i2]};*)
(*equationAA=TakeDerivatives[Setup,WetterichEquation,DerivativeListAA];*)
(*equationAA=equationAA//Truncate//FSimplify//Route;*)
(*traceExprAA=F[TBGetProjector["AA",1,{i1,i2}/.equationAA["externalIndices"]],(equationAA["result"]/.MakeDiagrammaticRules[Setup]//landauGauge)];*)
(*FlowAA=FormTrace["AA",traceExprAA]//.dressingRules//FORMSimplify//PropParam*)


(* ::Input:: *)
(*DerivativeListccbA={c[i3],cb[i2], A[i1]};*)
(*equationccbA=TakeDerivatives[Setup,WetterichEquation,DerivativeListccbA];*)
(*equationccbA=equationccbA//Truncate//FSimplify//Route;*)
(*traceExprccbA=F[TBGetProjector["Acbc",1,{i1,i2,i3}/.equationccbA["externalIndices"]],(equationccbA["result"]/.MakeDiagrammaticRules[Setup]//landauGauge)];*)
(*FlowccbA=FormTrace["ccbA",traceExprccbA,MakeSPFormRule[l1,p,p1,p2,p3],MakeSPFormRule[l1,p,p1,p2,p3]]//.dressingRules//*)
(*FORMSimplify[#,MakeSPFormRule[l1,p,p1,p2,p3],MakeSPFormRule[l1,p,p1,p2,p3]]&//SPParam*)


(* ::Input:: *)
(*DerivativeListA3={ A[i1],A[i2],A[i3]};*)
(*equationA3=TakeDerivatives[Setup,WetterichEquation,DerivativeListA3]//Truncate//FSimplify//Route;*)
(*projectorA3=TBGetProjector["AAAClassTrans",1,{i1,i2,i3}/.equationA3["externalIndices"]]//TBProjectToSymmetricPoint[#,l1,p,p1,p2,p3]&//Simplify;*)
(*traceExprA3=F[projectorA3,(equationA3["result"]/.MakeDiagrammaticRules[Setup]//landauGauge)];*)
(*FlowA3=FormTrace["A3",traceExprA3,MakeSPFormRule[l1,p,p1,p2,p3],MakeSPFormRule[l1,p,p1,p2,p3]]//.dressingRules//FORMSimplify[#,MakeSPFormRule[l1,p,p1,p2,p3],MakeSPFormRule[l1,p,p1,p2,p3]]&//SPParam*)


(* ::Input:: *)
(*Block[{Print},Get["FunKit`"]];*)
(*SetGlobalSetup[Setup];*)
(*DerivativeListA3={ A[i1],A[i2],A[i3]};*)
(*equationA3=TakeDerivatives[Setup,WetterichEquation,DerivativeListA3]//Truncate//FSimplify[Setup,#,Map[Join[#/.Cycles->Sequence,{1}]&,PermutationCycles/@Permutations[{1,2,3}]],{i1,i2,i3}]&*)


(* ::Input:: *)
(*DerivativeListA4={ A[i1],A[i2],A[i3],A[i4]};*)
(*equationA4=TakeDerivatives[Setup,WetterichEquation,DerivativeListA4]//Truncate//FSimplify[Setup,#,Map[Join[#/.Cycles->Sequence,{1}]&,PermutationCycles/@Permutations[{1,2,3,4}]],{i1,i2,i3,i4}]&//FPlot;*)


(* ::Input:: *)
(*Times@@equationA4[[1]]*)


(* ::Input:: *)
(*NormalizeIndices[setup_,expr_]:=Module[{cindices},*)
(*cindices=FunKit`Private`GetClosedSuperIndices[setup,FTerm[Times@@expr]]*)
(**)
(*]*)
(*NormalizeIndices[Setup,Reverse@equationA4[[1]]]*)


(* ::Input:: *)
(*DerivativeListA4={ A[i1],A[i2],A[i3],A[i4]};*)
(*equationA4=TakeDerivatives[Setup,WetterichEquation,DerivativeListA4]//Truncate//FSimplify[Setup,#,Map[Join[#/.Cycles->Sequence,{1}]&,PermutationCycles/@Permutations[{1,2,3,4}]],{i1,i2,i3,i4}]&//Route;*)
(*projectorA4=TBGetProjector["AAAAClassTrans",1,{i1,i2,i3,i4}/.equationA4["externalIndices"]]//TBProjectToSymmetricPoint[#,l1,p,p1,p2,p3,p4]&//Simplify;*)
(*traceExprA4=F[projectorA4,(equationA4["result"]/.MakeDiagrammaticRules[Setup]//landauGauge)];*)
(*FlowA4=FormTrace["A4",traceExprA4,MakeSPFormRule[l1,p,p1,p2,p3,p4],MakeSPFormRule[l1,p,p1,p2,p3,p4]]//.dressingRules//*)
(*FORMSimplify[#,MakeSPFormRule[l1,p,p1,p2,p3,p4],MakeSPFormRule[l1,p,p1,p2,p3,p4]]&//SPParam*)


(* ::Input:: *)
(*Map[Join[#/.Cycles->Sequence,{1}]&,PermutationCycles/@Permutations[{1,2,3,4}]]*)


(* ::Input:: *)
(*For[idx=1,idx<=57,idx++,*)
(*file="TraceCache/A4/Diagram_"<>ToString[idx]<>".m";*)
(*in=Import[file]//Simplify;*)
(*Export[file,in];*)
(*]*)
