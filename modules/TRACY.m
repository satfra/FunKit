(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

(* ::Input::Initialization:: *)
FORMSimplify::usage=""

IterativelySum::usage=""
FormMomentumExpansion::usage=""
FiniteTFormMomentumExpansion::usage=""
MakeP0FormRule::usage=""
MakeSPFormRule::usage=""
MakeSPFiniteTFormRule::usage=""
DiagramSimplify::usage=""


Begin["`Private`"]


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"TRACY","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"TRACY","FEDeriK"];
Abort[];
];

ModuleLoaded[TRACY]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
makeTemporaryFileName[]:=ToString[AbsoluteTime[]*10^6//Round]<>"_"<>ToString[RandomInteger[{10^6,10^7}]]


(* ::Input::Initialization:: *)
SetCacheDirectory::invalid="The directory \"`1` \"could not be created.";
SetCacheDirectory[str_String]:=Module[{mstr=str},
If[StringTake[mstr,{-1}]=!="/",mstr=StringJoin[mstr,"/"]];

CreateDirectory[mstr]//Quiet;
If[DirectoryQ[mstr],
Set[$TraceCacheDir,mstr],
Message[SetCacheDirectory::invalid,mstr];Abort[]
];
];
SetCacheDirectory["/tmp/TraceCache/"];
ClearTraceCache[]:=(DeleteDirectory[$TraceCacheDir,DeleteContents->True];CreateDirectory[$TraceCacheDir])
ClearTraceCache[str_String]:=(DeleteDirectory[$TraceCacheDir<>str,DeleteContents->True])



(* ::Input::Initialization:: *)
finiteTFormExpansion:=Module[{depth=8},"
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0))^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"];
finiteTFormExpansionDis={finiteTFormExpansion};


(* ::Input::Initialization:: *)
RemoveFromExtraVars[obj_]:=Module[{extraVars,postExtraVars},
extraVars=FormTracer`GetExtraVars[];
postExtraVars=If[MemberQ[extraVars,obj],DeleteCases[extraVars,obj],extraVars];

If[extraVars=!=postExtraVars,
FormTracer`DefineExtraVars[postExtraVars];Print["Error: Momentum \""<>ToString[obj]<>"\" had been defined as an extra variable in FormTracer!"];
Abort[];
];
];


(* ::Input::Initialization:: *)
FormMomentumExpansion[momenta___]:=Module[{Defs,code,depth=8},
RemoveFromExtraVars/@{momenta};

Defs=If[Length[{momenta}]>0,"Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";",""];

code="
*** definitions ***
"<>Defs<>"

*** rewrite/expand SP scalar products
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=mom1.mom2;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsp(mom1,mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsp(mom1,mom2);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite/expand SPS scalar products
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)=mom1.mom2;\nid FTxvec(mom1?,0)=mom1(0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsps(mom1,mom2)^-1;\nid (mom1?(0))^-1=FTxvec(mom1,0)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsps(mom1,mom2);\nid mom1?(0)=FTxvec(mom1,0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";

Return[{code}];
];


(* ::Input::Initialization:: *)
FiniteTFormMomentumExpansion[momenta___]:=Module[{Defs,code},
RemoveFromExtraVars/@{momenta};

Defs=If[Length[{momenta}]>0,"Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";",""];

code=finiteTFormExpansion;

Return[{code}];
];


(* ::Input::Initialization:: *)
MakeP0FormRule[q_,{momenta__},{projections__}]:=Module[
{momentaList,projectionsList,qf,nPt,Defs,repRules,freqRules,
externalFreqRule,depth=8},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
projectionsList={projections};
qf=ToString[q]<>"f";

If[Length[momentaList]!=Length[projectionsList],Print["Momentum and projection list have differing length!"];Abort[]];

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"intMom,intMomf;";
repRules=Thread[
Join[Map["exMom"<>ToString[#]&,Range[1,nPt]],{"intMomf","intMom","FTxI"}]->Join[Map[ToString,momentaList],{qf,ToString[q],"i_"}]
];
freqRules=StringTake[StringJoin[Map["id exMom"<>ToString[#]<>"(0)="<>ToString[CForm[projectionsList[[#]]/.Complex[re_,im_]:>re+FTxI im/.Thread[FormTracer`GetExtraVarsSynonyms[][[All,1]]->FormTracer`GetExtraVarsSynonyms[][[All,2]]]]]<>";\n"&,Range[1,nPt]]],{1,-2}];

externalFreqRule=finiteTFormExpansion<>Defs<>"

"<>StringJoin[StringRepeat["id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";

externalFreqRule=StringReplace[externalFreqRule,repRules];
Return[{externalFreqRule}];
];


(* ::Input::Initialization:: *)
MakeFTCos[a_,b_]:=Module[{res},
res="cos"<>StringJoin[Map[ToString,Sort[{a,b}]]];
If[StringTake[res,-1]=="f",Return[Symbol[StringTake[res,{1,-2}]]],Return[Symbol[res]]]
];


(* ::Input::Initialization:: *)
GetFTSynonym[symbol_]:=Module[{},
If[symbol===I,Return[FTxI//ToString]];

If[Head[symbol]=!=Symbol,Print["The value \""<>ToString[symbol]<>"\" is not a symbol!"];Abort[]];

If[Not@MemberQ[FormTracer`GetExtraVarsSynonyms[],symbol,Infinity],FormTracer`AddExtraVars[symbol]];
ToString@Select[FormTracer`GetExtraVarsSynonyms[],#[[1]]==symbol&][[1,2]]
]


(* ::Input::Initialization:: *)
MakeSPFormRule[{loopMomenta__},p_,{momenta__}]:=Module[{momentaList,loopMomentaList,Defs,nPt,nLoops,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules,depth=8,i,j},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
loopMomentaList={loopMomenta};

nPt=Length[momentaList];
nLoops=Length[{loopMomenta}];

Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>StringJoin[Map["intMom"<>ToString[#]<>","&,Range[1,nLoops]]]<>"avMom;";

nPtId=StringJoin[
Map[
"id (exMom"<>ToString[#]<>".exMom"<>ToString[#]<>")^-1=(avMom.avMom)^-1;\n"<>
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];

nPtCrossId=StringJoin[
Map[
"id (exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>")^-1=(-avMom.avMom/"<>ToString[nPt-1]<>")^-1;\n"<>
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];

nPtqId=StringJoin[
Table[
"id (exMom"<>ToString[i]<>".intMom"<>ToString[j]<>")^-1=(sqrt(avMom.avMom)*sqrt(intMom"<>ToString[j]<>".intMom"<>ToString[j]<>")*cos(exMom"<>ToString[i]<>",intMom"<>ToString[j]<>"))^-1;\n"<>
"id exMom"<>ToString[i]<>".intMom"<>ToString[j]<>"=sqrt(avMom.avMom)*sqrt(intMom"<>ToString[j]<>".intMom"<>ToString[j]<>")*cos(exMom"<>ToString[i]<>",intMom"<>ToString[j]<>");\n"
,{i,1,nPt},{j,1,nLoops}
]
];

symmetricPointFiniteTFormRule4pt="
*** definitions ***
"<>Defs<>"
AutoDeclare CFunction cos;

*** rewrite/expand SP scalar products
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)^-1=(mom1.mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsp(mom1?,mom2?)=mom1.mom2;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** simplification ***
"<>StringJoin[StringRepeat[nPtId<>nPtCrossId<>nPtqId<>"argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsp(mom1,mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsp(mom1,mom2);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
Map["intMom"<>ToString[#]&,Range[1,nLoops]],
{"avMom"}
]->
Join[
Map[ToString,momentaList],
Map[ToString,loopMomentaList],
{ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{symmetricPointFiniteTFormRule4pt}];
];


(* ::Input::Initialization:: *)
MakeSPFiniteTFormRule[q_,p_,momenta__]:=Module[{momentaList,qf,Defs,nPt,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules,depth=8},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
qf=ToString[q]<>"f";

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"avMom,intMom,intMomf;";
nPtId=StringJoin[
Map[
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];
nPtCrossId=StringJoin[
Map[
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];
nPtqId=StringJoin[Join[
Map[
"id exMom"<>ToString[#]<>".intMom=sqrt(avMom.avMom)*sqrt(intMom.intMom)*cos"<>ToString[#]<>";\n"&
,Range[1,nPt]
],
Map[
"id exMom"<>ToString[#]<>".intMomf=sqrt(avMom.avMom)*sqrt(intMom.intMom)*cos"<>ToString[#]<>";\n"&
,Range[1,nPt]
]
]];

symmetricPointFiniteTFormRule4pt=finiteTFormExpansion<>"

*** definitions ***
"<>Defs<>"
AutoDeclare CFunction cos;

*** rewrite/expand SPS scalar products
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)^-1=(mom1.mom2)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id FTxsps(mom1?,mom2?)=mom1.mom2;\nid FTxvec(mom1?,0)=mom1(0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** simplification ***
"<>StringJoin[StringRepeat[nPtId<>nPtCrossId<>nPtqId<>"argument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort

*** rewrite as FormTracer scalar products again ***
"<>StringJoin[StringRepeat["id (mom1?.mom2?)^-1=FTxsps(mom1,mom2)^-1;\nid (mom1?(0))^-1=FTxvec(mom1,0)^-1;\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
"<>StringJoin[StringRepeat["id mom1?.mom2?=FTxsps(mom1,mom2);\nid mom1?(0)=FTxvec(mom1,0);\nargument;\n",depth]<>StringRepeat["endargument;\n",depth]]<>"
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
{"intMomf","intMom","avMom"}
]->
Join[
Map[ToString,momentaList],
{qf,ToString[q],ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{symmetricPointFiniteTFormRule4pt}];
];


(* ::Input::Initialization:: *)
SafeReplaceTrace[expr_]:=Module[{allDressings,rule,reverse},
allDressings=Cases[expr,dressing[__]|_Real,Infinity]//DeleteDuplicates;
rule=Map[#->Unique["dressing"]&,allDressings];
reverse=Map[Values[#]->Keys[#]&,rule];

FormTracer`DefineFormAutoDeclareFunctions@@(FormTracer`Private`formCFunctionAutoDeclareList\[Union]{SymbolName@dressing});

Return[{rule,reverse}];
];


(* ::Input::Initialization:: *)
Protect@$dummy;
customExclusions[a_]:=And@@{a=!=List,a=!=Complex,a=!=Plus,a=!=Power,a=!=Times,a=!=Rational,a=!=$dummy}
removeFORMTracerRule:=
Map[Head[#][__]:>$dummy[RandomInteger[10^12]]&,Values[FormTracer`Private`lorentzTensorReplacementRulesOutput//Normal]]\[Union]
Map[Head[#][__]:>$dummy[RandomInteger[10^12]]&,Values[FormTracer`Private`groupTensorReplacementRulesOutput//Normal]]\[Union]
Map[#[__]:>$dummy[RandomInteger[10^12]]&,FormTracer`Private`combinedTensorNames]\[Union]
Map[#:>$dummy[RandomInteger[10^12]]&,Global`GetFormTracerGroupConstants[]];
GetAllCustomSymbols[expr_]:=Module[{obj},
obj={};
expr/.removeFORMTracerRule//.{
a_Symbol[b__]/;customExclusions[a]:>(AppendTo[obj,a];$dummy[RandomInteger[10^12],b]),
a_Symbol/;customExclusions[a]:>(AppendTo[obj,a];$dummy[RandomInteger[10^12]])
};
obj//DeleteDuplicates
];
GetAllMomenta[expr_]:=Module[{obj},
obj={};
expr/.sp[a_,b_]:>(AppendTo[obj,{a,b}];$dummy[RandomInteger[10^12],b]);
obj//GetAllCustomSymbols
];


(* ::Input::Initialization:: *)
ClearAll[balancedBracesQ]
balancedBracesQ[str_String]:=Module[{cases,idx},
If[Not@(StringCount[str,"("]===StringCount[str,")"]),Return[False]];
cases=StringCases[str,"("|")"];
For[idx=1,idx<=Length[cases],idx++,
If[(Count[cases[[;;idx]],"("]<Count[cases[[;;idx]],")"]),Return[False]];
];
Return[True];
];
hasFortranOperator[a_]:=StringContainsQ[a,"*"]||StringContainsQ[a,"/"]||StringContainsQ[a,"+"]||StringContainsQ[a,"-"]||StringContainsQ[a,"**"]||StringContainsQ[a,"^"]||StringContainsQ[a,"="]||StringContainsQ[a,"("]||StringContainsQ[a,")"];

fortranToMathematica[expr_String]:=Module[
{start,res,pres},

start=StringPosition[expr,"\n"];
start=If[Length[start]<=1,1,start[[2,1]]];
res=StringTake[expr,{start,-1}];
While[pres=!=res,
pres=res;
res=StringReplace[res,
{
Shortest[(a_/;Not@hasFortranOperator[a])~~"("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>a~~"["~~arg1~~"]",
Shortest["pow("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"Power["~~arg1~~"]",
Shortest["sqrt("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"Sqrt["~~arg1~~"]",
Shortest["FTxsp("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"sp["~~arg1~~"]",
Shortest["w("~~(arg1__/;balancedBracesQ[arg1])~~")"]:>"$w$["~~arg1~~"]",
"**"->"^",
" "->"",
"&\n&"->" ",
"expr="~~a__:>a
}
];
];
res
];


(* ::Input::Initialization:: *)
NormalizeIndices[expr_FTerm]:=Module[{cindices,orderingFunction},
cindices=FormTracer`GetClosedIndices[expr];
orderingFunction[e1_,e2_]:=Module[{p1,p2,idx},
p1=FirstPosition[expr,e1];
p2=FirstPosition[expr,e2];
For[idx=1,idx<=Min[Length[p1],Length[p2]],idx++,
If[p1[[idx]]<p2[[idx]],Return[True]];
If[p1[[idx]]>p2[[idx]],Return[False]];
];
Return[False];
];
cindices=Sort[cindices,orderingFunction];
expr/.Thread[cindices->Table[Symbol["nIdx"<>ToString[idx]],{idx,1,Length[cindices]}]]
];

makeHashFile[expr_,subdir_:""]:=$TraceCacheDir<>subdir<>ToString@Hash[NormalizeIndices@expr,"SHA256"]<>".m"


(* ::Input::Initialization:: *)
CreateFormSet[]:=Module[{session},
If[FileExistsQ[Directory[]<>"/form.set"],Return[]];
session=StartExternalSession[{"Python","Evaluator"-><|"Dependencies"->{"formtools-formset"},"EnvironmentName"->"FunKit"|>}];
ExternalEvaluate[session,{"import formset","formset.main(['-o','"<>Directory[]<>"/form.set"<>"','-p','100'])"}];
DeleteObject[session];
];


(* ::Input::Initialization:: *)
Unprotect[FEq,FTerm,FormTracer`FormTrace];

FEq/:FormTracer`FormTrace[name_String,FEq[a__],preReplRules_:{},postReplRules_:{}]:=Module[{idx},
CreateFormSet[];
ParallelTable[FormTracer`FormTrace[makeHashFile[{{a}[[idx]],preReplRules,postReplRules},name<>"/"],{a}[[idx]],preReplRules,postReplRules],{idx,1,Length[{a}]}]
];
FTerm/:FormTracer`FormTrace[file_String,FTerm[a__],preReplRules_:{},postReplRules_:{}]:=Module[
{expr,origVars,tmpfileName,import,repl,formReps,result},
If[FileExistsQ[file],result=Import[file];Return[result]];
result=FormTracer`FormTrace[FTerm[a],preReplRules,postReplRules];
Export[file,result];
Return[result];
];

FEq/:FormTracer`FormTrace[FEq[a__],preReplRules_:{},postReplRules_:{}]:=Module[{},
CreateFormSet[];
ParallelMap[FormTracer`FormTrace[makeHashFile[{#,preReplRules,postReplRules}],#,preReplRules,postReplRules]&,{a}]
];
FTerm/:FormTracer`FormTrace[FTerm[a__],preReplRules_:{},postReplRules_:{}]:=Module[
{expr,origVars,tmpfileName,import,repl,formReps,result,pref},

origVars=FormTracer`GetExtraVars[];
If[NumericQ[{a}[[1]]],
expr=Times@@({a}[[2;;]])//Rationalize;pref={a}[[1]],
expr=Times[a]//Rationalize;pref=1
];
Block[{Print},FormTracer`DisentangleLorentzStructures[True]];

repl=SafeReplaceTrace[expr];
tmpfileName="/tmp/FS_"<>makeTemporaryFileName[];
FormTracer`AddExtraVars@@GetAllCustomSymbols[expr/.repl[[1]]];
formReps=Map[#[[2]]->#[[1]]&,FormTracer`GetExtraVarsSynonyms[]];

FormTracer`FormTrace[expr/.repl[[1]],preReplRules,Join[$standardFORMmomentumRules,postReplRules],{tmpfileName,"O4","fortran90"}];
FormTracer`DefineExtraVars[origVars];
import=Import[tmpfileName,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import=import//fortranToMathematica;
result=(ToExpression[import]//Rationalize)/.repl[[2]]/.formReps//DiagramSimplify;

Return[pref*result];
];

Protect[FEq,FTerm,FormTrace];


(* ::Input::Initialization:: *)
$StandardQuickSimplify=Quiet@Simplify[#,TimeConstraint->0.1]&;
$StandardSimplify=Simplify[#]&;


(* ::Input::Initialization:: *)
IterativelySum[expr_List]:=Module[
{returnValue},

returnValue=expr;
If[Length[returnValue]==1,Return[returnValue]];

While[Length[returnValue]>1,
returnValue=ParallelMap[
$StandardQuickSimplify@FORMSimplify[Total[#]]&
,Partition[returnValue,UpTo[4]]]
];

Return[$StandardQuickSimplify[returnValue[[1]]]];
]


(* ::Input::Initialization:: *)
IterativelySum[expr_List,finalSize_Integer/;finalSize>=0]:=Module[
{processLists,returnValue,i},

If[finalSize==0,
Return[IterativelySum[expr][[1]]];
];

processLists=expr;
If[Length[processLists]==finalSize,Return[processLists]];

processLists=Sort[processLists,(ByteCount[#1]>ByteCount[#2])&];
processLists=Table[Downsample[processLists,finalSize,i],{i,1,finalSize}];

returnValue=Map[IterativelySum[#]&,processLists];

Return[Flatten[returnValue]]
];


(* ::Input::Initialization:: *)
findCouplings[expr_]:=Module[
{symbols},
symbols=GetAllCustomSymbols[expr];
symbols=Pick[symbols,
Map[MemberQ[{expr},#[__],Infinity]&,symbols]
];

symbols=Cases[expr,Alternatives@@Map[#[__]&,symbols],Infinity];
symbols=Pick[symbols,
Not/@Map[MemberQ[{expr},Power[a_,n_]/;(MemberQ[{a},#,Infinity]&&n<0),Infinity]&,symbols]
];

Return@symbols
];

DiagramSimplify[expr_]:=Module[{collected},
collected=Collect[expr,Map[#[__]&,findCouplings[expr]]];
If[Head[collected]===Plus,collected=List@@collected,collected={collected}];
If[Length[collected]>1,collected=ParallelMap[Simplify,collected],collected=Simplify[collected]];
Return[Plus@@collected]
];


(* ::Input::Initialization:: *)
$standardFORMmomentumRules=FormMomentumExpansion[];
ClearAll[FORMSimplify]
FORMSimplify[obj_,preReplRules_:{},postReplRules_:{}]:=Module[
{file,
origVars,tmpfileName,import,repl,expr,
newSymbols,momenta,momRule,ret
},
file=makeHashFile[obj];
If[FileExistsQ[file],ret=Import[file];Return[ret]];

expr=obj//Rationalize;
origVars=FormTracer`GetExtraVars[];
repl=SafeReplaceTrace[expr];

momenta=expr//GetAllMomenta;
newSymbols=GetAllCustomSymbols[expr/.repl[[1]]];
newSymbols=Select[newSymbols,FreeQ[momenta,#]&];
momRule=If[Length@momenta>0,{{FormTracer`PreambleFormRule,"Vector "<>StringRiffle[momenta,","]<>";"}},{}];

FormTracer`AddExtraVars@@newSymbols;

tmpfileName="/tmp/FS_"<>makeTemporaryFileName[];

FormTracer`FormTrace[Rationalize[expr/.repl[[1]]],Join[momRule,preReplRules],Join[$standardFORMmomentumRules,postReplRules],{tmpfileName,"O4","fortran90"}];
import=Import[tmpfileName,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import=import//fortranToMathematica;

FormTracer`DefineExtraVars[origVars];

ret=(ToExpression[import]//Rationalize)/.repl[[2]]//DiagramSimplify;

Export[file,ret];
Return[ret];
];


End[]



