(* ::Package:: *)

(* ::Input:: *)

(*SetOptions[EvaluationNotebook[],AutoGeneratedPackage->"TRACY.m"]*)

(* ::Title:: *)

(*TRACY -  Tracing Representations And Contractions Yourself*)

(* ::Section::Closed:: *)

(*Exports*)

(* ::Input::Initialization:: *)

FORMSimplify::usage = "FORMSimplify[expr]
FORMSimplify[expr, preReplRules, postReplRules]
Simplifies expressions using FORM's output optimization (O4) algorithms.
The first form uses default replacement rules for momentum expansion.
The second form allows specifying custom FORM preRepl and postRepl rules.
Integrates with FormTrace for powerful symbolic manipulation and optimization.
Essential for handling large expressions that benefit from FORM's optimization capabilities.";

SetAlwaysExpandLorentzTensors::usage = "";

IterativelySum::usage = "IterativelySum[list]
IterativelySum[list, finalSize]
Efficiently sums large lists of expressions by breaking them into subsets.
The first form repeatedly sums and simplifies until only a single expression remains.
The second form returns a list of specified finalSize with equally-sized terms.
Uses parallel processing and incremental simplification for optimal performance.
Crucial for managing memory and computation time in large symbolic calculations.";

FormMomentumExpansion::usage = "FormMomentumExpansion[]
FormMomentumExpansion[momenta...]
Creates a FORM rule to expand out any scalar products in expressions.
The optional momenta arguments specify which momenta to expand.
Can be passed as a postRepl or preRepl rule to FormTrace or FORMSimplify.
Essential for converting momentum-space expressions into expanded form for integration.";

FiniteTFormMomentumExpansion::usage = "FiniteTFormMomentumExpansion[]  
FiniteTFormMomentumExpansion[momenta...]
Creates a FORM rule to expand scalar products into spatial and temporal parts.
The optional momenta arguments specify which momenta to expand.
Separates d-dimensional momenta into (d-1)-dimensional spatial parts and time components.
Can be passed as a postRepl or preRepl rule to FormTrace or FORMSimplify.
Useful for finite-temperature field theory calculations.";

MakeP0Rule::usage = "MakeP0Rule[q, {p1, p2, ...}, {proj1, proj2, ...}]
Creates a replacement rule to project temporal components of momentum expressions.
The first argument q is the internal (loop) momentum variable.
The second argument is a list of external momenta {p1, p2, ...}.
The third argument is a list of projections {proj1, proj2, ...} for the temporal components.
Sets vec[pi,0] to the value of proji for finite-temperature field theory calculations.
Essential for evaluating expressions at specific temporal momentum projections.";

MakeP0FormRule::usage = "MakeP0FormRule[q, {p1, p2, ...}, {proj1, proj2, ...}]
Creates a FORM rule to project temporal components of momentum expressions.
The first argument q is the internal (loop) momentum variable.
The second argument is a list of external momenta {p1, p2, ...}.
The third argument is a list of projections {proj1, proj2, ...} for the temporal components.
Sets vec[pi,0] to the value of proji for finite-temperature field theory calculations.
Essential for evaluating expressions at specific temporal momentum projections.";

MakeSPFormRule::usage = "MakeSPFormRule[{l1, l2, ...}, p, {p1, p2, ...}]
Creates a FORM rule for symmetric point momentum configuration.
The first argument is a list of loop momenta {l1, l2, ...}.
The second argument p is the average momentum scale.
The third argument is a list of external leg momenta {p1, p2, ...}.
Projects all momenta to a symmetric configuration with average momentum p.
Crucial for evaluating loop integrals at the symmetric point for RG calculations.";

MakeSPFiniteTFormRule::usage = "MakeSPFiniteTFormRule[q, p, p1, p2, ...]
Creates a FORM rule for (d-1)-dimensional symmetric point configuration.
The first argument q is the internal (loop) momentum variable.
The second argument p is the average spatial momentum scale.
Remaining arguments are external leg momenta.
Projects momenta to spatial symmetric point configuration for finite-temperature calculations.
Separates temporal and spatial components for thermal field theory applications.";

ClearTraceCache::usage = "ClearTraceCache[]
ClearTraceCache[subdirectory]
Removes cached trace files from the trace cache directory.
The first form removes all files in the main trace cache (usually /tmp/TraceCache/).
The second form removes files from a specific subdirectory within the cache.
Use this to free up disk space or force recomputation of previously traced expressions.
Essential for cache management in long-running calculations.";

SetCacheDirectory::usage = "SetCacheDirectory[folder]
SetCacheDirectory[]
Changes the directory where traced expressions are cached.
The first form sets the cache directory to the specified folder path.
The second form resets the cache directory to the default /tmp/TraceCache/.
The cache directory stores intermediate results to avoid recomputation.
Per default, the cache directory is set to /tmp/TraceCache/.";

DiagramSimplify::usage = "DiagramSimplify[expr]
Simplifies diagrammatic expressions by collecting terms and optimizing their structure.
Uses advanced algorithms to identify common subexpressions and factor them efficiently.
Particularly effective for expressions with many coupling constants and similar terms.
Integrates with FORM's optimization capabilities when available for maximum efficiency.
Essential for making large diagrammatic calculations computationally manageable.";

(* ::Section::Closed:: *)

(*Begin Private*)

Begin["`Private`"]

(* ::Section::Closed:: *)

(*Global variables*)

(* ::Input::Initialization:: *)

ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "TRACY", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "TRACY", "FEDeriK"];
    Abort[];
];

ModuleLoaded[TRACY] = True;

(* ::Input::Initialization:: *)

$FunKitDirectory = SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory, "Applications", "FunKit"}], FileNameJoin[{$BaseDirectory, "Applications", "FunKit"}], FileNameJoin[{$InstallationDirectory, "AddOns", "Applications", "FunKit"}], FileNameJoin[{$InstallationDirectory, "AddOns", "Packages", "FunKit"}], FileNameJoin[{$InstallationDirectory, "AddOns", "ExtraPackages", "FunKit"}]}, Select[$Path, StringContainsQ[#, "FunKit"]&]], DirectoryQ[#]&] <> "/";

(* ::Input::Initialization:: *)

makeTemporaryFileName[] :=
    ToString[AbsoluteTime[] * 10^6 // Round] <> "_" <> ToString[RandomInteger[{10^6, 10^7}]]

(* ::Input::Initialization:: *)

SetCacheDirectory::invalid = "The directory \"`1` \"could not be created.";

SetCacheDirectory[str_String] :=
    Module[{mstr = str},
        If[StringTake[mstr, {-1}] =!= "/",
            mstr = StringJoin[mstr, "/"]
        ];
        CreateDirectory[mstr] // Quiet;
        If[DirectoryQ[mstr],
            Set[$TraceCacheDir, mstr]
            ,
            Message[SetCacheDirectory::invalid, mstr];
            Abort[]
        ];
    ];

SetCacheDirectory[] :=
    SetCacheDirectory["/tmp/TraceCache/"];

SetCacheDirectory[];

ClearTraceCache[] :=
    (
        DeleteDirectory[$TraceCacheDir, DeleteContents -> True];
        CreateDirectory[$TraceCacheDir]
    )

ClearTraceCache[str_String] :=
    (DeleteDirectory[$TraceCacheDir <> str, DeleteContents -> True])

(* ::Section:: *)

(*FORM*)

(* ::Subsection:: *)

(*FormTracer PostReplacement Code*)

(* ::Subsubsection:: *)

(*Tools*)

(* ::Input::Initialization:: *)

GetFTSynonym[symbol_] :=
    Module[{},
        If[symbol === I,
            Return[FTxI // ToString]
        ];
        If[Head[symbol] =!= Symbol,
            Print["The value \"" <> ToString[symbol] <> "\" is not a symbol!"];
            Abort[]
        ];
        If[Not @ MemberQ[FormTracer`GetExtraVarsSynonyms[], symbol, Infinity],
            FormTracer`AddExtraVars[symbol]
        ];
        ToString @ Select[FormTracer`GetExtraVarsSynonyms[], #[[1]] == symbol&][[1, 2]]
    ];

(* ::Input::Initialization:: *)

RemoveFromExtraVars[obj_] :=
    Module[{extraVars, postExtraVars},
        extraVars = FormTracer`GetExtraVars[];
        postExtraVars =
            If[MemberQ[extraVars, obj],
                DeleteCases[extraVars, obj]
                ,
                extraVars
            ];
        If[extraVars =!= postExtraVars,
            FormTracer`DefineExtraVars[postExtraVars];
            Print["Error: Momentum \"" <> ToString[obj] <> "\" had been defined as an extra variable in FormTracer!"];
            Abort[];
        ];
    ];

scallDef = "*** take care to do replacements at all nested levels
#procedure SCALL(F)
#call `F'
argument;
#call `F'
argument;
#call `F'
argument;
#call `F'
argument;
#call `F'
argument;
#call `F'
argument;
#call `F'
argument;
#call `F'
endargument;
argument;
#call `F'
endargument;
endargument;
endargument;
endargument;
endargument;
endargument;
endargument;
#endprocedure
";

(* ::Subsubsection:: *)

(*Finite T Projections*)

(* ::Input::Initialization:: *)

FiniteTFormMomentumExpansion[momenta___] :=
    Module[{Defs, code},
        RemoveFromExtraVars /@ {momenta};
        code = StringTemplate["
Vector `mom`;
AutoDeclare CFunction cos;
Set momFT : `mom`;
"][<|"mom" -> StringRiffle[{momenta}, ","]|>];
        (*The actual procedure can be then appended*)
        code = code ~~ "*** expand scalar products
#procedure ExpandFiniteT()
id FTxsp(p1?momFT,p2?momFT) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?momFT,p2?momFT)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
#endprocedure

#call SCALL(ExpandFiniteT)
.sort";
        Return[{code}];
    ];

(* ::Input::Initialization:: *)

MakeP0FormRule[{momenta__}, {projections__}] :=
    Module[{momentaList, projectionsList, code},
        RemoveFromExtraVars /@ {momenta};
        momentaList = {momenta};
        projectionsList = {projections};
        projectionsList = Map[ToString[CForm[# /. Complex[re_, im_] :> re + FTxI im /. Thread[FormTracer`GetExtraVarsSynonyms[][[All, 1]] -> FormTracer`GetExtraVarsSynonyms[][[All, 2]]]]]&, projectionsList];
        code = TemplateApply["Vectors `mom`;\nSet momP0: `mom`;\n\n", <|"mom" -> StringRiffle[momentaList, ","]|>];
        code = code ~~ "
*** Expand out all involved momenta
#procedure ExpandP0()
id FTxsp(p1?momP0,p2?momP0) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?momP0,p2?momP0)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;

id FTxsp(p1?momP0,p2?) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?momP0,p2?)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;

id FTxsp(p1?,p2?momP0) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?,p2?momP0)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
#endprocedure";
        code = code ~~ "
*** Project the zeroth components of the given vectors
#procedure ProjP0\n" ~~ (Table[TemplateApply["id FTxvec(`mom`, 0) = `proj`;
id `mom`(0) = `proj`;
id FTxvec(`mom`, 0)^-1 = (`proj`)^-1;
id `mom`(0)^-1 = (`proj`)^-1;", <|"mom" -> momentaList[[i]], "proj" -> projectionsList[[i]]|>], {i, 1, Length[momentaList]}] // StringRiffle[#, "\n"]&) ~~ "\n#endprocedure\n";
        code = code ~~ "
#call SCALL(ExpandP0)
#call SCALL(ProjP0)
.sort";
        Return[{code}];
    ];

MakeP0Rule[{momenta__}, {projections__}] :=
    Thread[Map[Global`vec[#, 0]&, {momenta}] -> {projections}];

(* ::Subsubsection:: *)

(*Symmetric point projections*)

(* ::Input::Initialization:: *)

MakeSPFormRule[{loopMomenta__}, p_, {momenta__}] :=
    Module[{momentaList, loopMomentaList, Defs, nPt, nLoops, nPtId, nPtCrossId, nPtqId, SPFormRule, repRules, depth = 8, i, j},
        RemoveFromExtraVars /@ {momenta};
        momentaList = {momenta};
        loopMomentaList = {loopMomenta};
        nPt = Length[momentaList];
        (*Definitions need to be customized with the input*)
        SPFormRule = StringTemplate["Vector `exMom`, `loopMom` ,`p`;
Symbol n;
AutoDeclare CFunction cos;
Set exMom : `exMom`;
Set loopMom : `loopMom`;

#define SPOrd \"`order`\"
"][<|"exMom" -> StringRiffle[momentaList, ","], "loopMom" -> StringRiffle[loopMomentaList, ","], "p" -> ToString[p], "order" -> ToString[nPt]|>];
        (*The actual procedure can be then appended*)
        SPFormRule = SPFormRule ~~ "
*** project to the SP
#procedure ProjSP()
id FTxsp(p1?exMom,p1?exMom)^-1 = FTxsp(p,p)^-1;
id FTxsp(p1?exMom,p1?exMom) = FTxsp(p,p);
id FTxsp(p1?exMom,p2?exMom)^-1 = (-FTxsp(p,p)/(`SPOrd'-1))^-1;
id FTxsp(p1?exMom,p2?exMom) = -FTxsp(p,p)/(`SPOrd'-1);

id FTxsp(p1?exMom,l1?loopMom)^-1 = (sqrt(FTxsp(p,p))*sqrt(FTxsp(l1,l1))*cos(p1,l1))^-1;
id FTxsp(p1?exMom,l1?loopMom) = (sqrt(FTxsp(p,p))*sqrt(FTxsp(l1,l1))*cos(p1,l1));
#endprocedure

#call SCALL(ProjSP)
.sort";
        Return[{SPFormRule}];
    ];

MakeSPFiniteTFormRule[{loopMomenta__}, p_, {momenta__}] :=
    Module[{momentaList, loopMomentaList, Defs, nPt, nLoops, nPtId, nPtCrossId, nPtqId, SPFormRule, repRules, depth = 8, i, j},
        RemoveFromExtraVars /@ {momenta};
        momentaList = {momenta};
        loopMomentaList = {loopMomenta};
        nPt = Length[momentaList];
        (*Definitions need to be customized with the input*)
        SPFormRule = StringTemplate["Vector `exMom`, `loopMom` ,`p`;
Symbol n;
AutoDeclare CFunction cos;
Set exMom : `exMom`;
Set loopMom : `loopMom`;

#define SPOrd \"`order`\"
"][<|"exMom" -> StringRiffle[momentaList, ","], "loopMom" -> StringRiffle[loopMomentaList, ","], "p" -> ToString[p], "order" -> ToString[nPt]|>];
        (*The actual procedure can be then appended*)
        SPFormRule = SPFormRule ~~ "

*** expand scalar products
#procedure ExpandSPFiniteT()
id FTxsp(p1?exMom,p2?exMom) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?exMom,p2?loopMom) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?loopMom,p2?exMom) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);
id FTxsp(p1?loopMom,p2?loopMom) = FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0);

id FTxsp(p1?exMom,p2?exMom)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
id FTxsp(p1?exMom,p2?loopMom)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
id FTxsp(p1?loopMom,p2?exMom)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
id FTxsp(p1?loopMom,p2?loopMom)^-1 = (FTxsps(p1,p2) + FTxvec(p1,0)*FTxvec(p2,0))^-1;
#endprocedure

*** project to the SP
#procedure ProjSPFiniteT()
id FTxsps(p1?exMom,p1?exMom)^-1 = FTxsps(p,p)^-1;
id FTxsps(p1?exMom,p1?exMom) = FTxsps(p,p);                                                                    
                                                                 
id FTxsps(p1?exMom,p2?exMom)^-1 = (-FTxsps(p,p)/(`SPOrd'-1))^-1;                                                      
id FTxsps(p1?exMom,p2?exMom) = -FTxsps(p,p)/(`SPOrd'-1);

id FTxsps(p1?exMom,l1?loopMom)^-1 = (sqrt(FTxsps(p,p))*sqrt(FTxsps(l1,l1))*cos(p1,l1))^-1;                      
id FTxsps(p1?exMom,l1?loopMom) = (sqrt(FTxsps(p,p))*sqrt(FTxsps(l1,l1))*cos(p1,l1));
#endprocedure

#call SCALL(ExpandSPFiniteT)
#call SCALL(ProjSPFiniteT)
.sort";
        Return[{SPFormRule}];
    ];

(* ::Subsection::Closed:: *)

(*Tools*)

(* ::Input::Initialization:: *)

SafeReplaceTrace[expr_] :=
    Module[{allDressings, rule, reverse},
        allDressings = Cases[expr, dressing[__] | _Real, Infinity] // DeleteDuplicates;
        rule = Map[# -> Unique["dressing"]&, allDressings];
        reverse = Map[Values[#] -> Keys[#]&, rule];
        FormTracer`DefineFormAutoDeclareFunctions @@ (FormTracer`Private`formCFunctionAutoDeclareList \[Union] {SymbolName @ dressing});
        Return[{rule, reverse}];
    ];

(* ::Input::Initialization:: *)

Protect @ $dummy;

customExclusions[a_] :=
    And @@ {a =!= List, a =!= Complex, a =!= Plus, a =!= Power, a =!= Times, a =!= Rational, a =!= Pattern, a =!= $dummy}

removeFORMTracerRule :=
    Map[Head[#][__] :> $dummy[RandomInteger[10^12]]&, Values[FormTracer`Private`lorentzTensorReplacementRulesOutput // Normal]] \[Union] Map[Head[#][__] :> $dummy[RandomInteger[10^12]]&, Values[FormTracer`Private`groupTensorReplacementRulesOutput // Normal]] \[Union] Map[#[__] :> $dummy[RandomInteger[10^12]]&, FormTracer`Private`combinedTensorNames] \[Union] Map[# :> $dummy[RandomInteger[10^12]]&, Global`GetFormTracerGroupConstants[]];

GetAllCustomSymbols[expr_] :=
    Module[{obj},
        obj = DeleteDuplicates @ Cases[expr /. removeFORMTracerRule, (a_Symbol /; customExclusions[a]) | (a_Symbol[__] /; customExclusions[a]), Infinity];
        obj = DeleteDuplicates @ ((# /. a_[__] :> a)& /@ obj);
        Return[obj];
    ];

GetAllMomenta[expr_] :=
    Module[{obj},
        obj = DeleteDuplicates @ Cases[expr, sp[__] | sps[__] | vec[__] | vecs[__], Infinity];
        obj = obj /. {sp[a_, b_] :> {a, b}, sps[a_, b_] :> {a, b}, vecs[a_, _] :> {a}, vec[a_, _] :> {a}} // Flatten;
        obj // DeleteDuplicates
    ];

(* ::Input::Initialization:: *)

ClearAll[balancedBracesQ]

balancedBracesQ[str_String] :=
    Module[{cases, idx},
        If[Not @ (StringCount[str, "("] === StringCount[str, ")"]),
            Return[False]
        ];
        cases = StringCases[str, "(" | ")"];
        For[idx = 1, idx <= Length[cases], idx++,
            If[(Count[cases[[ ;; idx]], "("] < Count[cases[[ ;; idx]], ")"]),
                Return[False]
            ];
        ];
        Return[True];
    ];

balancedBracketsQ[str_String] :=
    Module[{cases, idx},
        If[Not @ (StringCount[str, "["] === StringCount[str, "]"]),
            Return[False]
        ];
        cases = StringCases[str, "[" | "]"];
        For[idx = 1, idx <= Length[cases], idx++,
            If[(Count[cases[[ ;; idx]], "["] < Count[cases[[ ;; idx]], "]"]),
                Return[False]
            ];
        ];
        Return[True];
    ];

hasFortranOperator[a_] :=
    StringContainsQ[a, "*"] || StringContainsQ[a, "/"] || StringContainsQ[a, "+"] || StringContainsQ[a, "-"] || StringContainsQ[a, "**"] || StringContainsQ[a, "^"] || StringContainsQ[a, "="] || StringContainsQ[a, "("] || StringContainsQ[a, ")"] || StringContainsQ[a, " "];

fortranToMathematica[expr_String] :=
    Module[{start, res, pres},
        start = StringPosition[expr, "\n"];
        start =
            If[Length[start] <= 1,
                1
                ,
                start[[2, 1]]
            ];
        res = StringTake[expr, {start, -1}];
        While[
            pres =!= res
            ,
            pres = res;
            res = StringReplace[res, {Shortest[(a_ /; Not @ hasFortranOperator[a]) ~~ "(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> a ~~ "[" ~~ arg1 ~~ "]", Shortest["pow(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "Power[" ~~ arg1 ~~ "]", Shortest["sqrt(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "Sqrt[" ~~ arg1 ~~ "]", Shortest["FTxsp(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "sp[" ~~ arg1 ~~ "]", Shortest["FTxsps(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "sps[" ~~ arg1 ~~ "]", Shortest["FTxvec(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "vec[" ~~ arg1 ~~ "]", Shortest["FTxvecs(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "vecs[" ~~ arg1 ~~ "]", Shortest["FTxvecs(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "vecs[" ~~ arg1 ~~ "]", Shortest["w(" ~~ (arg1__ /; balancedBracesQ[arg1]) ~~ ")"] :> "$w$[" ~~ arg1 ~~ "]", "**" -> "^", " " -> "", "&\n&" -> " ", "i_" -> "\!\(\*TagBox[
StyleBox[
RowBox[{\"Complex\", \"[\", 
RowBox[{\"0\", \",\", \"1\"}], \"]\"}],\nShowSpecialCharacters->False,\nShowStringCharacters->True,\nNumberMarks->True],
FullForm]\)", "expr=" ~~ a__ :> a}];
            res = StringReplace[res, Map[ToString[#[[2]]] -> ToString[#[[1]]]&, FormTracer`GetExtraVarsSynonyms[]]];
        ];
        StringReplace[res, ";" -> "\n"]
    ];

ImportAndSimplifyFORM[file_, transf_ : (#&), mSimplify_ : (Simplify[#, Trig -> False, TimeConstraint -> 0.05]&)] :=
    Module[{fortran, math, splitmath, getAffectedVar, tempExpr, evalExpr, strExpr, expr, i, monitor},
        fortran = Import[file, "Text"];
        math = fortranToMathematica[fortran];
        splitmath = StringSplit[math, "\n"];
        getAffectedVar[line_String] :=
            Module[{pos, str},
                pos = StringPosition[line, Shortest["w[" ~~ (arg1__ /; balancedBracketsQ[arg1]) ~~ "]"]];
                str = StringTake[line, pos][[1]];
                Return[str];
            ];
        tempExpr = Select[splitmath, (StringLength[#] > 0 && StringTake[#, {1}] === "w")&];
        evalExpr = splitmath[[-1]];
        If[$FrontEnd === Null,
            Do[
                strExpr = getAffectedVar[tempExpr[[i]]];
                expr = strExpr ~~ "=" ~~ ToString[mSimplify] ~~ "[" ~~ ToString[transf] ~~ "[" ~~ strExpr ~~ "]]";
                ToExpression[tempExpr[[i]]];
                ToExpression[expr];
                ,
                {i, 1, Length[tempExpr]}
            ];
            ,
            ResourceFunction["MonitorProgress"][
                Do[
                    strExpr = getAffectedVar[tempExpr[[i]]];
                    expr = strExpr ~~ "=" ~~ ToString[mSimplify] ~~ "[" ~~ ToString[transf] ~~ "[" ~~ strExpr ~~ "]]";
                    ToExpression[tempExpr[[i]]];
                    ToExpression[expr];
                    ,
                    {i, 1, Length[tempExpr]}
                ]
            ];
        ];
        Return[ToExpression[evalExpr]];
    ];

(* ::Input::Initialization:: *)

NormalizeIndices[expr_FTerm] :=
    Module[{cindices, orderingFunction},
        cindices = FormTracer`GetClosedIndices[expr];
        orderingFunction[e1_, e2_] :=
            Module[{p1, p2, idx},
                p1 = FirstPosition[expr, e1];
                p2 = FirstPosition[expr, e2];
                For[idx = 1, idx <= Min[Length[p1], Length[p2]], idx++,
                    If[p1[[idx]] < p2[[idx]],
                        Return[True]
                    ];
                    If[p1[[idx]] > p2[[idx]],
                        Return[False]
                    ];
                ];
                Return[False];
            ];
        cindices = Sort[cindices, orderingFunction];
        expr /. Thread[cindices -> Table[Symbol["nIdx" <> ToString[idx]], {idx, 1, Length[cindices]}]]
    ];

NormalizeIndices[ex_List] :=
    Map[NormalizeIndices, ex];

NormalizeIndices[ex_FEx] :=
    Map[NormalizeIndices, ex];

NormalizeIndices[ex_] :=
    ex;

makeHashFile[expr_, subdir_:""] :=
    $TraceCacheDir <> subdir <> ToString @ Hash[NormalizeIndices @ expr, "SHA256"] <> ".m"

(* ::Subsection:: *)

(*Tracing*)

(* ::Input::Initialization:: *)

CreateFormSet[] :=
    Module[{session},
        If[FileExistsQ[Directory[] <> "/form.set"],
            Return[]
        ];
        session = StartExternalSession[{"Python", "Evaluator" -> <|"Dependencies" -> {"formtools-formset"}, "EnvironmentName" -> "FunKit"|>}];
        ExternalEvaluate[session, {"import formset", "formset.main(['-o','" <> Directory[] <> "/form.set" <> "','-p','100'])"}];
        DeleteObject[session];
    ];

(* ::Input::Initialization:: *)

Unprotect[FEx, FTerm, FormTracer`FormTrace];

FEx /: FormTracer`FormTrace[name_String, FEx[a__], preReplRules_ : {}, postReplRules_ : {}, bracket_ : {}] :=
    Module[{idx},
        CreateFormSet[];
        ParallelTable[FormTracer`FormTrace[$TraceCacheDir <> name <> "/" <> ToString[idx] <> ".m", {a}[[idx]], preReplRules, postReplRules, bracket], {idx, 1, Length[{a}]}]
    ];

FEx /: FormTracer`FormTrace[FEx[a__], preReplRules_ : {}, postReplRules_ : {}, bracket_ : {}] :=
    Module[{},
        CreateFormSet[];
        ParallelMap[FormTracer`FormTrace[makeHashFile[{#, preReplRules, postReplRules, bracket}], #, preReplRules, postReplRules, bracket]&, {a}]
    ];

FTerm /: FormTracer`FormTrace[file_String, FTerm[a__], preReplRules_ : {}, postReplRules_ : {}, bracket_ : {}] :=
    Module[{expr, origVars, tmpfileName, import, repl, formReps, result},
        If[FileExistsQ[file],
            FunKitDebug[1, "Result already exists, importing from file\n  " <> file];
            result = Import[file];
            Return[result]
        ];
        result = FormTracer`FormTrace[FTerm[a], preReplRules, postReplRules, bracket];
        Export[file, result];
        Return[result];
    ];

$AlwaysExpandLorentzTensors = True;

SetAlwaysExpandLorentzTensors[set_] /; BooleanQ[set] :=
    Module[{},
        $AlwaysExpandLorentzTensors = set;
    ];

FTerm /: FormTracer`FormTrace[FTerm[a__], preReplRules_ : {}, postReplRules_ : {}, bracket_ : {}] :=
    Module[{expr, origVars, tmpfileName, import, repl, formReps, result, pref},
        origVars = FormTracer`GetExtraVars[];
        If[NumericQ[{a}[[1]]],
            expr = Times @@ ({a}[[2 ;; ]]) // Rationalize;
            pref = {a}[[1]]
            ,
            expr = Times[a] // Rationalize;
            pref = 1
        ];
        If[$AlwaysExpandLorentzTensors,
            expr =
                expr //
                Global`TBInsertCombinedLorentzTensors //
                Global`UseLorentzLinearity;
        ];
        Block[{Print},
            FormTracer`DisentangleLorentzStructures[True]
        ];
        repl = SafeReplaceTrace[expr];
        tmpfileName = "/tmp/FS_" <> makeTemporaryFileName[];
        FormTracer`AddExtraVars @@ GetAllCustomSymbols[expr /. repl[[1]]];
        formReps = Map[#[[2]] -> #[[1]]&, FormTracer`GetExtraVarsSynonyms[]];
        FunKitDebug[2, "Custom symbols in expression: ", GetAllCustomSymbols[expr /. repl[[1]]]];
        FormTracer`FormTrace[expr /. repl[[1]], Join[{scallDef}, preReplRules], postReplRules, {tmpfileName, "O1", "fortran90"}, bracket];
        FormTracer`DefineExtraVars[origVars];
        FunKitDebug[2, "FORM finished, reimporting to Mathematica."];
        result = ImportAndSimplifyFORM[tmpfileName];
        FunKitDebug[2, "Import finished."];
        RunProcess[$SystemShell, All, "rm " <> tmpfileName];
        Return[pref * result /. repl[[2]] /. formReps // Rationalize];
    ];

Protect[FEx, FTerm, FormTrace];

(* ::Subsection::Closed:: *)

(*Summing diagrams*)

(* ::Input::Initialization:: *)

$StandardQuickSimplify = Quiet @ Simplify[#, TimeConstraint -> 0.1]&;

$StandardSimplify = Simplify[#]&;

(* ::Input::Initialization:: *)

IterativelySum[expr_List] :=
    Module[{returnValue},
        returnValue = expr;
        If[Length[returnValue] == 1,
            Return[returnValue]
        ];
        While[Length[returnValue] > 1, returnValue = ParallelMap[$StandardQuickSimplify @ FORMSimplify[Total[#]]&, Partition[returnValue, UpTo[4]]]];
        Return[$StandardQuickSimplify[returnValue[[1]]]];
    ]

(* ::Input::Initialization:: *)

IterativelySum[expr_List, finalSize_Integer /; finalSize >= 0] :=
    Module[{processLists, returnValue, i},
        If[finalSize == 0,
            Return[IterativelySum[expr][[1]]];
        ];
        processLists = expr;
        If[Length[processLists] == finalSize,
            Return[processLists]
        ];
        processLists = Sort[processLists, (ByteCount[#1] > ByteCount[#2])&];
        processLists = Table[Downsample[processLists, finalSize, i], {i, 1, finalSize}];
        returnValue = Map[IterativelySum[#]&, processLists];
        Return[Flatten[returnValue]]
    ];

(* ::Subsection:: *)

(*Simplification*)

findCouplings[expr_] :=
    Module[{symbols},
        FunKitDebug[2, "findCouplings: looking for custom symbols."];
        symbols = GetAllCustomSymbols[expr];
        symbols = Pick[symbols, Map[MemberQ[{expr}, #[__], Infinity]&, symbols]];
        symbols = DeleteDuplicates @ Cases[expr, Alternatives @@ Map[#[__]&, symbols], Infinity];
        FunKitDebug[2, "findCouplings: found: ", symbols];
        symbols = Pick[symbols, Not /@ Map[MemberQ[{expr}, Power[a_, n_] /; (MemberQ[{a}, #, Infinity] && n < 0), Infinity]&, symbols]];
        FunKitDebug[2, "findCouplings: picked: ", symbols];
        Return @ symbols
    ];

DiagramSimplify[expr_, mSimplify_ : (Quiet @ Simplify[Simplify[#, Trig -> False, TimeConstraint -> 0.01], Trig -> False, TimeConstraint -> 0.1]&)] :=
    Module[{collected, couplings},
        couplings = findCouplings[expr];
        FunKitDebug[2, "DiagramSimplify: Found the following couplings in the given expression: ", couplings];
        collected = Collect[expr, Map[#[__]&, couplings]];
        If[Head[collected] === Plus,
            collected = List @@ collected
            ,
            collected = {collected}
        ];
        If[Length[collected] > 1,
            collected = ParallelMap[mSimplify, collected]
            ,
            collected = mSimplify[collected]
        ];
        FunKitDebug[2, "DiagramSimplify: Finished"];
        Return[Plus @@ collected]
    ];

$standardFORMmomentumRules = {}; FormMomentumExpansion[];

ClearAll[FORMSimplify]

FORMSimplify[obj_, preReplRules_ : {}, postReplRules_ : {}, bracket_ : {}] :=
    Module[{file, origVars, tmpfileName, import, repl, expr, newSymbols, momenta, momRule, ret},
        file = makeHashFile[{obj, preReplRules, postReplRules, bracket}];
        If[FileExistsQ[file],
            ret = Import[file];
            Return[ret]
        ];
        expr = obj // Rationalize;
        origVars = FormTracer`GetExtraVars[];
        repl = SafeReplaceTrace[expr];
        momenta = expr // GetAllMomenta;
        newSymbols = GetAllCustomSymbols[expr /. repl[[1]]];
        newSymbols = Select[newSymbols, FreeQ[momenta, #]&];
        momRule =
            If[Length @ momenta > 0,
                {{FormTracer`PreambleFormRule, "Vector " <> StringRiffle[momenta, ","] <> ";"}}
                ,
                {}
            ];
        FunKitDebug[3, "FORMSimplify: Adding Extra Vars ", newSymbols];
        FormTracer`AddExtraVars @@ newSymbols;
        tmpfileName = "/tmp/FS_" <> makeTemporaryFileName[];
        FormTracer`FormTrace[Rationalize[expr /. repl[[1]]], Join[{scallDef}, momRule, preReplRules], postReplRules, {tmpfileName, "O4,saIter=10000,saMinT=10,saMaxT=10000", "fortran90"}, bracket];
        ret = ImportAndSimplifyFORM[tmpfileName];
        FunKitDebug[2, "FORMSimplify: FORM finished"];
        FormTracer`DefineExtraVars[origVars];
        RunProcess[$SystemShell, All, "rm " <> tmpfileName];
        ret = (ret) /. repl[[2]] // Rationalize;
        Export[file, ret];
        Return[ret];
    ];

(* ::Section::Closed:: *)

(*End Private*)

End[]
