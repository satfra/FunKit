(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetLoopMomentumName::usage="";

MakeDiagrammaticRules::usage="";

SetSymmetricDressing::usage="";

dressing::usage="";


Begin["`Private`"]


(* ::Input::Initialization:: *)
MakeDiagrammaticRules[]/;Head[$GlobalSetup]=!=Symbol:=MakeDiagrammaticRules[$GlobalSetup];


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"DiRK","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"DiRK","FEDeriK"];
Abort[];
];

ModuleLoaded[DiRK]=True;


(* ::Input::Initialization:: *)
makeTemporaryFileName[]:=ToString[AbsoluteTime[]*10^6//Round]<>"_"<>ToString[RandomInteger[{10^6,10^7}]]


(* ::Input::Initialization:: *)
Unprotect@dressing;
ClearAll[dressing];
Protect@dressing;

Options[MakeDiagrammaticRules]={"DerivePropagators"->True};

MakeDiagrammaticRules[setup_,OptionsPattern[]]:=Module[
{ruleList,truncationList,idx,jdx,kdx,minusRule,
object,fieldContent,rule,dress,minusOrig,minusBasis,subset=All,orderOrig,orderBasis
},
ruleList={};
truncationList=setup["FeynmanRules"];
For[idx=1,idx<=Length[truncationList], idx++,
object=truncationList[[idx,1]];
For[jdx=1,jdx<=Length[truncationList[[idx,2]]],jdx++,
rule=Values[truncationList[[idx,2,jdx]]];
If[Head[rule]===List,
subset=If[Head[rule[[2]]]===List,rule[[2]],{rule[[2]]}];
rule=rule[[1]],
subset=Range[TensorBases`TBGetBasisSize[makePosIdx[rule]]];
];
minusRule=If[isNeg[rule],-1,1];
rule*=minusRule;

{minusOrig,orderOrig}=GetOrder[setup,Keys@truncationList[[idx,2,jdx]],If[object===Propagator,True,False]];
fieldContent=(Keys@truncationList[[idx,2,jdx]])[[orderOrig]];
{minusBasis,orderBasis}=GetOrder[setup,fieldContent,TensorBases`TBGetBasisFields[rule]];

dress=If[OptionValue["DerivePropagators"]&&object===Propagator,
((CommuteSign[setup,##]&@@fieldContent)*TensorBases`TBMakePropagator[rule,Table[dressing[GammaN,Reverse@fieldContent,subset[[kdx]],$mom],{kdx,1,Length[subset]}]]),
(Table[dressing[object,fieldContent,subset[[kdx]],$mom],{kdx,1,Length[subset]}])
];
rule=minusOrig*minusRule*minusBasis*dress . (Table[$tens[rule,subset[[kdx]],$ind],{kdx,1,Length[subset]}]);

AppendTo[ruleList,OrderObject[setup,object[fieldContent,ind:(_List)]]:>(Evaluate@rule)/.$tens->TensorBases`TBGetVertex/.$mom:>ind$[[All,1]]/.$ind:>Flatten/@ind$[[$order]]/.$order->(Evaluate@orderBasis)]
];
];
Return[ruleList];
];


(* ::Input::Initialization:: *)
SetSymmetricDressing[obj_,{f__}]:=Module[{},
Unprotect[dressing];
dressing[obj,{f},n_,{any__}]/;Not@OrderedQ[{any}]:=dressing[obj,{f},n,Sort@{any}];
Protect[dressing];
]
SetSymmetricDressing[obj_,{f__},n_Integer]:=Module[{},
Unprotect[dressing];
dressing[obj,{f},n,{any__}]/;Not@OrderedQ[{any}]:=dressing[obj,{f},n,Sort@{any}];
Protect[dressing];
]


End[]



