(* ::Package:: *)

(* ::Input:: *)

(*SetOptions[EvaluationNotebook[],AutoGeneratedPackage->"DiRK.m"]*)

(* ::Title:: *)

(*DiRK -  Diagrammatic Rule Kit*)

(* ::Section:: *)

(*Exports*)

(* ::Input::Initialization:: *)

SetLoopMomentumName::usage = "SetLoopMomentumName[name]
Sets the base name for loop momentum variables in diagrammatic rules.
This affects momentum naming conventions when generating diagrammatic representations.
The name should be a string that will be used as the base for momentum variables in rules.";

MakeDiagrammaticRules::usage = "MakeDiagrammaticRules[setup]
Generates replacement rules that convert functional expressions into diagrammatic form.
Creates rules for propagators, vertices, and other diagrammatic elements based on the setup.
Returns a list of transformation rules suitable for use with ReplaceAll (/.).
Essential for converting abstract functional expressions into concrete diagrammatic representations.
Used in conjunction with TensorBases for generating basis-specific rules.";

SetSymmetricDressing::usage = "SetSymmetricDressing[object, fields]
SetSymmetricDressing[object, fields, indices] 
Defines symmetry properties for diagrammatic dressing of objects.
Automatically orders field arguments according to specified symmetries.
The first form symmetrizes over all field arguments.
The second form allows specifying which indices should be symmetrized.
Essential for handling symmetric tensors and avoiding redundant diagrammatic terms.";

dressing::usage = "dressing[object, fields, momentum, arguments]
Represents the diagrammatic dressing of objects with specific field content.
Used internally by the diagrammatic rule generation system.
The object specifies the type (e.g., InverseProp), fields list the field types.
Momentum and arguments specify the kinematic and tensor structure.
Automatically handles symmetrization when SetSymmetricDressing rules are active.";

InverseProp::usage = "InverseProp[fields, momentum, arguments]
Represents inverse propagator elements in diagrammatic expressions.
Used as a basis element for constructing propagator-based diagrammatic rules.
The fields specify the field types connected by the inverse propagator.
Momentum and arguments determine the kinematic and tensor structure.
Typically appears in dressing expressions for propagator construction.";

(* ::Section::Closed:: *)

(*Begin Private*)

Begin["`Private`"]

(* ::Section:: *)

(*Global setup redefinitions*)

(* ::Input::Initialization:: *)

MakeDiagrammaticRules[] /; Head[$GlobalSetup] =!= Symbol :=
    MakeDiagrammaticRules[$GlobalSetup];

(* ::Section::Closed:: *)

(*Global variables*)

(* ::Input::Initialization:: *)

ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "DiRK", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "DiRK", "FEDeriK"];
    Abort[];
];

ModuleLoaded[DiRK] = True;

(* ::Input::Initialization:: *)

makeTemporaryFileName[] :=
    ToString[AbsoluteTime[] * 10^6 // Round] <> "_" <> ToString[RandomInteger[
        {10^6, 10^7}]]

(* ::Section:: *)

(*Making diagrammatic rules*)

(* ::Input::Initialization:: *)

Unprotect @ dressing;

ClearAll[dressing];

Protect @ dressing;

Options[MakeDiagrammaticRules] = {"DerivePropagators" -> True};

Protect @ InverseProp;

MakeDiagrammaticRules[setup_, OptionsPattern[]] :=
    Module[{ruleList, truncationList, idx, jdx, kdx, minusRule, object,
         fieldContent, rule, dress, minusOrig, minusBasis, subset = All, orderOrig,
         orderBasis, newBasisName},
        ruleList = {};
        truncationList = Normal[setup["FeynmanRules"]];
        For[idx = 1, idx <= Length[truncationList], idx++,
            object = truncationList[[idx, 1]];
            FunKitDebug[1, "Creating diagrammatic rule for ", object]
                ;
            For[jdx = 1, jdx <= Length[truncationList[[idx, 2]]], jdx
                ++,
                rule = Values[truncationList[[idx, 2, jdx]]];
                FunKitDebug[1, "  Creating diagrammatic rule for ", rule
                    ];
                (*Check what the subset of the original basis is*)
                If[Head[rule] === List,
                    subset =
                        If[Head[rule[[2]]] === List,
                            rule[[2]]
                            ,
                            {rule[[2]]}
                        ];
                    rule = rule[[1]]
                    ,
                    subset = Range[TensorBases`TBGetBasisSize[makePosIdx[
                        rule]]];
                ];
                minusRule =
                    If[isNeg[rule],
                        -1
                        ,
                        1
                    ];
                rule *= minusRule;
                {minusOrig, orderOrig} =
                    GetOrder[
                        setup
                        ,
                        Keys @ truncationList[[idx, 2, jdx]]
                        ,
                        If[object === Propagator,
                            True
                            ,
                            False
                        ]
                    ];
                fieldContent = (Keys @ truncationList[[idx, 2, jdx]])
                    [[orderOrig]];
                {minusBasis, orderBasis} = GetOrder[setup, fieldContent,
                     TensorBases`TBGetBasisFields[rule]];
                dress =
                    If[OptionValue["DerivePropagators"] && object ===
                         Propagator,
                        FunKitDebug[2, "    Creating propagator rule"
                            ];
                        newBasisName = rule <> "_restrict_" <> StringReplace[
                            ToString[subset], {" " -> "", "," -> "_", "{" -> "", "}" -> ""}];
                        FunKitDebug[2, "      Creating restricted basis for propagator inversion ",
                             newBasisName];
                        If[Not @ TensorBases`TBBasisExists[newBasisName
                            ],
                            TensorBases`TBRestrictBasis[rule, newBasisName,
                                 subset]
                        ];
                        orderBasis = Reverse @ orderBasis;
                        ((CommuteSign[setup, ##]& @@ fieldContent) * 
                            TensorBases`TBMakePropagator[newBasisName, Table[dressing[InverseProp,
                             Reverse @ fieldContent, subset[[kdx]], $mom], {kdx, 1, Length[subset
                            ]}]])
                        ,
                        FunKitDebug[2, "Creating nPoint rule"];
                        (Table[dressing[object, fieldContent, subset[[
                            kdx]], $mom], {kdx, 1, Length[subset]}])
                    ];
                rule = minusOrig * minusRule * minusBasis * dress . (
                    Table[$tens[rule, subset[[kdx]], $ind], {kdx, 1, Length[subset]}]);
                AppendTo[ruleList, OrderObject[setup, object[fieldContent,
                     ind : (_List)]] :> (Evaluate @ rule) /. $tens -> TensorBases`TBGetVertex
                     /. $mom :> ind$[[All, 1]] /. $ind :> Flatten /@ ind$[[$order]] /. $order
                     -> (Evaluate @ orderBasis)]
            ];
        ];
        Return[ruleList];
    ];

(* ::Input::Initialization:: *)

SetSymmetricDressing[obj_, {f__}] :=
    Module[{},
        Unprotect[dressing];
        dressing[obj, {f}, n_, {any__}] /; Not @ OrderedQ[{any}] := dressing[
            obj, {f}, n, Sort @ {any}];
        Protect[dressing];
    ];

SetSymmetricDressing[obj_, {f__}, {i__Integer}] :=
    Module[{},
        Unprotect[dressing];
        dressing[obj, {f}, n_, {any__}] /; Not @ OrderedQ[{any}[[{i}]]
            ] :=
            Module[{new = {any}},
                new[[{i}]] = Sort @ new[[{i}]];
                dressing[obj, {f}, n, new]
            ];
        Protect[dressing];
    ];

SetSymmetricDressing[obj_, {f__}, n_Integer] :=
    Module[{},
        Unprotect[dressing];
        dressing[obj, {f}, n, {any__}] /; Not @ OrderedQ[{any}] := dressing[
            obj, {f}, n, Sort @ {any}];
        Protect[dressing];
    ];

SetSymmetricDressing[obj_, {f__}, n_Integer, {i__Integer}] :=
    Module[{},
        Unprotect[dressing];
        dressing[obj, {f}, n, {any__}] /; Not @ OrderedQ[{any}[[{i}]]
            ] :=
            Module[{new = {any}},
                new[[{i}]] = Sort @ new[[{i}]];
                dressing[obj, {f}, n, new]
            ];
        Protect[dressing];
    ];

(* ::Section::Closed:: *)

(*End Private*)

End[]

(* ::Title:: *)

(*Testing*)

(* ::Input:: *)

(*Get["FunKit`"]*)

(*fields= <|*)

(*"cField"-> {*)

(*A[p,{v, c}]*)

(*},*)

(*"Grassmann"->{*)

(*{cb[p,{c}],c[p,{c}]}*)

(*}*)

(*|>;*)

(*truncation=<|*)

(*GammaN->{*)

(*{A,A},{A,A,A},{A,A,A,A},*)

(*{A,cb,c}*)

(*},*)

(*Propagator->{*)

(*{A,A},{cb,c}*)

(*},*)

(*Rdot->{*)

(*{A,A},{cb,c}*)

(*},*)

(*S->{*)

(*{A,A},{A,A,A},{A,A,A,A},*)

(*{cb,c},{cb,c,A}*)

(*}*)

(*|>;*)

(*SetTexStyles[cb->"\\bar{c}"];*)

(*bases={*)

(*GammaN->{*)

(*{A,A}->"AA",{A,A,A}->"AAAClass",{A,A,A,A}->"AAAAClass",*)

(*{A,cb,c}->{"Acbc",1}*)

(*},*)

(*Propagator->{*)

(*{A,A}->"AA",{cb,c}->"cbc"*)

(*},*)

(*Rdot->{*)

(*{A,A}->"AA",{cb,c}->"cbc"*)

(*}*)

(*};*)

(*Setup:=<|*)

(*"FieldSpace"->fields,*)

(*"Truncation"->truncation,*)

(*"FeynmanRules"->bases*)

(*|>;*)

(*SetGlobalSetup[Setup];*)

(**)

(*DerivativeListAcbc={ A[i1],cb[i2],c[i3]};*)

(*TakeDerivatives[Setup,WetterichEquation,DerivativeListAcbc];*)

(*%//Truncate//FSimplify;*)

(*%/.MakeDiagrammaticRules[Setup]*)
