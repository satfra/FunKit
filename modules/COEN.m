(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

(* ::Input::Initialization:: *)
SetLoopMomentumName::usage=""

JuliaCode::usage=""

CppCode::usage=""

FORMCode::usage=""

FortranCode::usage=""

MakeCppClass::usage=""

MakeCppHeader::usage=""

MakeCppFunction::usage=""

MakeJuliaFunction::usage=""

MakeFortranFunction::usage=""

DefineCppNames::usage=""

CppForm::usage=""

FormatCode::usage=""


Begin["`Private`"]


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"COEN","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"COEN","FunKit"];
Abort[];
];

ModuleLoaded[COEN]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
makeTemporaryFileName[]:=ToString[AbsoluteTime[]*10^6//Round]<>"_"<>ToString[RandomInteger[{10^6,10^7}]]


(* ::Input::Initialization:: *)
Needs["SymbolicC`"]

$CppPrecision=20;

CppForm[expr_]:=Block[{processedExpr,nest,$MinPrecision=$CppPrecision,$MaxPrecision=$CppPrecision},
processedExpr=N[expr];
nest:=GenerateCode[CExpression[#]]&;

(*associativity*)
CExpression/:GenerateCode[CExpression[Times[a__,Plus[b_,c__],d__]]]:=nest[Times[a]]<>" * ("<>nest[Plus[b,c]]<>") * "<>nest[Times[d]];
CExpression/:GenerateCode[CExpression[Times[Plus[b_,c__],d__]]]:="("<>nest[Plus[b,c]]<>") * "<>nest[Times[d]];

(*recursion for + and * *)
CExpression/:GenerateCode[CExpression[Plus[a_,b__]]]:=nest[a]<>" + "<>nest[Plus[b]];
CExpression/:GenerateCode[CExpression[Times[a_,b__]]]:=nest[a]<>" * "<>nest[Times[b]];
CExpression/:GenerateCode[CExpression[Times[-1,b_,a__]]]/;Head[b]=!=Plus:="(-"<>nest[b]<>")";

CExpression/:GenerateCode[CExpression[Times[a__,Power[b_,-1]]]]:="("<>nest[a]<>") / ("<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[Times[a__,Plus[b_,c__],d__]]]:=nest[Times[a]]<>" * ("<>nest[Plus[b,c]]<>") * "<>nest[Times[d]];
CExpression/:GenerateCode[CExpression[Times[Plus[b_,c__],Power[d_,-1]]]]:="("<>nest[Plus[b,c]]<>") / ("<>nest[d]<>")";
CExpression/:GenerateCode[CExpression[Times[a__,Plus[b_,c__],Power[d_,-1]]]]:=nest[Times[a]]<>" * ("<>nest[Plus[b,c]]<>") / ("<>nest[d]<>")";

(*functions*)
CExpression/:GenerateCode[CExpression[a_[args_]]]:=nest[a]<>"("<>nest[args]<>")";

(*number conversion*)
CExpression/:GenerateCode[CExpression[I]]:="complex<double>(0,1)";
CExpression/:GenerateCode[CExpression[a_Real]]:=ToString[NumberForm[N[a,$CppPrecision],$CppPrecision,NumberFormat->(If[#3==="",#1,Row[{#1,"e",#3}]]&)]];
CExpression/:GenerateCode[CExpression[Rational[a_,b_]]]:=nest[N[a/b,$CppPrecision]];
CExpression/:GenerateCode[CExpression[a_Complex]]:="("<>nest[Re@a]<>" + complex<double>(0,1) * "<>nest[Im@a]<>")";
CExpression/:GenerateCode[CExpression[a_Complex]]/;Re[a]===0:="complex<double>(0,"<>nest[Im[a]]<>")";
CExpression/:GenerateCode[CExpression[a_]]/;NumericQ[a]&&Not@IntegerQ[a]:=nest[N[a,$CppPrecision]];

(*Powers and such*)
CExpression/:GenerateCode[CExpression[Sqrt[arg_]]]:="sqrt("<>nest[arg]<>")";

CExpression/:GenerateCode[CExpression[Power[a_,b_Integer]]]:="powr<"<>ToString[b]<>">("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Power[a_,b_/;Element[b+1/2,Integers]]]]:=If[b===1/2,"sqrt("<>nest[a]<>")","sqrt(powr<"<>nest[2b]<>">("<>nest[a]<>"))"];
CExpression/:GenerateCode[CExpression[Power[a_,b_]]]:="pow("<>nest[a]<>","<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[Power[E,b_]]]:="exp("<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[Power[E,b_Integer]]]:="exp("<>nest[b]<>")";

CExpression/:GenerateCode[CExpression[Exp[a_]]]:="exp("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Exp[a_]-1]]:="expm1("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[1-Exp[a_]]]:="-expm1("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Plus[Exp[a_],-1,c__]]]:="expm1("<>nest[a]<>") + "<>nest[Plus[c]];
CExpression/:GenerateCode[CExpression[Plus[-Exp[a_],1,c__]]]:="(-expm1("<>nest[a]<>")) + "<>nest[Plus[c]];

CExpression/:GenerateCode[CExpression[Log[a_]]]:="log("<>nest[a]<>")";

(*trigonometric*)
CExpression/:GenerateCode[CExpression[Sin[a_]]]:="sin("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Cos[a_]]]:="cos("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Tan[a_]]]:="tan("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Cot[a_]]]:="powr<-1>(tan("<>nest[a]<>"))";

CExpression/:GenerateCode[CExpression[ArcSin[a_]]]:="asin("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcCos[a_]]]:="acos("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcTan[a_]]]:="atan("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcTan[a_,b_]]]:="atan2("<>nest[a]<>", "<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[ArcCot[a_]]]:="atan(powr<-1>("<>nest[a]<>"))";

CExpression/:GenerateCode[CExpression[Sinh[a_]]]:="sinh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Cosh[a_]]]:="cosh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Tanh[a_]]]:="tanh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Coth[a_]]]:="powr<-1>(tanh("<>nest[a]<>"))";

CExpression/:GenerateCode[CExpression[ArcSinh[a_]]]:="asinh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcCosh[a_]]]:="acosh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcTanh[a_]]]:="atanh("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[ArcCoth[a_]]]:="atanh(powr<-1>("<>nest[a]<>"))";

(*min, max, abs*)
CExpression/:GenerateCode[CExpression[Abs[a_]]]:="abs("<>nest[a]<>")";
CExpression/:GenerateCode[CExpression[Min[a_,b_]]]:="min("<>nest[a]<>","<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[Min[a_,b_,c__]]]:="min({"<>nest[a]<>","<>nest[b]<>StringRiffle[Map[nest,{c}],","]"})";
CExpression/:GenerateCode[CExpression[Max[a_,b_]]]:="max("<>nest[a]<>","<>nest[b]<>")";
CExpression/:GenerateCode[CExpression[Max[a_,b_,c__]]]:="max({"<>nest[a]<>","<>nest[b]<>StringRiffle[Map[nest,{c}],","]"})";

ToCCodeString[CExpression[processedExpr]]
];


(* ::Input::Initialization:: *)
haveBashrc=0==RunProcess[$SystemShell,All,"source ~/.bashrc"]["ExitCode"];
haveZshrc=0==RunProcess[$SystemShell,All,"source ~/.zshrc"]["ExitCode"];
haveZshProfile=0==RunProcess[$SystemShell,All,"source ~/.zprofile"]["ExitCode"];
inferredPATH=RunProcess[$SystemShell,All,
If[haveBashrc,"source ~/.bashrc;",""]<>
If[haveZshrc,"source ~/.zshrc;",""]<>
If[haveZshProfile,"source ~/.zprofile;",""]<>
" echo $PATH"]["StandardOutput"];
SetEnvironment["PATH"->inferredPATH];

clangFormatExists=Quiet[RunProcess[{"clang-format","--help"}]]=!=$Failed;
CreateClangFormat[path_:"./"]:=If[Not@FileExistsQ[path<>"/.clang-format"],
Export[path<>"/.clang-format",
"BasedOnStyle: LLVM
UseTab: Never
IndentWidth: 2
TabWidth: 2
BreakBeforeBraces: Linux
AllowShortIfStatementsOnASingleLine: true
IndentCaseLabels: false
ColumnLimit: 120
AccessModifierOffset: -2
NamespaceIndentation: All
AllowShortEnumsOnASingleLine: true
",
"Text"]
];

WriteCodeToFile[fileName_String,expression_String]:=Module[{tmpfileName},
	tmpfileName=fileName<>".tmpcode";
	Export[tmpfileName,expression,"Text"];
	If[clangFormatExists,
		CreateClangFormat[];
		RunProcess[$SystemShell, All, "clang-format "<>tmpfileName<>" > "<>tmpfileName<>"_formatted && mv "<>tmpfileName<>"_formatted "<>tmpfileName];
	];
	If[FileExistsQ[fileName],
		If[Import[fileName,"Text"]==Import[tmpfileName,"Text"],
			Print[fileName<>" unchanged"];
			RunProcess[$SystemShell, All, "rm "<>tmpfileName],
			Print["Exported to "<>fileName];
			RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
		],
		Print["Exported to "<>fileName];
		RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
	]
];

FormatCode[expression_String]:=Module[{tmpfileName1,tmpfileName2,output},
tmpfileName1="/tmp/in_"<>makeTemporaryFileName[];
tmpfileName2="/tmp/out_"<>makeTemporaryFileName[];
Export[tmpfileName1,expression,"Text"];
If[clangFormatExists,
RunProcess[$SystemShell, All, "rm /tmp/.clang-format"];
CreateClangFormat["/tmp/"];
RunProcess[$SystemShell, All, "clang-format "<>tmpfileName1<>" > "<>tmpfileName2];
	];
If[FileExistsQ[tmpfileName2],
output=Import[tmpfileName2,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName1<>" "<>tmpfileName2];
Return[output];
];
Return[expression]
];


(* ::Input::Initialization:: *)
ClearAll[balancedBracesQ]
balancedBracesQ[str_String]:=Module[{cases,idx},
If[Not@(StringCount[str,"("]===StringCount[str,")"]),Return[False]];
cases=StringCases[str,"("|")"];
For[idx=1,idx<=Length[cases],idx++,
If[(Count[cases[[;;idx]],"("]<Count[cases[[;;idx]],")"]),Return[False]];
];
Return[True];
];
balancedRBracesQ[str_String]:=StringCount[str,"["]===StringCount[str,"]"]

hasNoOperators[str_String]:=StringFreeQ[str,")"]&&StringFreeQ[str,"("]&&StringFreeQ[str,"["]&&StringFreeQ[str,"]"]&&
StringFreeQ[str,"*"]&&StringFreeQ[str,"/"]&&
StringFreeQ[str,"+"]&&StringFreeQ[str,"-"]&&
StringFreeQ[str,"%"]&&StringFreeQ[str,"&"]


(* ::Input::Initialization:: *)
formatFORMCode[expr_String]:=Module[
{start,res,pres,idx,maxW,repl},
start=StringPosition[expr,"\n"];
start=If[Length[start]<=1,1,start[[2,1]]];
res=StringTake[expr,{start,-1}];

(*operation replacements*)
While[pres=!=res,
pres=res;
res=StringReplace[res,
{
Shortest["pow("~~(arg1__)~~","~~(arg2:(DigitCharacter...|"-"~~(DigitCharacter...)))~~")"]/;balancedBracesQ[arg1]&&StringFreeQ[arg1,";"]:>"powr<"~~arg2~~">("~~arg1~~")",
Shortest["pow("~~(arg1__)~~","~~"1./2."~~")"]/;balancedBracesQ[arg1]&&StringFreeQ[arg1,";"]:>"sqrt("~~arg1~~")",
" "->""
}
];
];

(*turn the buffer into a list of definitions of variables*)
maxW=Max[Map[ToExpression@StringTake[#,{3,-2}]&,StringCases[res,Shortest["w["~~(arg1__/;balancedRBracesQ[arg1])~~"]"]]]];
For[idx=1,idx<=maxW,idx++,
res=StringReplacePart[res,"auto _tmp"<>ToString[idx]<>"",StringPosition[res,"w["<>ToString[idx]<>"]",1]];
];
res=StringReplace[res,
{
Shortest["w["~~(arg1__/;balancedRBracesQ[arg1])~~"]"]:>"_tmp"~~arg1~~"",
"expr="->"return ",
"\n"->""
}
];
res=FormatCode[res];


(*Get rid of unecessary copies*)
repl=Map[
StringReplace[#,"auto _tmp"~~a__~~" = "~~b__~~";"/;hasNoOperators[b]:>"_tmp"~~a~~"->"~~b]&,
Select[StringSplit[res,"\n"],StringMatchQ[#,"auto _tmp"~~a__~~"="~~b__~~";"/;hasNoOperators[b]]&]
];
repl=Map[
((a_/;MatchQ[a,"("|" "|"-"])~~#[[1]]~~(b_/;MatchQ[b,")"|" "|";"]):>a~~#[[2]]~~b&)@StringSplit[#,"->"]&,
repl
];
res=StringJoin[
Select[StringSplit[res,"\n"],Not@StringMatchQ[#,"auto _tmp"~~a__~~"="~~b__/;hasNoOperators[b]]&]
];
res=StringReplace[res,repl];

Return[res];
];

FORMCode[expr_]:=Module[
{origVars,tmpfileName,import},

origVars=FormTracer`GetExtraVars[];

tmpfileName="/tmp/FO_"<>makeTemporaryFileName[];
FormTracer`AddExtraVars@@GetAllCustomSymbols[expr];
FormTracer`FormTrace[expr//Rationalize,{},{},{tmpfileName,"O4"}];
FormTracer`DefineExtraVars[origVars];
import=Import[tmpfileName,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import//formatFORMCode
];


(* ::Input::Initialization:: *)
$codeOptimizeFunctions={a_Symbol[__]/;Not@MatchQ[a,Times|Plus|Power|Rational|Complex|Real|Integer]};


(* ::Input::Initialization:: *)
CppCode[equation_]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,returnStatement},
optList=$codeOptimizeFunctions;
interpObj=Flatten@Map[Cases[equation,#,Infinity]&,optList];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["_repl"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->replacementNames[[i]],{i,1,Length[replacementObj]}];
definitions=If[Length[replacementObj]>0,
StringJoin[Table["const auto "<>ToString[replacementNames[[i]]]<>" = "<>CppForm[FullSimplify@replacementObj[[i]]]<>";\n",{i,1,Length[replacementObj]}]]<>"\n"
,""];
returnStatement=" return "<>CppForm[equation//.replacements]<>";";
definitions<>returnStatement
];


(* ::Input::Initialization:: *)
makeCppTemplateParameter[n_]:="typename T"<>ToString[n];
makeCppParameter[t_,n_]:=Module[{ret},
ret="const ";
ret=ret<>If[KeyFreeQ[t,"Type"]||t["Type"]==="template",
"T"<>ToString[n],
t["Type"]
];
ret=ret<>If[KeyExistsQ[t,"Reference"]&&t["Reference"],"& "," "];
ret=ret<>t["Name"];
Return[ret];
]


(* ::Input::Initialization:: *)
ClearAll[MakeCppFunction];
Options[MakeCppFunction]={"Return"->"auto","Const"->False,"Parameters"->{},"Name"->"function","Prefix"->"","CodeParser"->"Cpp","Body"->""};
MakeCppFunction[OptionsPattern[]]:=Module[
{functionPrefix,functionSuffix,functionName,
functionParameters,functionTemplates,idx,
functionBody},

(*Create prefixe for the function, e.g. static or such + the return value*)
functionPrefix=OptionValue["Prefix"];
functionPrefix=functionPrefix<>" "<>OptionValue["Return"]<>" ";

functionSuffix="";
If[OptionValue["Const"],functionSuffix=functionSuffix<>" const"];

functionName=OptionValue["Name"];

(*Create both a template list and a parameter list*)
functionTemplates=If[Length[Select[OptionValue["Parameters"],KeyFreeQ[#,"Type"]||#["Type"]==="template"&]]===0,
"",
"template<"<>StringRiffle[
Pick[
Table[makeCppTemplateParameter[idx],{idx,1,Length[OptionValue["Parameters"]]}],
Table[KeyFreeQ[OptionValue["Parameters"][[idx]],"Type"]||OptionValue["Parameters"][[idx]]["Type"]==="template",{idx,1,Length[OptionValue["Parameters"]]}]
],", "]<>">\n"
];
functionParameters="("<>StringRiffle[
Table[makeCppParameter[OptionValue["Parameters"][[idx]],idx],{idx,1,Length[OptionValue["Parameters"]]}]
,", "]<>")";

(*create the body*)
functionBody=StringReplace["{\n"<>OptionValue["Body"]<>"\n}","\n\n"->""];

Return[FormatCode[
functionTemplates<>functionPrefix<>functionName<>functionParameters<>functionSuffix<>"\n"<>functionBody
]
]
];
MakeCppFunction[expr_,OptionsPattern[]]:=Module[{codeParser,newBody},
codeParser=If[OptionValue["CodeParser"]==="FORM",FORMCode,CppCode];
newBody=OptionValue["Body"]<>"\n"<>codeParser[expr];
MakeCppFunction@@(Evaluate@Join[{"Body"->newBody},Thread[Rule@@{#,OptionValue[MakeCppFunction,#]}]&@Keys[Options[MakeCppFunction]]])
];


(* ::Input::Initialization:: *)
Options[MakeCppClass]={"TemplateTypes"->{},"MembersPublic"->{},"MembersPrivate"->{},"MembersProtected"->{},"Name"->"Class","bases"->{}};
MakeCppClass[OptionsPattern[]]:=Module[
{classPrefix,classSuffix,className,
classParameters,classTemplates,codeParser,
classBody},

(*Create prefixe for the class, e.g. static or such + the return value*)
classPrefix=If[Length[OptionValue["TemplateTypes"]]>0,"template<"~~StringRiffle[Map["typename "~~#&,OptionValue["TemplateTypes"]],", "]~~">\n",""];
classPrefix=classPrefix<>"class ";

classSuffix="";

className=OptionValue["Name"];

(*create the body*)
classBody="{\n"<>
If[Length[OptionValue["MembersPublic"]]>0,"public: "<>StringRiffle[OptionValue["MembersPublic"],"\n\n"],""]<>
If[Length[OptionValue["MembersProtected"]]>0,"protected: "<>StringRiffle[OptionValue["MembersProtected"],"\n\n"],""]<>
If[Length[OptionValue["MembersPrivate"]]>0,"private: "<>StringRiffle[OptionValue["MembersPrivate"],"\n\n"],""]<>
"\n};";
StringReplace[classBody,{";;"->";"}];

Return[FormatCode[
classPrefix<>className<>classSuffix<>"\n"<>classBody
]
]
];


(* ::Input::Initialization:: *)
Options[MakeCppHeader]={"Includes"->{},"Body"->{}};
MakeCppHeader[OptionsPattern[]]:=Module[
{headerPrefix,headerIncludes,headerBody},

(*Create prefixe for the header, e.g. static or such + the return value*)
headerPrefix="#pragma once\n";

headerIncludes=StringRiffle[Map["#include \""~~#~~"\""&,OptionValue["Includes"]],"\n"]<>"\n";

(*create the body*)
headerBody=StringRiffle[OptionValue["Body"],"\n"];

Return[FormatCode[
headerPrefix<>"\n"<>headerIncludes<>"\n"<>headerBody
]
];
];


(* ::Input::Initialization:: *)
$DefaultRegulatorDefinitions="
static __forceinline__ __device__ __host__ auto RB(const auto k2, const auto p2) { return REG::RB(k2, p2); }
static __forceinline__ __device__ __host__ auto RF(const auto k2, const auto p2) { return REG::RF(k2, p2); }

static __forceinline__ __device__ __host__ auto RBdot(const auto k2, const auto p2) { return REG::RBdot(k2, p2); }
static __forceinline__ __device__ __host__ auto RFdot(const auto k2, const auto p2) { return REG::RFdot(k2, p2); }

static __forceinline__ __device__ __host__ auto dq2RB(const auto k2, const auto p2) { return REG::dq2RB(k2, p2); }
static __forceinline__ __device__ __host__ auto dq2RF(const auto k2, const auto p2) { return REG::dq2RF(k2, p2); }
";

Options[CreateKernelClass]={
"integrationVariables"->{},"parameters"->{},"CodeParser"->"FORM","PrivateDefinitions"->$DefaultRegulatorDefinitions,
"integrandBody"->"","constantBody"->""
};
CreateKernelClass[name_String,integrand_,constant_:0,OptionsPattern[]]:=Module[
{ret,parameters,parametersIntegrand},

parameters=OptionValue["parameters"];
parameters=Map[KeyDrop[#,{"Type"}]&,parameters];
parametersIntegrand=Join[Map[<|"Name"->#|>&,OptionValue["integrationVariables"]],parameters];
ret=MakeCppHeader[
"Body"->{
MakeCppClass[
"TemplateTypes"->{"REG"},
"Name"->name,
"MembersPublic"-> {
MakeCppFunction[integrand,"parameters"->parametersIntegrand,"CodeParser"->OptionValue["CodeParser"],"Name"->"kernel","static"->True,"CUDA"->True,"const"->False,"return"->"auto","body"->OptionValue["integrandBody"]],
MakeCppFunction[constant,"parameters"->parameters,"CodeParser"->"Cpp","Name"->"constant","static"->True,"CUDA"->True,"const"->False,"return"->"auto","body"->OptionValue["constantBody"]]
},
"MembersPrivate"->{OptionValue["PrivateDefinitions"]}]
}];
Return[ret]
]


(* ::Input::Initialization:: *)
JuliaForm[expr_]:=Module[{Fstr},
Fstr=ToString[FortranForm[expr//.{E^x_:>exp[x]}]];StringReplace[Fstr,{a_~~"(i)"->a~~"[i]",a_~~"(-1 + i)"->a~~"[i-1]",a_~~"(1 + i)"->a~~"[i+1]","**"->"^",".*"->"*",".+"->"+","Pi"->"\[Pi]","Sqrt"->"sqrt","Coth"->"coth","Tanh"->"tanh"}]
];

IndentCode[code_String,level_Integer]:=Module[
{ret=code},
For[i=1,i<=level,i++,
ret=StringReplace[ret,"\n"->"\n  "];
];
(*Remove trailing whitespaces*)
While[StringTake[ret,{-1}]===" ",
ret=StringTake[ret,StringLength[ret]-1];
];
Return[ret];
]


(* ::Input::Initialization:: *)
JuliaCode[equation_]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,returnStatement},
optList=$codeOptimizeFunctions;
interpObj=Flatten@Map[Cases[equation,#,Infinity]&,optList];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["_repl"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->replacementNames[[i]],{i,1,Length[replacementObj]}];

definitions=If[Length[replacementObj]>0,
StringJoin[Table[ToString[replacementNames[[i]]]<>" = "<>JuliaForm[FullSimplify@replacementObj[[i]]]<>"\n",{i,1,Length[replacementObj]}]]<>"\n"
,""];
returnStatement="return "<>JuliaForm[equation//.replacements];
definitions<>returnStatement
];


(* ::Input::Initialization:: *)
ClearAll[MakeJuliaFunction];
Options[MakeJuliaFunction]={"Parameters"->{},"Name"->"kernel","Prefix"->"","Body"->""};
MakeJuliaFunction[OptionsPattern[]]:=Module[
{functionPrefix,functionName,
functionParameters,idx,
functionBody},

(*Create prefixe for the function, e.g. static or such + the return value*)
functionPrefix=If[OptionValue["Prefix"]==="","",OptionValue["Prefix"]<>" "];

functionName="function "<>OptionValue["Name"];

functionParameters="("<>StringRiffle[
Map[If[AssociationQ[#],#["Name"],ToString[#]]&,OptionValue["Parameters"]],
", "]<>")";

(*create the body*)
functionBody=StringReplace["\n"<>OptionValue["Body"]<>"\n","\n\n"->"\n"];
functionBody=IndentCode[functionBody,1];

Return[
functionPrefix<>functionName<>functionParameters<>functionBody<>"end"
]
];
MakeJuliaFunction[expr_,OptionsPattern[]]:=Module[{newBody},
newBody=OptionValue["Body"]<>"\n"<>JuliaCode[expr];
MakeJuliaFunction@@(Evaluate@Join[{"Body"->newBody},Thread[Rule@@{#,OptionValue[MakeJuliaFunction,#]}]&@Keys[Options[MakeJuliaFunction]]])
];


(* ::Input::Initialization:: *)
FortranCode[equation_,name_:"result"]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,returnStatement},
optList=$codeOptimizeFunctions;
interpObj=Flatten@Map[Cases[equation,#,Infinity]&,optList];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["repl"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->Symbol@replacementNames[[i]],{i,1,Length[replacementObj]}];

definitions=If[Length[replacementObj]>0,
StringJoin[Table["real, parameter :: "<>ToString[replacementNames[[i]]]<>" = "<>ToString@FortranForm[FullSimplify@replacementObj[[i]]]<>"\n",{i,1,Length[replacementObj]}]]<>"\n"
,""];
returnStatement=name<>" = "<>ToString@FortranForm[equation//.replacements];
definitions<>"\n"<>returnStatement
];


(* ::Input::Initialization:: *)
ClearAll[MakeFortranFunction];
Options[MakeFortranFunction]={"Parameters"->{},"Name"->"kernel","Prefix"->"","Body"->""};
MakeFortranFunction[OptionsPattern[]]:=Module[
{functionPrefix,functionName,
functionParameters,idx,
functionBody},

(*Create prefixe for the function, e.g. static or such + the return value*)
functionPrefix=If[OptionValue["Prefix"]==="","",OptionValue["Prefix"]<>" "];

functionName="function "<>OptionValue["Name"];

functionParameters="("<>StringRiffle[
Map["real "<>If[AssociationQ[#],#["Name"],ToString[#]]&,OptionValue["Parameters"]],
", "]<>")";

(*create the body*)
functionBody=StringReplace["\n"<>OptionValue["Body"]<>"\n","\n\n"->"\n"];
functionBody=IndentCode[functionBody,1];

Return[
functionPrefix<>functionName<>functionParameters<>functionBody<>"end"
]
];
MakeFortranFunction[expr_,OptionsPattern[]]:=Module[{newBody},
newBody=OptionValue["Body"]<>"\n"<>FortranCode[expr,OptionValue["Name"]];
MakeFortranFunction@@(Evaluate@Join[{"Body"->newBody},Thread[Rule@@{#,OptionValue[MakeFortranFunction,#]}]&@Keys[Options[MakeFortranFunction]]])
];


End[]



