(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetLoopMomentumName::usage=""

CppCode::usage=""

FORMCode::usage=""

MakeCppClass::usage=""

MakeHeader::usage=""

MakeCppFunction::usage=""

DefineCppNames::usage=""

CppForm::usage=""

FormatCode::usage=""


Begin["`Private`"]


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"COEN","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"COEN","FunKit"];
Abort[];
];

ModuleLoaded[COEN]=True;


(* ::Input::Initialization:: *)
$FunKitDirectory=SelectFirst[Join[{FileNameJoin[{$UserBaseDirectory,"Applications","FunKit"}],FileNameJoin[{$BaseDirectory,"Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FunKit"}],FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FunKit"}]},Select[$Path,StringContainsQ[#,"FunKit"]&]],DirectoryQ[#]&]<>"/";


(* ::Input::Initialization:: *)
makeTemporaryFileName[]:=ToString[AbsoluteTime[]*10^6//Round]<>"_"<>ToString[RandomInteger[{10^6,10^7}]]


(* ::Input::Initialization:: *)
ClearAll[CppFormatted];
CppFormatted[expr_,computeType_String:"double"] :=Module[{Powergen,Powery,Sqrty,RemoveFormat,res},
	Format[Powergen[a_,b_],CForm]:="pow("~~ToString[a,CForm]~~", "~~ToString[b,CForm]~~")";
	Format[Powery[a_,b_],CForm]:="powr<"~~ToString[b,CForm]~~">("~~ToString[a,CForm]~~")";
	Format[Sqrty[a_],CForm]:="sqrt("~~ToString[a,CForm]~~")";

	RemoveFormat[exp_]:=Module[{ret},
		ret=exp;
		ret=StringReplace[ret,{"Max(":>"max("}];
		ret=StringReplace[ret,{"Min(":>"min("}];
		ret=StringReplace[ret,{"Re(":>"real("}];
		ret=StringReplace[ret,{"Im(":>"imag("}];
		ret=StringReplace[ret,{"Sqrt(":>"sqrt("}];
		ret=StringReplace[ret,{"Log(":>"log("}];
		ret=StringReplace[ret,{"Abs(":>"abs("}];
		ret=StringReplace[ret,{"Complex(":>"complex<"<>computeType<>">("}];
		ret=StringReplace[ret,{"powr<1>(":>"("}];
		ret=StringReplace[ret,{"HeavisideTheta(":>"heaviside_theta("}];
		While[StringCount[ret,{"\\","\""," "}]>0,
			ret=StringReplace[ret,{"\\"->"","\""->""," "->""}]
		];
		ret
	];

	res=ToString[
		CForm[
			expr//.{Power[a_,b_Integer]->Powery[a,b], Power[a_,b_/;Element[b+1/2,Integers]]->Powery[Sqrty[a],2b],Power[a_,b_]->Powergen[a,b]}//.ArcTan[a_,b_]:>Global`atan2[a,b]
		]
	]//RemoveFormat;
	
	If[computeType=="float",
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:DigitCharacter..~~"e-"~~c:DigitCharacter..:>a~~"."~~b~~"*"~~ToString[DecimalForm[10^-ToExpression[c]//N]]];
	res=StringReplace[res,a:DigitCharacter..~~"."~~"e-"~~c:DigitCharacter..:>a~~"."~~"*"~~ToString[DecimalForm[10^-ToExpression[c]//N]]];
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:DigitCharacter..:>a~~"."~~b~~"f"];
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:Except[DigitCharacter]:>a~~".f"~~b];
	res=StringReplace[res,a:DigitCharacter..~~"."~~EndOfString:>a~~".f"];
	];
	res=StringReplace[res,{"Complex(":>"complex<"<>computeType<>">("}];
	Return[res//RemoveFormat];
];

CppNames={};
DefineCppNames[rules___]:=Module[{baseList,ruleList},
	baseList={
		"Sin("->"sin(",
		"Cos("->"cos(",
		"Tan("->"tan(",
		"Cot("->"cot(",
		"q0f"->"(q0 + M_PI * T)"
	};
	ruleList={rules};
	CppNames=Join[ruleList,baseList];
];
DefineCppNames[]

CppForm[expr_,computeType_String:"double"]:=StringDelete[StringReplace[CppFormatted[expr,computeType],CppNames],"\n"|"\r"];


(* ::Input::Initialization:: *)
clangFormatExists=Quiet[RunProcess[{"clang-format","--help"}]]=!=$Failed;
CreateClangFormat[path_:"./"]:=If[Not@FileExistsQ[path<>"/.clang-format"],
Export[path<>"/.clang-format",
"BasedOnStyle: LLVM
UseTab: Never
IndentWidth: 2
TabWidth: 2
BreakBeforeBraces: Linux
AllowShortIfStatementsOnASingleLine: true
IndentCaseLabels: false
ColumnLimit: 120
AccessModifierOffset: -2
NamespaceIndentation: All
AllowShortEnumsOnASingleLine: true
",
"Text"]
];

WriteCodeToFile[fileName_String,expression_String]:=Module[{tmpfileName},
	tmpfileName=fileName<>".tmpcode";
	Export[tmpfileName,expression,"Text"];
	If[clangFormatExists,
		CreateClangFormat[];
		RunProcess[$SystemShell, All, "clang-format "<>tmpfileName<>" > "<>tmpfileName<>"_formatted && mv "<>tmpfileName<>"_formatted "<>tmpfileName];
	];
	If[FileExistsQ[fileName],
		If[Import[fileName,"Text"]==Import[tmpfileName,"Text"],
			Print[fileName<>" unchanged"];
			RunProcess[$SystemShell, All, "rm "<>tmpfileName],
			Print["Exported to "<>fileName];
			RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
		],
		Print["Exported to "<>fileName];
		RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
	]
];

FormatCode[expression_String]:=Module[{tmpfileName1,tmpfileName2,output},
tmpfileName1="/tmp/in_"<>makeTemporaryFileName[];
tmpfileName2="/tmp/out_"<>makeTemporaryFileName[];
Export[tmpfileName1,expression,"Text"];
If[clangFormatExists,
RunProcess[$SystemShell, All, "rm /tmp/.clang-format"];
CreateClangFormat["/tmp/"];
RunProcess[$SystemShell, All, "clang-format "<>tmpfileName1<>" > "<>tmpfileName2];
	];
If[FileExistsQ[tmpfileName2],
output=Import[tmpfileName2,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName1<>" "<>tmpfileName2];
Return[output];
];
Return[expression]
];


(* ::Input::Initialization:: *)
ClearAll[balancedBracesQ]
balancedBracesQ[str_String]:=Module[{cases,idx},
If[Not@(StringCount[str,"("]===StringCount[str,")"]),Return[False]];
cases=StringCases[str,"("|")"];
For[idx=1,idx<=Length[cases],idx++,
If[(Count[cases[[;;idx]],"("]<Count[cases[[;;idx]],")"]),Return[False]];
];
Return[True];
];
balancedRBracesQ[str_String]:=StringCount[str,"["]===StringCount[str,"]"]

hasNoOperators[str_String]:=StringFreeQ[str,")"]&&StringFreeQ[str,"("]&&StringFreeQ[str,"["]&&StringFreeQ[str,"]"]&&
StringFreeQ[str,"*"]&&StringFreeQ[str,"/"]&&
StringFreeQ[str,"+"]&&StringFreeQ[str,"-"]&&
StringFreeQ[str,"%"]&&StringFreeQ[str,"&"]


(* ::Input::Initialization:: *)
formatFORMCode[expr_String]:=Module[
{start,res,pres,idx,maxW,repl},
start=StringPosition[expr,"\n"];
start=If[Length[start]<=1,1,start[[2,1]]];
res=StringTake[expr,{start,-1}];

(*operation replacements*)
While[pres=!=res,
pres=res;
res=StringReplace[res,
{
Shortest["pow("~~(arg1__)~~","~~(arg2:(DigitCharacter...|"-"~~(DigitCharacter...)))~~")"]/;balancedBracesQ[arg1]&&StringFreeQ[arg1,";"]:>"powr<"~~arg2~~">("~~arg1~~")",
Shortest["pow("~~(arg1__)~~","~~"1./2."~~")"]/;balancedBracesQ[arg1]&&StringFreeQ[arg1,";"]:>"sqrt("~~arg1~~")",
" "->""
}
];
];

(*turn the buffer into a list of definitions of variables*)
maxW=Max[Map[ToExpression@StringTake[#,{3,-2}]&,StringCases[res,Shortest["w["~~(arg1__/;balancedRBracesQ[arg1])~~"]"]]]];
For[idx=1,idx<=maxW,idx++,
res=StringReplacePart[res,"auto _tmp"<>ToString[idx]<>"",StringPosition[res,"w["<>ToString[idx]<>"]",1]];
];
res=StringReplace[res,
{
Shortest["w["~~(arg1__/;balancedRBracesQ[arg1])~~"]"]:>"_tmp"~~arg1~~"",
"expr="->"return ",
"\n"->""
}
];
res=FormatCode[res];


(*Get rid of unecessary copies*)
repl=Map[
StringReplace[#,"auto _tmp"~~a__~~" = "~~b__~~";"/;hasNoOperators[b]:>"_tmp"~~a~~"->"~~b]&,
Select[StringSplit[res,"\n"],StringMatchQ[#,"auto _tmp"~~a__~~"="~~b__~~";"/;hasNoOperators[b]]&]
];
repl=Map[
((a_/;MatchQ[a,"("|" "|"-"])~~#[[1]]~~(b_/;MatchQ[b,")"|" "|";"]):>a~~#[[2]]~~b&)@StringSplit[#,"->"]&,
repl
];
res=StringJoin[
Select[StringSplit[res,"\n"],Not@StringMatchQ[#,"auto _tmp"~~a__~~"="~~b__/;hasNoOperators[b]]&]
];
res=StringReplace[res,repl];

Return[res];
];

FORMCode[expr_]:=Module[
{origVars,tmpfileName,import},

origVars=FormTracer`GetExtraVars[];

tmpfileName="/tmp/FO_"<>makeTemporaryFileName[];
FormTracer`AddExtraVars@@GetAllCustomSymbols[expr];
FormTracer`FormTrace[expr//Rationalize,{},{},{tmpfileName,"O4"}];
FormTracer`DefineExtraVars[origVars];
import=Import[tmpfileName,"Text"];
RunProcess[$SystemShell, All, "rm "<>tmpfileName];
import//formatFORMCode
];


(* ::Input::Initialization:: *)
$codeOptimizeFunctions={a_Symbol[__]/;Not@MatchQ[a,Times|Plus|Power|Rational|Complex|Real|Integer]};


(* ::Input::Initialization:: *)
CppCode[equation_]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,returnStatement},
optList=$codeOptimizeFunctions;
interpObj=Flatten@Map[Cases[equation,#,Infinity]&,optList];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["_repl"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->replacementNames[[i]],{i,1,Length[replacementObj]}];
definitions=If[Length[replacementObj]>0,
StringJoin[Table["const auto "<>ToString[replacementNames[[i]]]<>" = "<>CppForm[FullSimplify@replacementObj[[i]]]<>";\n",{i,1,Length[replacementObj]}]]<>"\n"
,""];
returnStatement=" return "<>CppForm[equation//.replacements,"auto"]<>";";
definitions<>returnStatement
];


(* ::Input::Initialization:: *)
makeCppTemplateParameter[n_]:="typename T"<>ToString[n];
makeCppParameter[t_,n_]:=Module[{ret},
ret="const ";
ret=ret<>If[KeyFreeQ[t,"Type"]||t["Type"]==="template",
"T"<>ToString[n],
"aua"
];
ret=ret<>If[KeyExistsQ[t,"Reference"]&&t["Reference"],"& "," "];
ret=ret<>t["Name"];
Return[ret];
]


(* ::Input::Initialization:: *)
ClearAll[MakeCppFunction];
Options[MakeCppFunction]={"return"->"auto","const"->False,"parameters"->{},"Name"->"function","static"->False,"CUDA"->False,"CodeParser"->"FORM","body"->""};
MakeCppFunction[OptionsPattern[]]:=Module[
{functionPrefix,functionSuffix,functionName,
functionParameters,functionTemplates,idx,
functionBody},

(*Create prefixe for the function, e.g. static or such + the return value*)
functionPrefix="";
If[OptionValue["static"],functionPrefix=functionPrefix<>"static "];
If[OptionValue["CUDA"],functionPrefix=functionPrefix<>"__host__ __device__ "];
functionPrefix=functionPrefix<>OptionValue["return"]<>" ";

functionSuffix="";
If[OptionValue["const"],functionSuffix=functionSuffix<>" const"];

functionName=OptionValue["Name"];

(*Create both a template list and a parameter list*)
functionTemplates=If[Length[OptionValue["parameters"]]===0,
"",
"template<"<>StringRiffle[
Pick[
Table[makeCppTemplateParameter[idx],{idx,1,Length[OptionValue["parameters"]]}],
Table[KeyFreeQ[OptionValue["parameters"][[idx]],"Type"]||OptionValue["parameters"][[idx]]["Type"]==="template",{idx,1,Length[OptionValue["parameters"]]}]
],", "]<>">\n"
];
functionParameters="("<>StringRiffle[
Table[makeCppParameter[OptionValue["parameters"][[idx]],idx],{idx,1,Length[OptionValue["parameters"]]}]
,", "]<>")";

(*create the body*)
functionBody=StringReplace["{\n"<>OptionValue["body"]<>"\n}","\n\n"->""];

Return[FormatCode[
functionTemplates<>functionPrefix<>functionName<>functionParameters<>functionSuffix<>"\n"<>functionBody
]
]
];
MakeCppFunction[expr_,OptionsPattern[]]:=Module[{codeParser,newBody},
codeParser=If[OptionValue["CodeParser"]==="FORM",FORMCode,CppCode];
newBody=OptionValue["body"]<>"\n"<>codeParser[expr];
MakeCppFunction@@(Evaluate@Join[{"body"->newBody},Thread[Rule@@{#,OptionValue[MakeCppFunction,#]}]&@Keys[Options[MakeCppFunction]]])
];


(* ::Input::Initialization:: *)
Options[MakeCppClass]={"TemplateTypes"->{},"MembersPublic"->{},"MembersPrivate"->{},"MembersProtected"->{},"Name"->"Class","bases"->{}};
MakeCppClass[OptionsPattern[]]:=Module[
{classPrefix,classSuffix,className,
classParameters,classTemplates,codeParser,
classBody},

(*Create prefixe for the class, e.g. static or such + the return value*)
classPrefix=If[Length[OptionValue["TemplateTypes"]]>0,"template<"~~StringRiffle[Map["typename "~~#&,OptionValue["TemplateTypes"]],", "]~~">\n",""];
classPrefix=classPrefix<>"class ";

classSuffix="";

className=OptionValue["Name"];

(*create the body*)
classBody="{\n"<>
If[Length[OptionValue["MembersPublic"]]>0,"public: "<>StringRiffle[OptionValue["MembersPublic"],"\n\n"],""]<>
If[Length[OptionValue["MembersProtected"]]>0,"protected: "<>StringRiffle[OptionValue["MembersProtected"],"\n\n"],""]<>
If[Length[OptionValue["MembersPrivate"]]>0,"private: "<>StringRiffle[OptionValue["MembersPrivate"],"\n\n"],""]<>
"\n};";
StringReplace[classBody,{";;"->";"}];

Return[FormatCode[
classPrefix<>className<>classSuffix<>"\n"<>classBody
]
]
];


(* ::Input::Initialization:: *)
Options[MakeHeader]={"Includes"->{},"Body"->{}};
MakeHeader[OptionsPattern[]]:=Module[
{headerPrefix,headerIncludes,headerBody},

(*Create prefixe for the header, e.g. static or such + the return value*)
headerPrefix="#pragma once\n";

headerIncludes=StringRiffle[Map["#include \""~~#~~"\""&,OptionValue["Includes"]],"\n"]<>"\n";

(*create the body*)
headerBody=StringRiffle[OptionValue["Body"],"\n"];

Return[FormatCode[
headerPrefix<>"\n"<>headerIncludes<>"\n"<>headerBody
]
];
];


(* ::Input::Initialization:: *)
$DefaultRegulatorDefinitions="
static __forceinline__ __device__ __host__ auto RB(const auto k2, const auto p2) { return REG::RB(k2, p2); }
static __forceinline__ __device__ __host__ auto RF(const auto k2, const auto p2) { return REG::RF(k2, p2); }

static __forceinline__ __device__ __host__ auto RBdot(const auto k2, const auto p2) { return REG::RBdot(k2, p2); }
static __forceinline__ __device__ __host__ auto RFdot(const auto k2, const auto p2) { return REG::RFdot(k2, p2); }

static __forceinline__ __device__ __host__ auto dq2RB(const auto k2, const auto p2) { return REG::dq2RB(k2, p2); }
static __forceinline__ __device__ __host__ auto dq2RF(const auto k2, const auto p2) { return REG::dq2RF(k2, p2); }
";

Options[CreateKernelClass]={
"integrationVariables"->{},"parameters"->{},"CodeParser"->"FORM","PrivateDefinitions"->$DefaultRegulatorDefinitions,
"integrandBody"->"","constantBody"->""
};
CreateKernelClass[name_String,integrand_,constant_:0,OptionsPattern[]]:=Module[
{ret,parameters,parametersIntegrand},

parameters=OptionValue["parameters"];
parameters=Map[KeyDrop[#,{"Type"}]&,parameters];
parametersIntegrand=Join[Map[<|"Name"->#|>&,OptionValue["integrationVariables"]],parameters];
ret=MakeHeader[
"Body"->{
MakeCppClass[
"TemplateTypes"->{"REG"},
"Name"->name,
"MembersPublic"-> {
MakeCppFunction[integrand,"parameters"->parametersIntegrand,"CodeParser"->OptionValue["CodeParser"],"Name"->"kernel","static"->True,"CUDA"->True,"const"->False,"return"->"auto","body"->OptionValue["integrandBody"]],
MakeCppFunction[constant,"parameters"->parameters,"CodeParser"->"Cpp","Name"->"constant","static"->True,"CUDA"->True,"const"->False,"return"->"auto","body"->OptionValue["constantBody"]]
},
"MembersPrivate"->{OptionValue["PrivateDefinitions"]}]
}];
Return[ret]
]


End[]



