(* ::Package:: *)

(* ::Title:: *)

(*AnSEL - Analysis and Simplification of Equations with Loops*)

(* ::Section:: *)

(*Exports*)

(* ::Input::Initialization:: *)

SetLoopMomentumName::usage = "SetLoopMomentumName[name]
Sets the base name for loop momentum variables used in functional calculations.
The name should be a string (e.g., \"l\", \"k\", \"q\") that will be used to generate loop momenta l1, l2, l3, etc.
Also creates fermionic variants (lf1, lf2, ...) and bosonic variants for different loop types.
Default setting is \"l\".";

FMakeSymmetryList::usage = "FMakeSymmetryList[setup, {f1, f2, ...}]
Generates a list of symmetries for functional expressions based on the provided fields.
Each field fi should be a valid field symbol defined in the setup.
Returns a list of symmetry rules that can be used in FSimplify to identify identical diagrams.";

FRoute::usage = "FRoute[setup, expr]
Routes indices and momenta in functional expressions, organizing terms by loop order.
For FTerm expressions, returns an Association with keys \"Expression\", \"ExternalIndices\", and \"LoopMomenta\".
For FEx expressions, returns an Association with keys like \"0-Loop\", \"1-Loop\", \"2-Loop\", etc.
Automatically enforces momentum conservation and assigns unique loop momentum variables.
Essential for organizing diagrammatic calculations by perturbative order.";

FUnroute::usage = "FUnroute[setup, expr]
Reverses the index and momentum routing performed by FRoute.
Converts routed expressions (with explicit momenta and indices) back to superindex notation.
Can handle both individual loop-order associations and complete routed expressions.
Used when you need to go back from explicit momentum space to abstract superindex form.";

FSimplify::usage = "FSimplify[setup, expr]
Simplifies functional expressions by identifying and combining identical terms.
Uses sophisticated diagram comparison algorithms to detect terms that differ only by index relabeling.
FSimplify[setup, expr, \"Symmetries\" -> symmetries] allows specifying symmetries to enhance simplification.
Significantly reduces the number of terms in complex functional calculations.
Essential for making large diagrammatic expressions manageable.";

loopMomentum::usage = "loopMomentum[momentum, isGrassmann]
Internal representation for loop momentum variables during the routing process.
The first argument is the momentum symbol, the second indicates whether it's Grassmann (True) or commuting (False).
This is automatically generated by FRoute and should not be used directly by users.
Gets converted to standard momentum notation (l1, l2, lf1, lf2, etc.) at the end of routing.";

externalMomentum::usage = "externalMomentum[momentum, isGrassmann]
Internal representation for external momentum variables during the routing process.
The first argument is the momentum symbol, the second indicates whether it's Grassmann (True) or commuting (False).
This is automatically generated by FRoute and should not be used directly by users.
Gets converted to standard momentum notation at the end of routing.";

(* ::Section:: *)

(*Begin Private*)

(* ::Input::Initialization:: *)

Begin["`Private`"];

ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FEDeriK"];
    Abort[];
];

ModuleLoaded[AnSEL] = True;

(* ::Section:: *)

(*Loading Components*)

(* ::Input::Initialization:: *)

(* Global setup *)

Get[$FunKitDirectory <> "modules/AnSEL/Global.m"];

(* Routing *)

Get[$FunKitDirectory <> "modules/AnSEL/Routing.m"];

(* Simplification *)

Get[$FunKitDirectory <> "modules/AnSEL/Simplify.m"];

(* ::Section:: *)

(*End Private*)

(* ::Input::Initialization:: *)

End[];
