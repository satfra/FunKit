(* ::Package:: *)

(* ::Title:: *)
(*AnSEL - Analysis and Simplification of Equations with Loops*)


(* ::Section::Closed:: *)
(*Exports*)


(* ::Input::Initialization:: *)
SetLoopMomentumName::usage = "SetLoopMomentumName[name]
Sets the base name for loop momentum variables used in functional calculations.
The name should be a string (e.g., \"l\", \"k\", \"q\") that will be used to generate loop momenta l1, l2, l3, etc.
Also creates fermionic variants (lf1, lf2, ...) and bosonic variants for different loop types.
Default setting is \"l\".";

FRoute::usage = "FRoute[setup, expr]
Routes indices and momenta in functional expressions, organizing terms by loop order.
For FTerm expressions, returns an Association with keys \"Expression\", \"ExternalIndices\", and \"LoopMomenta\".
For FEx expressions, returns an Association with keys like \"0-Loop\", \"1-Loop\", \"2-Loop\", etc.
Automatically enforces momentum conservation and assigns unique loop momentum variables.
Essential for organizing diagrammatic calculations by perturbative order.";

FUnroute::usage = "FUnroute[setup, expr]
Reverses the index and momentum routing performed by FRoute.
Converts routed expressions (with explicit momenta and indices) back to superindex notation.
Can handle both individual loop-order associations and complete routed expressions.
Used when you need to go back from explicit momentum space to abstract superindex form.";

FSimplify::usage = "FSimplify[setup, expr]
Simplifies functional expressions by identifying and combining identical terms.
Uses sophisticated diagram comparison algorithms to detect terms that differ only by index relabeling.
FSimplify[setup, expr, \"Symmetries\" -> symmetries] allows specifying symmetries to enhance simplification.
Significantly reduces the number of terms in complex functional calculations.
Essential for making large diagrammatic expressions manageable.";

loopMomentum::usage = "loopMomentum[momentum, isGrassmann]
Internal representation for loop momentum variables during the routing process.
The first argument is the momentum symbol, the second indicates whether it's fermionic (True) or bosonic (False).
This is automatically generated by FRoute and should not be used directly by users.
Gets converted to standard momentum notation (l1, l2, lf1, lf2, etc.) at the end of routing.";



(* ::Section::Closed:: *)
(*Begin Private*)


Begin["`Private`"];



(* ::Section::Closed:: *)
(*Global setup redefinitions*)


(* ::Input::Initialization:: *)
FRoute[expr_FEx] /; Head[$GlobalSetup] =!= Symbol :=
    FRoute[$GlobalSetup, expr];

FUnroute[expr_] /; Head[$GlobalSetup] =!= Symbol :=
    FUnroute[$GlobalSetup, expr];

FSimplify[expr_FEx] /; Head[$GlobalSetup] =!= Symbol :=
    FSimplify[$GlobalSetup, expr];

FSimplify[expr_FEx, OptionsPattern[]] /; Head[$GlobalSetup] =!= Symbol :=
    FSimplify[$GlobalSetup, expr, (Sequence @@ Thread[Rule @@ {#, OptionValue[
        FSimplify, #]}]& @ Keys[Options[FSimplify]])];



(* ::Section:: *)
(*Global variables*)


(* ::Input::Initialization:: *)
ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FEDeriK"];
    Abort[];
];

ModuleLoaded[AnSEL] = True;



(* ::Input::Initialization:: *)
SetLoopMomentumName[name_String] :=
    Module[{},
        If[StringQ[$loopMomentumName],
            Unprotect @@ Table[$loopMomentumName <> ToString[idx], {idx,
                 1, 50}];
            Unprotect @@ Table[$loopMomentumName <> "f" <> ToString[idx
                ], {idx, 1, 50}];
            Unprotect @@ Table[$loopMomentumName <> "fb" <> ToString[
                idx], {idx, 1, 50}];
        ];
        $loopMomentumName = name;
        ClearAll @@ Table[$loopMomentumName <> ToString[idx], {idx, 1,
             50}];
        ClearAll @@ Table[$loopMomentumName <> "f" <> ToString[idx], 
            {idx, 1, 50}];
        ClearAll @@ Table[$loopMomentumName <> "fb" <> ToString[idx],
             {idx, 1, 50}];
        Protect @@ Table[$loopMomentumName <> ToString[idx], {idx, 1,
             50}];
        Protect @@ Table[$loopMomentumName <> "f" <> ToString[idx], {
            idx, 1, 50}];
        Protect @@ Table[$loopMomentumName <> "fb" <> ToString[idx], 
            {idx, 1, 50}];
        Unprotect[$availableLoopMomenta, $availableLoopMomentaf, $availableLoopMomentafb
            ];
        $availableLoopMomenta := Table[Symbol[$loopMomentumName <> ToString[
            idx]], {idx, 1, 50}];
        $availableLoopMomentaf := Table[Symbol[$loopMomentumName <> "f"
             <> ToString[idx]], {idx, 1, 50}];
        $availableLoopMomentafb := Table[Symbol[$loopMomentumName <> 
            "fb" <> ToString[idx]], {idx, 1, 50}];
        Protect[$availableLoopMomenta, $availableLoopMomentaf, $availableLoopMomentafb
            ];
    ];

SetLoopMomentumName["l"];



(* ::Section:: *)
(*Index routing*)


(* ::Input::Initialization:: *)
(*A convenience function to quickly obtain the index structure of a given field.*)

FieldSetupIndices[setup_, field_] :=
    Module[{},
        List @@ SelectFirst[Flatten @ Values[setup["FieldSpace"]], Head[
            #] === field&]
    ];



(* ::Input::Initialization:: *)
FRoute::undeterminedFields = "Cannot route indices in expressions with undetermined fields.";

FRoute::momentaFailed = "Cannot route momenta in the given expression. Final momentum conservation read `1`";

FRoute::conservationFail = "Momentum conservation could not be fulfilled. Error in `1`.
Full Expression:
`2`";

FRoute[setup_, expr_FTerm] :=
    Module[{openIndices, closedIndices, objects, ret = ReduceFTerm[setup,
         ReduceIndices[setup, expr]], doFields, idx, a, indPos, assocField, subObj,
         subMom, subExtMom, indStruct, externalIndices, externalMomenta, kind,
         f, momRepl, i, mom, loopMomenta, sidx, discard},
        FunKitDebug[1, "FRoute: routing the sub-term ", expr];
        (*We first get all closed, open indices and all indexed objects.
            *)
        doFields = replFields[setup];
        openIndices = Sort @ GetOpenSuperIndices[setup, ret];
        closedIndices = GetClosedSuperIndices[setup, ret];
        objects = ExtractObjectsWithIndex[setup, ret] //. doFields;
        (*If there are any undetermined fields, we cannot route indices.
            *)
        If[MemberQ[objects[[All, 1]], AnyField, {1, 4}],
            Message[FRoute::undeterminedFields];
            Abort[]
        ];
(*As a first step, we insert the correct index structures into all superindices and define momentum variables at every single vertex.
    
We loop over all closed indices.*)
        Do[
            (*The indexed object we currently modify. There are always two and we simply grab the first.
                *)subObj = Select[objects, MemberQ[#, closedIndices[[idx]], Infinity]&
                ][[1]];
            (*The position of the current index inside the subObj*)
            indPos = FirstPosition[subObj[[2]], closedIndices[[idx]]]
                [[1]];
            (*See what kind of field is associated with the index*)
            assocField = subObj[[1, indPos]];
            (*Grab the index structure of this field from the setup and assign a new momentum variable
                *)
            indStruct =
                Map[
                    If[MatchQ[#, _Symbol],
                        Unique[SymbolName[#]]
                        ,
                        #
                    ]&
                    ,
                    FieldSetupIndices[setup, assocField]
                    ,
                    {1, 3}
                ];
            indStruct[[1]] = loopMomentum[indStruct[[1]], IsGrassmann[
                setup, assocField]];
(*replace all occurences of the superindex with the fitting index structure. 
    
We want to keep the index sign in the momenta, but remove it from the group indices
    *)
            ret = ret /. closedIndices[[idx]] -> indStruct;
            objects = objects /. closedIndices[[idx]] -> indStruct;
            If[Length[indStruct] > 1,
                ret = ret /. (-indStruct[[2]]) -> indStruct[[2]];
                objects = objects /. (-indStruct[[2]]) -> indStruct[[
                    2]];
            ];
            ,
            {idx, 1, Length[closedIndices]}
        ];
(*Next, we treat the external superindices. We assign to each an open group structure and a new momentum p1,p2,... 
    
Momentum conservation is already enforced here, i.e. \!\(
\*SubscriptBox[\(\[Sum]\), \(i\)]
\*SubscriptBox[\(p\), \(i\)]\)=0 and we choose Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]\(
\*SubscriptBox[\(p\), \(i\)]\ for\ the\ last\ momentum\ \(
\*SubscriptBox[\(p\), \(n\)]\(.\)\)\)\)*)
        externalIndices = Table[{}, {idx, 1, Length[openIndices]}];
        Do[
            (*see above*)subObj = Select[objects, MemberQ[#, openIndices
                [[idx]], Infinity]&][[1]];
            indPos = FirstPosition[subObj[[2]], openIndices[[idx]]][[
                1]];
            assocField = subObj[[1, indPos]];
            indStruct =
                Map[
                    If[MatchQ[#, _Symbol],
                        Symbol[SymbolName[#] <> ToString[idx]]
                        ,
                        #
                    ]&
                    ,
                    FieldSetupIndices[setup, assocField]
                    ,
                    {1, 3}
                ];
(*Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]
\*SubscriptBox[\(p\), \(i\)]\)*)
            If[idx === Length[openIndices],
                indStruct[[1]] = -Total[Values[externalIndices][[ ;; 
                    idx - 1, 1]]]
            ];
            ret = ret /. (-openIndices[[idx]]) -> indStruct;
            ret = ret /. (openIndices[[idx]]) -> indStruct;
            objects = objects /. (-openIndices[[idx]]) -> indStruct;
            objects = objects /. openIndices[[idx]] -> indStruct;
            (*This is information for the user, which we will return.
                *)
            externalIndices[[idx]] = openIndices[[idx]] -> indStruct;
                
            ,
            {idx, 1, Length[openIndices]}
        ];
        (*extract a list of all new external momenta*)
        externalMomenta = Values[externalIndices][[All, 1]];
        FunKitDebug[2, "  FRoute: Determined external momenta as ", externalMomenta
            ];
        (*Now, we do the momentum routing. We iterate over all objects in subObj and fully resolve them.
            *)
        Do[
            subObj = objects[[idx]];
            subMom = subObj[[2, All, 1]];
            (*See if the object has any external (sub-)momenta*)
            subExtMom = Select[subMom, (ContainsAny[externalMomenta, 
                makePosIdx /@ Flatten[{# /. Plus[a_, b__] :> List[a, b]}]])&];
            FunKitDebug[3, "  FRoute: routing the subObj ", subObj];
            FunKitDebug[3, "    FRoute: subExtMom are ", subExtMom];
            (********************************************************************************
                *)
            (*CASE 0: If momentum conservation is already fulfilled, do nothing
                *)
            (********************************************************************************
                *)
            If[Total @ subMom === 0,
                Continue[]
            ];
            (********************************************************************************
                *)
            (*CASE 1: we have no external momentum anywhere in the legs of the current object
                *)
            (********************************************************************************
                *)
            If[Length[subExtMom] === 0,
                (*If we have nothing to enforce, skip this object*)
                If[Length[subObj[[2, All, 1]]] < 2,
                    Continue[]
                ];
                FunKitDebug[3, "      FRoute: No external momenta"];
(*For safety, we try to route our momenta through fermions.
At 1-loop this is irrelevant, at n-loop it is not. Furthermore, this allows us to explicitly mark fermionic loops!
    *)
                f = FirstPosition[IsFermion[setup, #]& /@ subObj[[1]],
                     True][[1]];
                If[f === "NotFound",
                    f = FirstPosition[IsGrassmann[setup, #]& /@ subObj
                        [[1]], True][[1]];
                    If[f === "NotFound",
                        (*If there are no fermions, just use the first momentum.
                            *)
                        f = 1
                    ];
                ];
                mom = makePosIdx @ Select[
                            (*Make a list out of the momentum sum in the subObj at position f
                                *)Flatten[{subObj[[2, f, 1]] //. {Plus[a_, b__] :> List[a, b], Times[
                                a_loopMomentum, b__] :> List[a, b]}}]
                            ,
                            (*Grab one of the momenta which is a loopMomentum
                                *)
                            (MatchQ[#, loopMomentum[__]] || MatchQ[-#,
                                 loopMomentum[__]])&
                        ][[1]];
                momRepl = Solve[Total[subObj[[2, All, 1]]] == 0, mom]
                    [[1, 1]];
                objects = objects /. momRepl;
                ret = ret /. momRepl;
                FunKitDebug[3, "  FRoute: routing a momentum as ", momRepl
                    ];
                Continue[];
            ];
            (********************************************************************************
                *)
            (*Case 2*)
            (********************************************************************************
                *)
            If[Length[subExtMom] <= Length[subMom],
                FunKitDebug[3, "      FRoute: Have both internal and external momenta"
                    ];
(*Discard helps us to iterate thorugh momentum arguments.
sidx iterates through the loopMomenta contained in each mometnum argument
    *)
                discard[_] = False;
                sidx = 0;
                While[
                    sidx < 1000
                    ,
                    sidx++;
                    (*For safety, we try to route our momenta through fermions.
                        *)
                    f = FirstPosition[Table[(IsFermion[setup, subObj[[
                        1, i]]] && MemberQ[makePosIdx /@ Flatten[{subObj[[2, i, 1]] /. Plus[a_,
                         b__] :> List[a, b]}], loopMomentum[__]] && Not @ discard[i]), {i, 1,
                         Length[subObj[[1]]]}], True][[1]];
                    (*Alternatively, just grab a Grassman*)
                    If[f === "NotFound",
                        f = FirstPosition[Table[(IsGrassmann[setup, subObj
                            [[1, i]]] && MemberQ[makePosIdx /@ Flatten[{subObj[[2, i, 1]] /. Plus[
                            a_, b__] :> List[a, b]}], loopMomentum[__]] && Not @ discard[i]), {i,
                             1, Length[subObj[[1]]]}], True][[1]];
                        (*If no fermions are present, simply grab the index which does not contain external momenta.
                            *)
                        If[f === "NotFound",
                            f = FirstPosition[Table[MemberQ[makePosIdx
                                 /@ Flatten[{subObj[[2, i, 1]] /. Plus[a_, b__] :> List[a, b]}], loopMomentum[
                                __]] && Not @ discard[i], {i, 1, Length[subObj[[1]]]}], True][[1]];
                            (*The only other possibility is that all momenta are external. In that case, we do nothing but check consistency.
                                *)
                            If[f === "NotFound",
                                Break[];
                            ];
                        ];
                    ];
                    (*Extract all loop momenta*)
                    mom = makePosIdx /@ Select[Flatten[{subObj[[2, f,
                         1]] /. Plus[a_, b__] :> List[a, b]}], (MatchQ[#, loopMomentum[__]] ||
                         MatchQ[-#, loopMomentum[__]])&];
                    If[sidx > Length[mom],
                        discard[f] = True;
                        sidx = 0;
                        Continue[];
                    ];
                    mom = mom[[sidx]];
                    (*If the momentum is already routed through, ignore it (e.g. p in Propagator[{...},{-p+..., p+...}])
                        *)
                    If[Not @ MemberQ[{Total[subObj[[2, All, 1]]]}, mom,
                         Infinity],
                        Continue[];
                    ];
                    (*if we were not stopped, we got it*)
                    Break[];
                ];
                (********************************************************************************
                    *)
                (*The only other possibility is that all momenta are external. In that case, we do nothing but check consistency.
                    *)
                (********************************************************************************
                    *)
                If[f === "NotFound",
                    FunKitDebug[3, "      FRoute: Have only external momenta"
                        ];
                    If[Total @ subObj[[2, All, 1]] =!= 0,
                        Message[FRoute::conservationFail, subObj, ret
                            ];
                        Abort[];
                    ];
                    Continue[]
                ];
                momRepl = Solve[Total[subObj[[2, All, 1]]] == 0, mom]
                    [[1, 1]];
                objects = objects /. momRepl;
                ret = ret /. momRepl;
                FunKitDebug[3, "  FRoute: routing a momentum as ", momRepl
                    ];
                Continue[];
            ];
            ,
            {idx, 1, Length[objects]}
        ];
        (*Sanity check to see that we did not make an error*)
        Do[
            subObj = objects[[idx]];
            (*Skip again Fields and such*)
            If[Length[subObj[[2, All, 1]]] < 2,
                Continue[]
            ];
            (*Check the conservation of momentum at all vertices*)
            If[Total[subObj[[2, All, 1]]] =!= 0,
                Message[FRoute::momentaFailed, Total[subObj[[2, All, 
                    1]]]];
                Abort[]
            ];
            ,
            {idx, 1, Length[objects]}
        ];
        (*replace the loopMomenta[...] by l1, l2, ...*)
        loopMomenta = Cases[objects[[All, 2, 1]], loopMomentum[__], Infinity
            ] // DeleteDuplicates;
        kind =
            If[#[[2]],
                "f"
                ,
                ""
            ]&;
        ret = ret /. Thread[loopMomenta -> Table[Symbol[$loopMomentumName
             <> kind[loopMomenta[[idx]]] <> ToString[idx]], {idx, 1, Length[loopMomenta
            ]}]];
        loopMomenta = loopMomenta /. Thread[loopMomenta -> Table[Symbol[
            $loopMomentumName <> ToString[idx]], {idx, 1, Length[loopMomenta]}]];
            
        Return[<|"Expression" -> FEx[ret], "ExternalIndices" -> Sort 
            @ externalIndices, "LoopMomenta" -> Sort @ loopMomenta|>];
    ];

makeMomentaAlternatives[mom_] :=
    Module[{idx},
        idx = StringSplit[SymbolName[mom], x:NumberString :> ToExpression
             @ x][[2]];
        Return[Alternatives[Symbol[$loopMomentumName <> ToString[idx]], Symbol[$loopMomentumName
             <> "f" <> ToString[idx]]]]
    ];

FRoute[setup_, expr_FEx] :=
    Module[{results, ret, idx, subidx},
        results = FRoute[setup, #]& /@ (List @@ expr);
        results = GatherBy[results, Length[#["LoopMomenta"]]&];
        results = Map[<|"Expression" -> FEx @@ #[[All, Key["Expression"
            ]]], "ExternalIndices" -> #[[1, Key["ExternalIndices"]]], "LoopMomenta"
             -> makeMomentaAlternatives /@ #[[1, Key["LoopMomenta"]]]|>&, results
            ];
        results = Association @@ Map[ToString[Length[#["LoopMomenta"]
            ]] ~~ "-Loop" -> #&, results];
        Return[results];
    ];



(* ::Input::Initialization:: *)
isLoopAssociation[expr_] :=
    Module[{},
        If[Head[expr] =!= Association,
            Return[False]
        ];
        If[FreeQ[Keys[expr], "Expression"],
            Return[False]
        ];
        If[FreeQ[Keys[expr], "ExternalIndices"],
            Return[False]
        ];
        If[FreeQ[Keys[expr], "LoopMomenta"],
            Return[False]
        ];
        Return[True];
    ];

isRoutedAssociation[expr_] :=
    Module[{},
        If[Head[expr] =!= Association,
            Return[False]
        ];
        Return @ AllTrue[expr, isLoopAssociation]
    ];



(* ::Input::Initialization:: *)
FUnroute[setup_, assoc_Association] /; isLoopAssociation[assoc] :=
    Module[{},
        Return @ FUnroute[assoc["Expression"] /. Map[#[[2]] -> #[[1]]&,
             assoc["ExternalIndices"]]];
    ];

FUnroute[setup_, assoc_Association] /; isRoutedAssociation[assoc] :=
    FEx @@ (FUnroute[setup, #]& /@ (List @@ assoc));

FUnroute[setup_, term_FEx] :=
    FUnroute[setup, #]& /@ term;

FUnroute[setup_, term_FTerm] :=
    Module[{fw, bw},
        {fw, bw} = GetSuperIndexTermTransformations[setup, term];
        Return[term // fw];
    ];



(* ::Section:: *)
(*Identification of expressions*)


(* ::Input::Initialization:: *)
(*Get viable starting points for a comparison of two diagrams*)

StartPoints[setup_, t1_FTerm, t2_FTerm] :=
    Module[{obj1, obj2, count, desired, sList, match1, match2, cidx1,
         cidx2, doFields},
        doFields = replFields[setup];
        (*Get all sub-objects inside the terms*)
        obj1 = Reverse @ Sort @ ExtractObjectsWithIndex[setup, t1] /.
             doFields;
        obj2 = Reverse @ Sort @ ExtractObjectsWithIndex[setup, t2] /.
             doFields;
        (*If the objects (with field content) do not match, they are not identical.
            *)
        If[Sort @ Map[Head[#][Sort @ #[[1]]]&, obj1] =!= Sort @ Map[Head[
            #][Sort @ #[[1]]]&, obj2],
            Return[{False, Null, Null}]
        ];
        cidx1 = GetClosedSuperIndices[setup, t1];
        cidx2 = GetClosedSuperIndices[setup, t2];
        If[Length[cidx1] =!= Length[cidx2],
            Return[{False, Null, Null}]
        ];
(*
If[Length[cidx1]>0,
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
];*)
        (*Otherwise, we check which object is the "rarest"*)
        sList = Map[Head[#][#[[1]]]&, obj1];
        count = Counts[sList];
        desired = Keys[count][[PositionSmallest[Values[count]][[1]]]]
            ;
        match1 = Select[obj1, (Head[#][#[[1]]] === desired)&];
        match2 = Select[obj2, (Head[#][#[[1]]] === desired)&];
        (*return all possible starting points *)
        Return[{True, match1, match2}]
    ];



(* ::Input::Initialization:: *)
(*Find all objects following the closed indices attached to the object curPos*)

IterateDiagram[setup_Association, allObj_, closedIndices_, openIndices_,
     curPos_, entryIdx_] :=
    Module[{otherIndices, followObjects, i},
        FunKitDebug[4, "Inspecting: ", curPos];
        (*All indices except the one we entered with*)
        otherIndices = DeleteCases[makePosIdx /@ curPos[[2]], entryIdx
            ];
        otherIndices = Intersection[otherIndices, closedIndices];
        FunKitDebug[4, "Found outgoing indices: ", otherIndices];
        (*all objects containing the otherIndices*)
        followObjects = Table[Select[DeleteCases[allObj, curPos], MemberQ[
            #[[2]], otherIndices[[i]], Infinity]&][[1]], {i, 1, Length[otherIndices
            ]}];
        FunKitDebug[3, "Found followObjects: ", followObjects];
        Return[{otherIndices, followObjects}]
    ];



(* ::Input::Initialization:: *)
(*maximum accepted loop length.*)

$MaxIterLoop = 100;

TermsEqualAndSum::exceededLoopLimit = "Exceeded the maximum allowed length of a loop! (" <>
     ToString[$MaxIterLoop] <> ")";

TermsEqualAndSum::branchFailure = "Arrived at unhandled branch point";

TermsEqualAndSum[setup_, t1_, t2_, MallObjt1_, cidxt1_, oidxt1_, Mmemory1_,
     entry1_, MallObjt2_, cidxt2_, oidxt2_, Mmemory2_, entry2_, Msign2_] :=
    Module[{allObjt1 = MallObjt1, curIdx1, curPos1, nextInd1, nextPos1,
         memory1 = Mmemory1, assocFields1, allObjt2 = MallObjt2, curIdx2, curPos2,
         nextInd2, nextPos2, memory2 = Mmemory2, assocFields2, sign2 = Msign2,
         iter = 1, idx, jdx, viableBranches, branchSign, branchItRepl, branchObj,
         temp1, temp2},
        FunKitDebug[3, "Following along a chain of indices."];
        curIdx1 = makePosIdx @ entry1;
        curIdx2 = makePosIdx @ entry2;
        curPos1 = memory1[[-1]];
        curPos2 = memory2[[-1]];
        While[
            iter < $MaxIterLoop
            ,
            (*Take a single step forward in the terms*)
            {nextInd1, nextPos1} = IterateDiagram[setup, allObjt1, cidxt1,
                 oidxt1, curPos1, curIdx1];
            {nextInd2, nextPos2} = IterateDiagram[setup, allObjt2, cidxt2,
                 oidxt2, curPos2, curIdx2];
            (*If the (set of) next object(s) is different for 1 and 2, we can immediately abort.
                *)
            If[Sort @ Map[Head[#][Sort[#[[1]]]]&, nextPos1] =!= Sort 
                @ Map[Head[#][Sort[#[[1]]]]&, nextPos2],
                FunKitDebug[3, "FAILURE ------------ Heads do not match: ",
                     nextPos1, ", ", nextPos2];
                Return[{False, allObjt2}]
            ];
            (*Check if the external indices in the current object match
                *)
            If[Intersection[oidxt1, makePosIdx /@ (curPos1[[2]])] =!=
                 Intersection[oidxt2, makePosIdx /@ (curPos2[[2]])],
                FunKitDebug[3, "FAILURE ------------ Current open indices disagree: ",
                     Intersection[oidxt1, makePosIdx /@ (curPos1[[2]])], ", ", Intersection[
                    oidxt2, makePosIdx /@ (curPos2[[2]])]];
                Return[{False, allObjt2}]
            ];
            FunKitDebug[3, "Next objects along the chain: ", nextPos1,
                 ", ", nextPos2];
            FunKitDebug[3, "Entering through: ", nextInd1, ", ", nextInd2
                ];
            (*Case 1: There is only a single object following*)
            If[Length[nextInd1] === 1,
                FunKitDebug[3, "Following the index chain."];
                (*Check if the open indices aggree*)
                If[Sort @ Intersection[oidxt1, makePosIdx /@ nextPos1
                    [[1, 2]]] =!= Sort @ Intersection[oidxt2, makePosIdx /@ nextPos2[[1, 
                    2]]],
                    FunKitDebug[3, "FAILURE ------------ Next open indices disagree.",
                         Sort @ Intersection[oidxt1, makePosIdx /@ nextPos1[[1, 2]]], ", ", Sort
                         @ Intersection[oidxt2, makePosIdx /@ nextPos2[[1, 2]]]];
                    Return[{False, allObjt2}]
                ];
                (*fix the current object*)
                {temp1, temp2} = RearrangeFields[setup, curPos1, curPos2,
                     {nextInd1[[1]], nextInd2[[1]]}];
                sign2 = sign2 * temp1;
                allObjt2 = allObjt2 /. curPos2 -> temp2;
                memory2 = memory2 /. curPos2 -> temp2;
                curPos2 = temp2;
                (*fix the next object*)
                {temp1, temp2} = RearrangeFields[setup, nextPos1[[1]],
                     nextPos2[[1]], {nextInd1[[1]], nextInd2[[1]]}];
                sign2 = sign2 * temp1;
                allObjt2 = allObjt2 /. nextPos2[[1]] -> temp2;
                memory2 = memory2 /. nextPos2[[1]] -> temp2;
                nextPos2[[1]] = temp2;
                (*Check if we closed a loop*)
                If[FirstPosition[memory1, nextPos1[[1]]] === FirstPosition[
                    memory2, nextPos2[[1]]] && NumericQ[FirstPosition[memory1, nextPos1[[
                    1]]][[1]]],
                    FunKitDebug[3, "SUCCESS ------------ Closed a loop."
                        ];
                    Return[{sign2, allObjt2}]
                ];
                (*Closed one loop, but not the other*)
                If[FirstPosition[memory1, nextPos1[[1]]] =!= FirstPosition[
                    memory2, nextPos2[[1]]],
                    FunKitDebug[3, "FAILURE ------------ Closed only one loop."
                        ];
                    Return[{False, allObjt2}]
                ];
                (*step forward*)
                curIdx1 = nextInd1[[1]];
                curPos1 = nextPos1[[1]];
                curIdx2 = nextInd2[[1]];
                curPos2 = nextPos2[[1]];
                (*update the memory*)
                AppendTo[memory1, curPos1];
                AppendTo[memory2, curPos2];
                iter++;
                Continue[];
            ];
            (*Case 2: End of the line.*)
            If[Length[nextInd1] === 0,
                FunKitDebug[4, "Finished an index chain in (", curPos1,
                     ", ", curPos2, ")"];
                (*We need to check if both expressions are with FDOps
                    *)
                If[Head @ curPos1 === Field,
                    temp1 = Cases[t1, FDOp[curPos1[[1, 1]][curPos1[[2,
                         1]]]], Infinity];
                    temp2 = Cases[t2, FDOp[curPos2[[1, 1]][curPos2[[2,
                         1]]]], Infinity];
                    If[Length[temp1] =!= Length[temp2],
                        FunKitDebug[3, "FAILURE ------------ Number of FDOps is different."
                            ];
                        Return[{False, allObjt2}]
                    ];
                ];
                FunKitDebug[3, "SUCCESS ------------ Index chain ended with equality."
                    ];
                Return[{sign2, allObjt2}]
            ];
            (*Case 3: Branching point.*)
            If[Length[nextInd1] > 1,
                FunKitDebug[3, "Index chain is branching."];
                (*We need to build all possible combinations between the "next" indices and follow these separately, until one of them fits.
                    *)
                assocFields1 = curPos1[[1, FirstPosition[curPos1[[2]],
                     #][[1]]]]& /@ nextInd1;
                assocFields2 = curPos2[[1, FirstPosition[curPos2[[2]],
                     #][[1]]]]& /@ nextInd2;
                viableBranches = Map[Transpose[{Transpose @ {nextInd1,
                     assocFields1, nextPos1}, #}]&, Permutations[Transpose @ {nextInd2, assocFields2,
                     nextPos2}]];
                viableBranches = Select[viableBranches, AllTrue[#, (#
                    [[1, 2]] === #[[2, 2]])&]&];
                FunKitDebug[4, "Viable Branches: ", viableBranches];
                For[idx = 1, idx <= Length[viableBranches], idx++,
                    branchSign = sign2;
                    branchObj = allObjt2;
                    Do[
                        (*Fix the outgoing objects*){branchSign, branchItRepl
                            } = RearrangeFields[setup, curPos1, curPos2, viableBranches[[idx, jdx,
                             All, 1]]];
                        (*Fix the incoming objects*)
                        {temp1, temp2} = RearrangeFields[setup, viableBranches
                            [[idx, jdx, 1, 3]], viableBranches[[idx, jdx, 2, 3]], viableBranches[[
                            idx, jdx, All, 1]]];
                        branchSign = temp1 * branchSign;
                        branchObj = branchObj /. curPos2 -> branchItRepl
                            ;
                        branchObj = branchObj /. viableBranches[[idx,
                             jdx, 2, 3]] -> temp2;
                        viableBranches[[idx, jdx, 2, 3]] = temp2;
                        FunKitDebug[4, "Branching at ", branchObj];
                        {branchSign, branchObj} = TermsEqualAndSum[setup,
                             t1, t2, allObjt1, cidxt1, oidxt1, Append[memory1, viableBranches[[idx,
                             jdx, 1, 3]]], viableBranches[[idx, jdx, 1, 1]], branchObj, cidxt2, oidxt2,
                             Append[memory2 /. curPos2 -> branchItRepl, viableBranches[[idx, jdx,
                             2, 3]]], viableBranches[[idx, jdx, 2, 1]], branchSign];
                        If[branchSign === False,
                            Break[]
                        ];
                        ,
                        {jdx, 1, Length[viableBranches[[idx]]]}
                    ];
                    If[branchSign === False,
                        Continue[]
                    ];
                    FunKitDebug[3, "SUCCESS ------------ Branch ", idx,
                         " succeeded, branchSign is ", branchSign];
                    Return[{branchSign, branchObj}];
                ];
                FunKitDebug[3, "FAILURE ------------ Branch failed."]
                    ;
                Return[{False, allObjt2}];
            ];
            (*Nothing should lead here*)
            Message[TermsEqualAndSum::branchFailure];
            Abort[];
        ];
        (*Nothing should lead here*)
        Message[TermsEqualAndSum::exceededLoopLimit];
        Abort[];
    ];



(* ::Input::Initialization:: *)
(*re-order the fields in an indexed object t2 so that it fits the order in t1. Returns both the sign and the reordered t2*)

RearrangeFields[setup_, t1_, t2_, equiv_] :=
    Module[{ipos1, ipos2, idx, sign, newt2},
        ipos1 = FirstPosition[makePosIdx /@ t1[[2]], equiv[[1]]][[1]]
            ;
        ipos2 = FirstPosition[makePosIdx /@ t2[[2]], equiv[[2]]][[1]]
            ;
        (*nothing to do:*)
        If[ipos1 === ipos2,
            Return[{1, t2}]
        ];
        sign =
            If[ipos2 > ipos1,
                (*commute pos2 backwards*)
                Table[FMinus[{t2[[1, ipos2]], t2[[1, ipos2 - idx]]}, 
                    {t2[[2, ipos2]], t2[[2, ipos2 - idx]]}], {idx, 1, ipos2 - ipos1}]
                ,
                (*commute pos2 forwards*)
                Table[FMinus[{t2[[1, ipos2]], t2[[1, ipos2 + idx]]}, 
                    {t2[[2, ipos2]], t2[[2, ipos2 + idx]]}], {idx, 1, ipos1 - ipos2}]
            ];
        (*Resolve the resulting FMinus, if possible*)
        sign = Times @@ ReduceIndices[setup, FTerm @@ sign];
        (*Replace the indices & fields in t2*)
        newt2 = Head[t2][Insert[Delete[t2[[1]], ipos2], t2[[1, ipos2]],
             ipos1], Insert[Delete[t2[[2]], ipos2], t2[[2, ipos2]], ipos1]];
        Return[{sign, newt2}];
    ];



(* ::Input::Initialization:: *)
TermsEqualAndSum::undeterminedFields = "Error: Cannot equate terms if they are not fully truncated, i.e. contain instances of AnyField.";

TermsEqualAndSum[setup_, it1_FTerm, it2_FTerm] :=
    Module[
        {t1 = ReduceIndices[setup, it1], t2 = ReduceIndices[setup, it2
            ], startPoints, doFields, allObjt1, allObjt2, cidxt1, cidxt2, oidxt1,
             oidxt2, startt1, startt1fields, cidxstartt1, startt2, nstartt2, startt2fields,
             cidxstartt2, branchAllObjt2, idx, jdx, equal = False, startsign, a, 
            factor, removeOther}
        ,
        (*If[MemberQ[t1,AnyField,Infinity],Message[TermsEqualAndSum::undeterminedFields];Abort[]];
            *)
        (*Briefly check the trivial case*)
        If[it1 === it2,
            Return @ FTerm[2, t1]
        ];
        If[t1[[2 ;; ]] === t2[[2 ;; ]],
            Return @ FTerm[t1[[1]] + t2[[1]], t1[[2 ;; ]]]
        ];
        If[t1[[2 ;; ]] === t2[[1 ;; ]],
            Return @ FTerm[t1[[1]] + 1, t1[[2 ;; ]]]
        ];
        If[t1[[1 ;; ]] === t2[[2 ;; ]],
            Return @ FTerm[1 + t2[[1]], t2[[2 ;; ]]]
        ];
        (*Get all the possible starting points for the search*)
        startPoints = StartPoints[setup, t1, t2];
        If[Not[startPoints[[1]]],
            Return[False]
        ];
        FunKitDebug[4, "Collected StartPoints"];
        doFields = replFields[setup];
        (*collect objects for both terms*)
        allObjt1 = Select[ExtractObjectsWithIndex[setup, t1] /. doFields,
             FreeQ[FMinus[__]]];
        allObjt2 = Select[ExtractObjectsWithIndex[setup, t2] /. doFields,
             FreeQ[FMinus[__]]];
        cidxt1 = GetClosedSuperIndices[setup, t1];
        cidxt2 = GetClosedSuperIndices[setup, t2];
        oidxt1 = GetOpenSuperIndices[setup, t1];
        oidxt2 = GetOpenSuperIndices[setup, t2];
        (*We pick the first candidate for t1 and iterate over all candidates for t2.
            *)
        startt1 = startPoints[[2, 1]];
        (*starting indices can only be closed indices! We pick these out with the following 4 commands
            *)
        startt1fields = startt1[[1]];
        cidxstartt1 = Map[MemberQ[cidxt1, makePosIdx @ #]&, startt1[[
            2]]];
        startt1fields = Pick[startt1fields, cidxstartt1];
        cidxstartt1 = makePosIdx /@ Pick[startt1[[2]], cidxstartt1];
        (*Sanity check*)
        If[Length[cidxstartt1] === 0,
            Return[False]
        ];
        FunKitDebug[3, "Comparing the terms \n  ", t1, "\n  ", t2];
        (*If the terms are equal for any starting candidates for t2, we have succeeded
            *)
        For[idx = 1, idx <= Length[startPoints[[3]]], idx++,
            (*We need to identify all possible insertion points in t2 that fit the insertion in t1
                *)startt2 = startPoints[[3, idx]];
            (*starting indices can only be 1. closed indices 2. have same field content as the starting point in t1. We pick these out with the following 2 commands
                *)
            cidxstartt2 = Map[(MemberQ[cidxt2, #[[1]]] && #[[2]] === 
                startt1fields[[1]])&, Transpose[{makePosIdx /@ startt2[[2]], startt2[[
                1]]}]];
            cidxstartt2 = Pick[makePosIdx /@ startt2[[2]], cidxstartt2
                ];
            (*Loop over all possible starting indices*)
            For[jdx = 1, jdx <= Length[cidxstartt2], jdx++,
                (*re-order the starting point so that it fits the first.
                    *){startsign, nstartt2} = RearrangeFields[setup, startt1, startt2, {cidxstartt1
                    [[1]], cidxstartt2[[jdx]]}];
                FunKitDebug[3, "Starting sign: ", startsign];
                branchAllObjt2 = allObjt2 /. startt2 -> nstartt2;
                (*iterate the diagram*)
                FunKitDebug[3, "StartPoints: \n  ", startt1, "\n  ", 
                    nstartt2];
                FunKitDebug[3, "StartIndices: \n  ", cidxstartt1[[1]],
                     "\n  ", cidxstartt2[[jdx]]];
                {equal, branchAllObjt2} = TermsEqualAndSum[setup, t1,
                     t2, allObjt1, cidxt1, oidxt1, {startt1}, cidxstartt1[[1]], branchAllObjt2,
                     cidxt2, oidxt2, {nstartt2}, cidxstartt2[[jdx]], startsign];
                FunKitDebug[3, "Finished pass ", jdx " with equal=", 
                    equal];
                (*If we found an equality, break out*)
                If[equal =!= False,
                    Break[]
                ];
            ];
            If[equal =!= False,
                Break[]
            ];
        ];
        (*If equal===False, the terms are clearly not equal*)
        If[equal === False,
            Return[False]
        ];
        FunKitDebug[3, "Found two equal terms"];
        removeOther = Dispatch[{Alternatives @@ Map[Blank, $allObjects
             \[Union] {FDOp}] -> 1, Alternatives @@ Map[Blank, GetAllFields[setup
            ] \[Union] {AnyField}] -> 1}];
        (*No need to do any ordering if there are no explicit Grassmanns in the expression
            *)
        If[GrassmannCount[setup, t1] === 0,
            factor = (equal * Times @@ (t2 /. removeOther) + Times @@
                 (t1 /. removeOther)) / Times @@ (t1 /. removeOther);
            FunKitDebug[3, "With prefactor: ", factor];
            Return @ FTerm[factor, t1];
        ];
        Print["Could not resolve Grassmann factors"];
        Abort[];
        Return @ FTerm[standardOrderGrassmanns[t1][[1]] * standardOrderGrassmanns[
            t2][[1]] * (equal * (Times @@ t2) + (Times @@ t1)) / (Times @@ t1) /.
             Alternatives @@ Map[Blank, $allObjects \[Union] {FDOp}] -> 1 /. Alternatives
             @@ Map[Blank, GetAllFields[setup]] -> 1, t1];
    ];



(* ::Input::Initialization:: *)
FTermContent[setup_, term_FTerm] :=
    Module[{},
        Hash[Sort @ Map[Head[#][#[[1]]]&, FunKit`Private`ExtractObjectsWithIndex[
            setup, term] /. FunKit`Private`replFields[setup]], "SHA"]
    ];



(* ::Input::Initialization:: *)
SeparateTermGroups[setup_, expr_FEx] :=
    Module[
        {ret = List @@ expr, identifierRep, removeFirsts, groupedDiagrams
            }
        ,
(*We group all diagrams into groups that could be potentially identical.
    
We simply make sure that in each group all diagrams have the same objects.
    *)
        identifierRep = Map[FTermContent[setup, #]&, ret];
        identifierRep = Thread[{identifierRep, ret}];
        removeFirsts[ex_] := Map[#[[2]]&, ex];
        groupedDiagrams = (FEx @@ #)& /@ Map[removeFirsts, GatherBy[identifierRep,
             #[[1]]&]];
        FunKitDebug[2, "Separated into ", Length[groupedDiagrams], " groups."
            ];
        Return[groupedDiagrams]
    ];



(* ::Input::Initialization:: *)
SubFSimplify[setup_, expr_FEx] :=
    Module[{ret = List @@ expr, idx, jdx, red},
        For[idx = 1, idx <= Length[ret], idx++,
            For[jdx = idx + 1, jdx <= Length[ret], jdx++,
                red = TermsEqualAndSum[setup, ret[[idx]], ret[[jdx]]]
                    ;
                If[red =!= False,
                    ret[[idx]] = red;
                    ret = Delete[ret, jdx];
                    jdx--;
                ];
            ];
        ];
        Return[FEx @@ ret];
    ];



(* ::Input::Initialization:: *)
BuildSymmetryList[setup_, symmetries_, derivativeList_] :=
    Module[{procDerList, buildOneSymmetry},
        If[Head[symmetries] =!= List,
            Print["Symmetries must be given as a list!"];
            Abort[]
        ];
        If[Length[symmetries] == 0,
            Return[{}]
        ];
        If[Length[derivativeList] == 0,
            Return[{}]
        ];
        procDerList = derivativeList /. unreplFields[setup];
        buildOneSymmetry[sym_] :=
            Module[{valid = True, buildCycle, pairs},
                If[AnyTrue[sym[[ ;; -2]], Not[Head[#] === List]&],
                    valid = False
                ];
                pairs = Subsets[sym[[ ;; -2]], {2}];
                valid = Not @ AnyTrue[Map[ContainsAny[#[[1]], #[[2]]]&,
                     pairs], Identity];
                If[Not @ valid,
                    Print[sym, " is  not a valid symmetry!"];
                    Abort[]
                ];
                buildCycle[cyc_] :=
                    Module[{cycvalid = True, numberRules, idx, nextIdx
                        },
                        If[AnyTrue[cyc, Not[IntegerQ[#]]&],
                            cycvalid = False
                        ];
                        If[AnyTrue[cyc, (# > Length[derivativeList]) 
                            || (# < 1)&],
                            cycvalid = False
                        ];
                        If[Not @ cycvalid,
                            Print[cyc, " is  not a valid cycle!"];
                            Abort[]
                        ];
                        numberRules = {};
                        For[idx = 1, idx <= Length[cyc], idx++,
                            nextIdx = Mod[(idx), Length[cyc]] + 1;
                            numberRules = Join[numberRules, {{cyc[[idx
                                ]], cyc[[nextIdx]]}}];
                        ];
                        Return[Map[procDerList[[#[[1]], 1]] -> procDerList
                            [[#[[2]], 1]]&, numberRules]];
                    ];
                <|"Rule" -> Flatten[Map[buildCycle, sym[[ ;; -2]]], 1
                    ], "Factor" -> sym[[-1]]|>
            ];
        Return @ Join[{<|"Rule" -> {}, "Factor" -> 1|>}, Map[buildOneSymmetry,
             symmetries /. Cycles -> Identity]];
    ];

SubFSimplify[setup_, expr_FEx, symmetryList_] :=
    Module[{ret = List @@ expr, idx, jdx, kdx, red},
        For[idx = 1, idx <= Length[ret], idx++,
            For[jdx = idx + 1, jdx <= Length[ret], jdx++,
                For[kdx = 1, kdx <= Length[symmetryList], kdx++,
                    red = symmetryList[[kdx, Key["Factor"]]] * TermsEqualAndSum[
                        setup, ret[[idx]], ret[[jdx]] /. symmetryList[[kdx, Key["Rule"]]]];
                    If[red =!= False,
                        ret[[idx]] = red;
                        ret = Delete[ret, jdx];
                        jdx--;
                        kdx = Length[symmetryList] + 1;
                    ];
                ];
            ];
        ];
        Return[FEx @@ ret];
    ];

FSimplifyNoSym[setup_, expr_FEx] :=
    Module[{subGroups, res},
        FunKitDebug[1, "Simplifying diagrammatic expression of length ",
             Length[expr]];
        subGroups = SeparateTermGroups[setup, expr];
        res = FEx @@ ParallelMap[SubFSimplify[setup, #]&, subGroups];
            
        FunKitDebug[1, "FTerms before: ", Length[expr], ", after: ", 
            Length[res]];
        Return[res];
    ];

Options[FSimplify] = {"Symmetries" -> {}};

FSimplify[setup_, expr_FEx, OptionsPattern[]] :=
    Module[{subGroups, res, symmetryList},
        If[OptionValue["Symmetries"] === {},
            Return[FSimplifyNoSym[setup, expr]]
        ];
        FunKitDebug[1, "Simplifying diagrammatic expression of length ",
             Length[expr], "with symmetry list"];
        subGroups = SeparateTermGroups[setup, expr];
        symmetryList = BuildSymmetryList[setup, OptionValue["Symmetries"
            ][[1]], AnyField[#]& /@ OptionValue["Symmetries"][[2]]];
        res = FEx @@ ParallelMap[SubFSimplify[setup, #, symmetryList]&,
             subGroups];
        FunKitDebug[1, "FTerms before: ", Length[expr], ", after: ", 
            Length[res]];
        Return[res];
    ];



(* ::Section::Closed:: *)
(*End Private*)


End[];
