(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

(* ::Input::Initialization:: *)
SetLoopMomentumName::usage="";

FRoute::usage="";

FUnroute::usage="";

FSimplify::usage="";

loopMomentum::usage;


Begin["`Private`"];


(* ::Input::Initialization:: *)
FRoute[expr_FEq]/;Head[$GlobalSetup]=!=Symbol:=FRoute[$GlobalSetup,expr];

FUnroute[expr_]/;Head[$GlobalSetup]=!=Symbol:=FUnroute[$GlobalSetup,expr];

FSimplify[expr_FEq]/;Head[$GlobalSetup]=!=Symbol:=FSimplify[$GlobalSetup,expr];
FSimplify[expr_FEq,OptionsPattern[]]/;Head[$GlobalSetup]=!=Symbol:=FSimplify[$GlobalSetup,expr,(Sequence@@Thread[Rule@@{#,OptionValue[FSimplify,#]}]&@Keys[Options[FSimplify]])];


(* ::Input::Initialization:: *)
ModuleLoaded::dependency="The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit]=!=True,
Message[ModuleLoaded::dependency,"AnSEL","FunKit"];
Abort[];
];

If[ModuleLoaded[FEDeriK]=!=True,
Message[ModuleLoaded::dependency,"AnSEL","FEDeriK"];
Abort[];
];

ModuleLoaded[AnSEL]=True;


(* ::Input::Initialization:: *)
SetLoopMomentumName[name_String]:=Module[{},
If[StringQ[$loopMomentumName],
Unprotect@@Table[$loopMomentumName<>ToString[idx],{idx,1,50}]
];
$loopMomentumName=name;
ClearAll@@Table[$loopMomentumName<>ToString[idx],{idx,1,50}];
Protect@@Table[$loopMomentumName<>ToString[idx],{idx,1,50}];
Unprotect[$availableLoopMomenta];
$availableLoopMomenta:=Table[Symbol[$loopMomentumName<>ToString[idx]],{idx,1,50}];
Protect[$availableLoopMomenta];
];
SetLoopMomentumName["l"];


(* ::Input::Initialization:: *)
(*A convenience function to quickly obtain the index structure of a given field.*)
FieldSetupIndices[setup_,field_]:=Module[{},
List@@SelectFirst[
Flatten@Values[setup["FieldSpace"]],
Head[#]===field&
]
];


(* ::Input::Initialization:: *)
FRoute::undeterminedFields="Cannot route indices in expressions with undetermined fields.";
FRoute::momentaFailed="Cannot route momenta in the given expression. Final momentum conservation read `1`";
FRoute::conservationFail="Momentum conservation could not be fulfilled. Error in `1`";

FRoute[setup_,expr_FTerm]:=Module[
{openIndices,closedIndices,objects,
ret=ReduceFTerm[setup,ReduceIndices[setup,expr]],doFields,idx,a,
indPos,assocField,subObj,subMom,subExtMom,
indStruct,externalIndices,externalMomenta,
f,momRepl,i,mom,loopMomenta,sidx,discard
},
FunKitDebug[1,"FRoute: routing the sub-term ",expr];

(*We first get all closed, open indices and all indexed objects.*)
doFields=replFields[setup];
openIndices=Sort@GetOpenSuperIndices[setup,ret];
closedIndices=GetClosedSuperIndices[setup,ret];
objects=ExtractObjectsWithIndex[setup,ret]//.doFields;

(*If there are any undetermined fields, we cannot route indices.*)
If[MemberQ[objects[[All,1]],AnyField,{1,4}],Message[FRoute::undeterminedFields];Abort[]];

(*As a first step, we insert the correct index structures into all superindices and define momentum variables at every single vertex.
We loop over all closed indices.*)
Do[
(*The indexed object we currently modify. There are always two and we simply grab the first.*)
subObj=Select[objects,MemberQ[#,closedIndices[[idx]],Infinity]&][[1]];
(*The position of the current index inside the subObj*)
indPos=FirstPosition[subObj[[2]],closedIndices[[idx]]][[1]];
(*See what kind of field is associated with the index*)
assocField=subObj[[1,indPos]];
(*Grab the index structure of this field from the setup and assign a new momentum variable*)
indStruct=Map[If[MatchQ[#,_Symbol],Unique[SymbolName[#]],#]&,FieldSetupIndices[setup,assocField],{1,3}];
indStruct[[1]]=loopMomentum[indStruct[[1]]];

(*replace all occurences of the superindex with the fitting index structure. 
We want to keep the index sign in the momenta, but remove it from the group indices*)
ret=ret/.closedIndices[[idx]]->indStruct;
objects=objects/.closedIndices[[idx]]->indStruct;
If[Length[indStruct]>1,
ret=ret/.(-indStruct[[2]])->indStruct[[2]];
objects=objects/.(-indStruct[[2]])->indStruct[[2]];
];

,{idx,1,Length[closedIndices]}];


(*Next, we treat the external superindices. We assign to each an open group structure and a new momentum p1,p2,... 
Momentum conservation is already enforced here, i.e. \!\(
\*SubscriptBox[\(\[Sum]\), \(i\)]
\*SubscriptBox[\(p\), \(i\)]\)=0 and we choose Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]\(
\*SubscriptBox[\(p\), \(i\)]\ for\ the\ last\ momentum\ \(
\*SubscriptBox[\(p\), \(n\)]\(.\)\)\)\)*)
externalIndices=Table[{},{idx,1,Length[openIndices]}];
Do[
(*see above*)
subObj=Select[objects,MemberQ[#,openIndices[[idx]],Infinity]&][[1]];
indPos=FirstPosition[subObj[[2]],openIndices[[idx]]][[1]];
assocField=subObj[[1,indPos]];
indStruct=Map[If[MatchQ[#,_Symbol],Symbol[SymbolName[#]<>ToString[idx]],#]&,FieldSetupIndices[setup,assocField],{1,3}];

(*Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]
\*SubscriptBox[\(p\), \(i\)]\)*)
If[idx===Length[openIndices],indStruct[[1]]=-Total[Values[externalIndices][[;;idx-1,1]]]];

ret=ret/.(-openIndices[[idx]])->indStruct;
ret=ret/.(openIndices[[idx]])->indStruct;
objects=objects/.(-openIndices[[idx]])->indStruct;
objects=objects/.openIndices[[idx]]->indStruct;

(*This is information for the user, which we will return.*)
externalIndices[[idx]]=openIndices[[idx]]->indStruct;

,{idx,1,Length[openIndices]}];

(*extract a list of all new external momenta*)
externalMomenta=Values[externalIndices][[All,1]];

FunKitDebug[2,"FRoute: Determined external momenta as ",externalMomenta];

(*Now, we do the momentum routing.*)
Do[
subObj=objects[[idx]];
subMom=subObj[[2,All,1]];
(*See if the object has any external (sub-)momenta*)
subExtMom=Select[subMom,(ContainsAny[externalMomenta,makePosIdx/@Flatten[{#/.Plus[a_,b__]:>List[a,b]}]])&];

FunKitDebug[3,"FRoute: routing the object ",subObj];

(*if momentum conservation is already fulfilled, do nothing*)
If[Total@subMom===0,Continue[]];

(*Case 1: we have no external momentum anywhere in the legs of the current object*)
If[Length[subExtMom]===0,
(*If we have nothing to enforce, skip this object*)
If[Length[subObj[[2,All,1]]]<2,Continue[]];
(*for safety, we try to route our momenta through fermions. At 1-loop this is irrelevant, at n-loop it is not.*)
f=FirstPosition[IsFermion[setup,#]&/@subObj[[1]],True][[1]];
If[f==="NotFound",f=1];

mom=makePosIdx@Select[Flatten[{subObj[[2,f,1]]//.{Plus[a_,b__]:>List[a,b],Times[a_loopMomentum,b__]:>List[a,b]}}],(MatchQ[#,loopMomentum[_]]||MatchQ[-#,loopMomentum[_]])&][[1]];

momRepl=Solve[Total[subObj[[2,All,1]]]==0,mom][[1,1]];

objects=objects/.momRepl;
ret=ret/.momRepl;

FunKitDebug[3,"FRoute: routing a momentum as ",momRepl];

Continue[];
];

(*Case 2*)
If[Length[subExtMom]<=Length[subMom],

(*discard helps us to iterate thorugh momentum arguments. sidx iterates through the loopMomenta contained in each momenum argument*)
discard[_]=False;
sidx=0;
While[sidx<1000,
sidx++;
(*for safety, we try to route our momenta through fermions.*)
f=FirstPosition[
Table[
(IsFermion[setup,subObj[[1,i]]]&&MemberQ[makePosIdx/@Flatten[{subObj[[2,i,1]]/.Plus[a_,b__]:>List[a,b]}],loopMomentum[__]]&&Not@discard[i])
,{i,1,Length[subObj[[1]]]}]
,True][[1]];

(*If no fermions are present, simply grab the index which does not contain external momenta.*)
If[f==="NotFound",
f=FirstPosition[
Table[MemberQ[makePosIdx/@Flatten[{subObj[[2,i,1]]/.Plus[a_,b__]:>List[a,b]}],loopMomentum[__]]&&Not@discard[i]
,{i,1,Length[subObj[[1]]]}]
,True][[1]]; 

(*The only other possibility is that all momenta are external. In that case, we do nothing but check consistency.*)
If[f==="NotFound",Break[];];
];

(*Extract all loop momenta*)
mom=makePosIdx/@Select[Flatten[{subObj[[2,f,1]]/.Plus[a_,b__]:>List[a,b]}],(MatchQ[#,loopMomentum[_]]||MatchQ[-#,loopMomentum[_]])&];
If[sidx>Length[mom],
discard[f]=True;
sidx=0;
Continue[];
];

mom=mom[[sidx]];
(*If the momentum is already routed through, ignore it (e.g. p in Propagator[{...},{-p+..., p+...}])*)
If[Not@MemberQ[{Total[subObj[[2,All,1]]]},mom,Infinity],
Continue[];
];

(*if we were not stopped, we got it*)
Break[];
];

(*The only other possibility is that all momenta are external. In that case, we do nothing but check consistency.*)
If[f==="NotFound",
If[Total@subObj[[2,All,1]]=!=0,Message[FRoute::conservationFail,subObj];Abort[];];
Continue[]
];

momRepl=Solve[Total[subObj[[2,All,1]]]==0,mom][[1,1]];

objects=objects/.momRepl;
ret=ret/.momRepl;

FunKitDebug[3,"FRoute: routing a momentum as ",momRepl];

Continue[];
];

,{idx,1,Length[objects]}];

(*Sanity check to see that we did not make an error*)
Do[
subObj=objects[[idx]];
(*Skip again Fields and such*)
If[Length[subObj[[2,All,1]]]<2,Continue[]];
(*Check the conservation of momentum at all vertices*)
If[Total[subObj[[2,All,1]]]=!=0,Message[FRoute::momentaFailed,Total[subObj[[2,All,1]]]];Abort[]];
,{idx,1,Length[objects]}];

(*replace the loopMomenta[...] by l1, l2, ...*)
loopMomenta=Cases[objects[[All,2,1]],loopMomentum[_],Infinity]//DeleteDuplicates;
ret=ret/.Thread[loopMomenta->Table[Symbol[$loopMomentumName<>ToString[idx]],{idx,1,Length[loopMomenta]}]];
loopMomenta=loopMomenta/.Thread[loopMomenta->Table[Symbol[$loopMomentumName<>ToString[idx]],{idx,1,Length[loopMomenta]}]];

Return[<|
"Expression"->FEq[ret],
"ExternalIndices"->Sort@externalIndices,
"LoopMomenta"->Sort@loopMomenta
|>];
];

FRoute[setup_,expr_FEq]:=Module[{results,ret,idx,subidx},
results=FRoute[setup,#]&/@(List@@expr);
results=GatherBy[results,Length[#["LoopMomenta"]]&];
results=Map[<|
"Expression"->FEq@@#[[All,Key["Expression"]]],
"ExternalIndices"->#[[1,Key["ExternalIndices"]]],
"LoopMomenta"->S #[[1,Key["LoopMomenta"]]]
|>&,results];
results=Association@@Map[ToString[Length[#["LoopMomenta"]]]~~"-Loop"->#&,results];
Return[results];
];



(* ::Input::Initialization:: *)
isLoopAssociation[expr_]:=Module[{},
If[Head[expr]=!=Association,Return[False]];
If[FreeQ[Keys[expr],"Expression"],Return[False]];
If[FreeQ[Keys[expr],"ExternalIndices"],Return[False]];
If[FreeQ[Keys[expr],"LoopMomenta"],Return[False]];
Return[True];
];
isRoutedAssociation[expr_]:=Module[{},
If[Head[expr]=!=Association,Return[False]];
Return@AllTrue[expr,isLoopAssociation]
];


(* ::Input::Initialization:: *)
FUnroute[setup_,assoc_Association]/;isLoopAssociation[assoc]:=Module[{},
Return@FUnroute[assoc["Expression"]/.Map[#[[2]]->#[[1]]&,assoc["ExternalIndices"]]];
];
FUnroute[setup_,assoc_Association]/;isRoutedAssociation[assoc]:=FEq@@(FUnroute[setup,#]&/@(List@@assoc));
FUnroute[setup_,term_FEq]:=FUnroute[setup,#]&/@term;
FUnroute[setup_,term_FTerm]:=Module[{fw,bw},
{fw,bw}=GetSuperIndexTermTransformations[setup,term];
Return[term//fw];
];


(* ::Input::Initialization:: *)
(*Get viable starting points for a comparison of two diagrams*)
StartPoints[setup_,t1_FTerm,t2_FTerm]:=Module[
{obj1,obj2,count,
desired,sList,
match1,match2,
cidx1,cidx2,
doFields},
doFields=replFields[setup];

(*Get all sub-objects inside the terms*)
obj1=Reverse@Sort@ExtractObjectsWithIndex[setup,t1]/.doFields;
obj2=Reverse@Sort@ExtractObjectsWithIndex[setup,t2]/.doFields;

(*If the objects (with field content) do not match, they are not identical.*)
If[
Sort@Map[Head[#][Sort@#[[1]]]&,obj1]=!=Sort@Map[Head[#][Sort@#[[1]]]&,obj2],
Return[{False,Null,Null}]
];

cidx1=GetClosedSuperIndices[setup,t1];
cidx2=GetClosedSuperIndices[setup,t2];

If[Length[cidx1]=!=Length[cidx2],Return[{False,Null,Null}]];
(*
If[Length[cidx1]>0,
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
];*)

(*Otherwise, we check which object is the "rarest"*)
sList=Map[Head[#][#[[1]]]&,obj1];
count=Counts[sList];
desired=Keys[count][[PositionSmallest[Values[count]][[1]]]];
match1=Select[obj1,(Head[#][#[[1]]]===desired)&];
match2=Select[obj2,(Head[#][#[[1]]]===desired)&];

(*return all possible starting points *)
Return[{True,match1,match2}]
];


(* ::Input::Initialization:: *)
(*Find all objects following the closed indices attached to the object curPos*)
IterateDiagram[setup_Association,allObj_,closedIndices_,openIndices_,curPos_,entryIdx_]:=Module[
{otherIndices,followObjects,i},
FunKitDebug[4,"Inspecting: ",curPos];
(*All indices except the one we entered with*)
otherIndices=DeleteCases[makePosIdx/@curPos[[2]],entryIdx];
otherIndices=Intersection[otherIndices,closedIndices];
FunKitDebug[4,"Found outgoing indices: ",otherIndices];
(*all objects containing the otherIndices*)
followObjects=Table[
Select[DeleteCases[allObj,curPos],MemberQ[#[[2]],otherIndices[[i]],Infinity]&][[1]],
{i,1,Length[otherIndices]}];
FunKitDebug[3,"Found followObjects: ",followObjects];
Return[{otherIndices,followObjects}]
];


(* ::Input::Initialization:: *)
(*maximum accepted loop length.*)
$MaxIterLoop=100;
TermsEqualAndSum::exceededLoopLimit="Exceeded the maximum allowed length of a loop! ("<>ToString[$MaxIterLoop]<>")";
TermsEqualAndSum::branchFailure="Arrived at unhandled branch point";

TermsEqualAndSum[setup_,t1_,t2_,
MallObjt1_,cidxt1_,oidxt1_,Mmemory1_,entry1_,
MallObjt2_,cidxt2_,oidxt2_,Mmemory2_,entry2_,Msign2_
]:=Module[
{allObjt1=MallObjt1,curIdx1,curPos1,nextInd1,nextPos1,memory1=Mmemory1,assocFields1,
allObjt2=MallObjt2,curIdx2,curPos2,nextInd2,nextPos2,memory2=Mmemory2,assocFields2,sign2=Msign2,
iter=1,idx,jdx,viableBranches,branchSign,branchItRepl,branchObj,
temp1,temp2},

FunKitDebug[3,"Following along a chain of indices."];

curIdx1=makePosIdx@entry1;
curIdx2=makePosIdx@entry2;
curPos1=memory1[[-1]];
curPos2=memory2[[-1]];

While[iter<$MaxIterLoop,

(*Take a single step forward in the terms*)
{nextInd1,nextPos1}=IterateDiagram[setup,allObjt1,cidxt1,oidxt1,curPos1,curIdx1];
{nextInd2,nextPos2}=IterateDiagram[setup,allObjt2,cidxt2,oidxt2,curPos2,curIdx2];

(*If the (set of) next object(s) is different for 1 and 2, we can immediately abort.*)
If[Sort@Map[Head[#][Sort[#[[1]]]]&,nextPos1]=!=Sort@Map[Head[#][Sort[#[[1]]]]&,nextPos2],
FunKitDebug[3,"FAILURE ------------ Heads do not match: ",nextPos1,", ",nextPos2];
Return[{False,allObjt2}]
];
(*Check if the external indices in the current object match*)
If[Intersection[oidxt1,makePosIdx/@(curPos1[[2]])]=!=Intersection[oidxt2,makePosIdx/@(curPos2[[2]])],
FunKitDebug[3,"FAILURE ------------ Current open indices disagree: ",Intersection[oidxt1,makePosIdx/@(curPos1[[2]])],", ",Intersection[oidxt2,makePosIdx/@(curPos2[[2]])]];
Return[{False,allObjt2}]];

FunKitDebug[3,"Next objects along the chain: ",nextPos1,", ",nextPos2];
FunKitDebug[3,"Entering through: ",nextInd1,", ",nextInd2];

(*Case 1: There is only a single object following*)
If[Length[nextInd1]===1,
FunKitDebug[3,"Following the index chain."];

(*Check if the open indices aggree*)
If[Sort@Intersection[oidxt1,makePosIdx/@nextPos1[[1,2]]]=!=Sort@Intersection[oidxt2,makePosIdx/@nextPos2[[1,2]]],
FunKitDebug[3,"FAILURE ------------ Next open indices disagree.",Sort@Intersection[oidxt1,makePosIdx/@nextPos1[[1,2]]],", ",Sort@Intersection[oidxt2,makePosIdx/@nextPos2[[1,2]]]];
Return[{False,allObjt2}]];

(*fix the current object*)
{temp1,temp2}=RearrangeFields[setup,curPos1,curPos2,{nextInd1[[1]],nextInd2[[1]]}];
sign2=sign2*temp1;
allObjt2=allObjt2/.curPos2->temp2;
memory2=memory2/.curPos2->temp2;
curPos2=temp2;

(*fix the next object*)
{temp1,temp2}=RearrangeFields[setup,nextPos1[[1]],nextPos2[[1]],{nextInd1[[1]],nextInd2[[1]]}];
sign2=sign2*temp1;
allObjt2=allObjt2/.nextPos2[[1]]->temp2;
memory2=memory2/.nextPos2[[1]]->temp2;
nextPos2[[1]]=temp2;

(*Check if we closed a loop*)
If[FirstPosition[memory1,nextPos1[[1]]]===FirstPosition[memory2,nextPos2[[1]]]&&NumericQ[FirstPosition[memory1,nextPos1[[1]]][[1]]],
FunKitDebug[3,"SUCCESS ------------ Closed a loop."];
Return[{sign2,allObjt2}]];
(*Closed one loop, but not the other*)
If[FirstPosition[memory1,nextPos1[[1]]]=!=FirstPosition[memory2,nextPos2[[1]]],
FunKitDebug[3,"FAILURE ------------ Closed only one loop."];
Return[{False,allObjt2}]];

(*step forward*)
curIdx1=nextInd1[[1]];curPos1=nextPos1[[1]];
curIdx2=nextInd2[[1]];curPos2=nextPos2[[1]];

(*update the memory*)
AppendTo[memory1,curPos1];
AppendTo[memory2,curPos2];

iter++;
Continue[];
];

(*Case 2: End of the line.*)
If[Length[nextInd1]===0,
FunKitDebug[4,"Finished an index chain in (",curPos1,", ",curPos2,")"];
(*We need to check if both expressions are with FDOps*)
If[Head@curPos1===Field,
temp1=Cases[t1,FDOp[curPos1[[1,1]][curPos1[[2,1]]]],Infinity];
temp2=Cases[t2,FDOp[curPos2[[1,1]][curPos2[[2,1]]]],Infinity];
If[Length[temp1]=!=Length[temp2],
FunKitDebug[3,"FAILURE ------------ Number of FDOps is different."];
Return[{False,allObjt2}]
];
];

FunKitDebug[3,"SUCCESS ------------ Index chain ended with equality."];
Return[{sign2,allObjt2}]];

(*Case 3: Branching point.*)
If[Length[nextInd1]>1,
FunKitDebug[3,"Index chain is branching."];
(*We need to build all possible combinations between the "next" indices and follow these separately, until one of them fits.*)
assocFields1=curPos1[[1,FirstPosition[curPos1[[2]],#][[1]]]]&/@nextInd1;
assocFields2=curPos2[[1,FirstPosition[curPos2[[2]],#][[1]]]]&/@nextInd2;
viableBranches=Map[Transpose[{Transpose@{nextInd1,assocFields1,nextPos1},#}]&,Permutations[Transpose@{nextInd2,assocFields2,nextPos2}]];
viableBranches=Select[viableBranches,AllTrue[#,(#[[1,2]]===#[[2,2]])&]&];

FunKitDebug[4,"Viable Branches: ",viableBranches];

For[idx=1,idx<=Length[viableBranches],idx++,
branchSign=sign2;
branchObj=allObjt2;

Do[
(*Fix the outgoing objects*)
{branchSign,branchItRepl}=RearrangeFields[setup,curPos1,curPos2,viableBranches[[idx,jdx,All,1]]];

(*Fix the incoming objects*)
{temp1,temp2}=RearrangeFields[setup,viableBranches[[idx,jdx,1,3]],viableBranches[[idx,jdx,2,3]],viableBranches[[idx,jdx,All,1]]];

branchSign=temp1*branchSign;
branchObj=branchObj/.curPos2->branchItRepl;
branchObj=branchObj/.viableBranches[[idx,jdx,2,3]]->temp2;
viableBranches[[idx,jdx,2,3]]=temp2;

FunKitDebug[4,"Branching at ",branchObj];
{branchSign,branchObj}=TermsEqualAndSum[setup,t1,t2,
allObjt1,cidxt1,oidxt1,Append[memory1,viableBranches[[idx,jdx,1,3]]],viableBranches[[idx,jdx,1,1]],
branchObj,cidxt2,oidxt2,Append[memory2,viableBranches[[idx,jdx,2,3]]],viableBranches[[idx,jdx,2,1]],branchSign
];
If[branchSign===False,Break[]];
,{jdx,1,Length[viableBranches[[idx]]]}
];
If[branchSign===False,Continue[]];
FunKitDebug[3,"SUCCESS ------------ Branch ",idx," succeeded, branchSign is ",branchSign];
Return[{branchSign,branchObj}];
];

FunKitDebug[3,"FAILURE ------------ Branch failed."];
Return[{False,allObjt2}];
];

(*Nothing should lead here*)
Message[TermsEqualAndSum::branchFailure];
Abort[];
];

(*Nothing should lead here*)
Message[TermsEqualAndSum::exceededLoopLimit];Abort[];
];


(* ::Input::Initialization:: *)
(*re-order the fields in an indexed object t2 so that it fits the order in t1. Returns both the sign and the reordered t2*)
RearrangeFields[setup_,t1_,t2_,equiv_]:=Module[{ipos1,ipos2,idx,sign,newt2},
ipos1=FirstPosition[makePosIdx/@t1[[2]],equiv[[1]]][[1]];
ipos2=FirstPosition[makePosIdx/@t2[[2]],equiv[[2]]][[1]];

(*nothing to do:*)
If[ipos1===ipos2,Return[{1,t2}]];

sign=If[ipos2>ipos1,
(*commute pos2 backwards*)
Table[
FMinus[{t2[[1,ipos2]],t2[[1,ipos2-idx]]},{t2[[2,ipos2]],t2[[2,ipos2-idx]]}]
,{idx,1,ipos2-ipos1}],
(*commute pos2 forwards*)
Table[
FMinus[{t2[[1,ipos2]],t2[[1,ipos2+idx]]},{t2[[2,ipos2]],t2[[2,ipos2+idx]]}]
,{idx,1,ipos1-ipos2}]
];
(*Resolve the resulting FMinus, if possible*)
sign=Times@@ReduceIndices[setup,FTerm@@sign];

(*Replace the indices & fields in t2*)
newt2=Head[t2][
Insert[Delete[t2[[1]],ipos2],t2[[1,ipos2]],ipos1],
Insert[Delete[t2[[2]],ipos2],t2[[2,ipos2]],ipos1]
];

Return[{sign,newt2}];
];


(* ::Input::Initialization:: *)
TermsEqualAndSum::undeterminedFields="Error: Cannot equate terms if they are not fully truncated, i.e. contain instances of AnyField.";

TermsEqualAndSum[setup_,it1_FTerm,it2_FTerm]:=Module[
{t1=ReduceIndices[setup,it1],t2=ReduceIndices[setup,it2],
startPoints,doFields,
allObjt1,allObjt2,
cidxt1,cidxt2,oidxt1,oidxt2,
startt1,startt1fields,cidxstartt1,
startt2,nstartt2,startt2fields,cidxstartt2,branchAllObjt2,
idx,jdx,equal=False,startsign,a,factor,removeOther},

(*If[MemberQ[t1,AnyField,Infinity],Message[TermsEqualAndSum::undeterminedFields];Abort[]];*)

(*Briefly check the trivial case*)
If[it1===it2,Return@FTerm[2,t1]];

(*Get all the possible starting points for the search*)
startPoints = StartPoints[setup,t1,t2];
If[Not[startPoints[[1]]],Return[False]];

doFields=replFields[setup];

(*collect objects for both terms*)
allObjt1=Select[ExtractObjectsWithIndex[setup,t1]/.doFields,FreeQ[FMinus[__]]];
allObjt2=Select[ExtractObjectsWithIndex[setup,t2]/.doFields,FreeQ[FMinus[__]]];
cidxt1=GetClosedSuperIndices[setup,t1];
cidxt2=GetClosedSuperIndices[setup,t2];
oidxt1=GetOpenSuperIndices[setup,t1];
oidxt2=GetOpenSuperIndices[setup,t2];

(*We pick the first candidate for t1 and iterate over all candidates for t2.*)
startt1=startPoints[[2,1]];
(*starting indices can only be closed indices! We pick these out with the following 4 commands*)
startt1fields=startt1[[1]];
cidxstartt1=Map[MemberQ[cidxt1,makePosIdx@#]&,startt1[[2]]];
startt1fields=Pick[startt1fields,cidxstartt1];
cidxstartt1=makePosIdx/@Pick[startt1[[2]],cidxstartt1];

(*Sanity check*)
If[Length[cidxstartt1]===0,Return[False]];

FunKitDebug[3,"Comparing the terms \n  ",t1,"\n  ",t2];

(*If the terms are equal for any starting candidates for t2, we have succeeded*)
For[idx=1,idx<=Length[startPoints[[3]]],idx++,
(*We need to identify all possible insertion points in t2 that fit the insertion in t1*)
startt2=startPoints[[3,idx]];
(*starting indices can only be 1. closed indices 2. have same field content as the starting point in t1. We pick these out with the following 2 commands*)
cidxstartt2=Map[(MemberQ[cidxt2,#[[1]]]&&#[[2]]===startt1fields[[1]])&,Transpose[{makePosIdx/@startt2[[2]],startt2[[1]]}]];
cidxstartt2=Pick[makePosIdx/@startt2[[2]],cidxstartt2];

(*Loop over all possible starting indices*)
For[jdx=1,jdx<=Length[cidxstartt2],jdx++,
(*re-order the starting point so that it fits the first.*)
{startsign,nstartt2}=RearrangeFields[setup,startt1,startt2,{cidxstartt1[[1]],cidxstartt2[[jdx]]}];
FunKitDebug[3,"Starting sign: ",startsign];
branchAllObjt2=allObjt2/.startt2->nstartt2;
(*iterate the diagram*)
FunKitDebug[3,"StartPoints: \n  ",startt1,"\n  ",nstartt2];
FunKitDebug[3,"StartIndices: \n  ",cidxstartt1[[1]],"\n  ",cidxstartt2[[jdx]]];
{equal,branchAllObjt2}=TermsEqualAndSum[setup,t1,t2,
allObjt1,cidxt1,oidxt1,{startt1},cidxstartt1[[1]],
branchAllObjt2,cidxt2,oidxt2,{nstartt2},cidxstartt2[[jdx]],startsign
];
FunKitDebug[3,"Finished pass ",jdx " with equal=",equal];

(*If we found an equality, break out*)
If[equal=!=False,Break[]];
];

If[equal=!=False,Break[]];
];

(*If equal===False, the terms are clearly not equal*)
If[equal===False,Return[False]];

FunKitDebug[3,"Found two equal terms"];

removeOther=Dispatch[{Alternatives@@Map[Blank,$allObjects\[Union]{FDOp}]->1,Alternatives@@Map[Blank,GetAllFields[setup]\[Union]{AnyField}]->1}];

(*No need to do any ordering if there are no explicit Grassmanns in the expression*)
If[GrassmannCount[setup,t1]===0,
factor=(equal*Times@@(t2/.removeOther)+Times@@(t1/.removeOther))/Times@@(t1/.removeOther);
FunKitDebug[3,"With prefactor: ",factor];
Return@FTerm[factor,t1];
];

Print["Could not resolve Grassmann factors"];Abort[];
Return@FTerm[standardOrderGrassmanns[t1][[1]]*standardOrderGrassmanns[t2][[1]]*
(equal*(Times@@t2)+(Times@@t1))/(Times@@t1)/.Alternatives@@Map[Blank,$allObjects\[Union]{FDOp}]->1/.Alternatives@@Map[Blank,GetAllFields[setup]]->1,t1];
];


(* ::Input::Initialization:: *)
FTermContent[setup_,term_FTerm]:=Module[{},
Hash[
Sort@Map[Head[#][#[[1]]]&,
FunKit`Private`ExtractObjectsWithIndex[setup,term]/.FunKit`Private`replFields[setup]
]
,"SHA"]
];


(* ::Input::Initialization:: *)
SeparateTermGroups[setup_,expr_FEq]:=Module[{ret=List@@expr,identifierRep,removeFirsts,groupedDiagrams},

(*We group all diagrams into groups that could be potentially identical.
We simply make sure that in each group all diagrams have the same objects.*)
identifierRep=Map[FTermContent[setup,#]&,ret];
identifierRep=Thread[{identifierRep,ret}];
removeFirsts[ex_]:=Map[#[[2]]&,ex];
groupedDiagrams=(FEq@@#)&/@Map[removeFirsts,GatherBy[identifierRep,#[[1]]&]];
FunKitDebug[2,"Separated into ",Length[groupedDiagrams]," groups."];
Return[groupedDiagrams]
];


(* ::Input::Initialization:: *)
SubFSimplify[setup_,expr_FEq]:=Module[
{ret=List@@expr,idx,jdx,red},

For[idx=1,idx<=Length[ret],idx++,
For[jdx=idx+1,jdx<=Length[ret],jdx++,
red=TermsEqualAndSum[setup,ret[[idx]],ret[[jdx]]];
If[red=!=False,
ret[[idx]]=red;
ret=Delete[ret,jdx];
jdx--;
];
];
];
Return[FEq@@ret];
];


(* ::Input::Initialization:: *)
BuildSymmetryList[setup_,symmetries_,derivativeList_]:=Module[{procDerList,buildOneSymmetry},
If[Head[symmetries]=!=List,Print["Symmetries must be given as a list!"];Abort[]];
If[Length[symmetries]==0,Return[{}]];
If[Length[derivativeList]==0,Return[{}]];

procDerList=derivativeList/.unreplFields[setup];

buildOneSymmetry[sym_]:=Module[{valid=True,buildCycle,pairs},
If[AnyTrue[sym[[;;-2]],Not[Head[#]===List]&],valid=False];
pairs=Subsets[sym[[;;-2]],{2}];
valid=Not@AnyTrue[Map[ContainsAny[#[[1]],#[[2]]]&,pairs],Identity];
If[Not@valid,Print[sym," is  not a valid symmetry!"];Abort[]];

buildCycle[cyc_]:=Module[{cycvalid=True,numberRules,idx,nextIdx},
If[AnyTrue[cyc,Not[IntegerQ[#]]&],cycvalid=False];
If[AnyTrue[cyc,(#>Length[derivativeList])||(#<1)&],cycvalid=False];
If[Not@cycvalid,Print[cyc," is  not a valid cycle!"];Abort[]];

numberRules={};
For[idx=1,idx<=Length[cyc],idx++,
nextIdx=Mod[(idx),Length[cyc]]+1;
numberRules=Join[numberRules,{{cyc[[idx]],cyc[[nextIdx]]}}];
];

Return[Map[procDerList[[#[[1]],1]]->procDerList[[#[[2]],1]]&,numberRules]];
];

<|
"Rule"->Flatten[Map[buildCycle,sym[[;;-2]]],1],
"Factor"->sym[[-1]]
|>
];

Return@Join[{<|
"Rule"->{},
"Factor"->1
|>},
Map[buildOneSymmetry,symmetries/.Cycles->Identity]
];
];

SubFSimplify[setup_,expr_FEq,symmetryList_]:=Module[
{ret=List@@expr,idx,jdx,kdx,red},

For[idx=1,idx<=Length[ret],idx++,
For[jdx=idx+1,jdx<=Length[ret],jdx++,
For[kdx=1,kdx<=Length[symmetryList],kdx++,
red=symmetryList[[kdx,Key["Factor"]]]*TermsEqualAndSum[setup,ret[[idx]],ret[[jdx]]/.symmetryList[[kdx,Key["Rule"]]]];
If[red=!=False,
ret[[idx]]=red;
ret=Delete[ret,jdx];
jdx--;kdx=Length[symmetryList]+1;
];
];
];
];
Return[FEq@@ret];
];

FSimplifyNoSym[setup_,expr_FEq]:=Module[{subGroups,res},
FunKitDebug[1,"Simplifying diagrammatic expression of length ",Length[expr]];
subGroups=SeparateTermGroups[setup,expr];
res=FEq@@ParallelMap[SubFSimplify[setup,#]&,subGroups];
FunKitDebug[1,"FTerms before: ",Length[expr],", after: ",Length[res]];
Return[res];
];

Options[FSimplify]={"Symmetries"->{}};

FSimplify[setup_,expr_FEq,OptionsPattern[]]:=Module[{subGroups,res,symmetryList},
If[OptionValue["Symmetries"]==={},Return[FSimplifyNoSym[setup,expr]]];

FunKitDebug[1,"Simplifying diagrammatic expression of length ",Length[expr],"with symmetry list"];
subGroups=SeparateTermGroups[setup,expr];
symmetryList=BuildSymmetryList[setup,OptionValue["Symmetries"][[1]],AnyField[#]&/@OptionValue["Symmetries"][[2]]];
res=FEq@@ParallelMap[SubFSimplify[setup,#,symmetryList]&,subGroups];
FunKitDebug[1,"FTerms before: ",Length[expr],", after: ",Length[res]];
Return[res];
];


End[];
