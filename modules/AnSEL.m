(* ::Package:: *)

(* ::Title:: *)

(*AnSEL - Analysis and Simplification of Equations with Loops*)

(* ::Section:: *)

(*Exports*)

(* ::Input::Initialization:: *)

SetLoopMomentumName::usage = "SetLoopMomentumName[name]
Sets the base name for loop momentum variables used in functional calculations.
The name should be a string (e.g., \"l\", \"k\", \"q\") that will be used to generate loop momenta l1, l2, l3, etc.
Also creates fermionic variants (lf1, lf2, ...) and bosonic variants for different loop types.
Default setting is \"l\".";

FRoute::usage = "FRoute[setup, expr]
Routes indices and momenta in functional expressions, organizing terms by loop order.
For FTerm expressions, returns an Association with keys \"Expression\", \"ExternalIndices\", and \"LoopMomenta\".
For FEx expressions, returns an Association with keys like \"0-Loop\", \"1-Loop\", \"2-Loop\", etc.
Automatically enforces momentum conservation and assigns unique loop momentum variables.
Essential for organizing diagrammatic calculations by perturbative order.";

FUnroute::usage = "FUnroute[setup, expr]
Reverses the index and momentum routing performed by FRoute.
Converts routed expressions (with explicit momenta and indices) back to superindex notation.
Can handle both individual loop-order associations and complete routed expressions.
Used when you need to go back from explicit momentum space to abstract superindex form.";

FSimplify::usage = "FSimplify[setup, expr]
Simplifies functional expressions by identifying and combining identical terms.
Uses sophisticated diagram comparison algorithms to detect terms that differ only by index relabeling.
FSimplify[setup, expr, \"Symmetries\" -> symmetries] allows specifying symmetries to enhance simplification.
Significantly reduces the number of terms in complex functional calculations.
Essential for making large diagrammatic expressions manageable.";

loopMomentum::usage = "loopMomentum[momentum, isGrassmann]
Internal representation for loop momentum variables during the routing process.
The first argument is the momentum symbol, the second indicates whether it's Grassmann (True) or commuting (False).
This is automatically generated by FRoute and should not be used directly by users.
Gets converted to standard momentum notation (l1, l2, lf1, lf2, etc.) at the end of routing.";

externalMomentum::usage = "externalMomentum[momentum, isGrassmann]
Internal representation for external momentum variables during the routing process.
The first argument is the momentum symbol, the second indicates whether it's Grassmann (True) or commuting (False).
This is automatically generated by FRoute and should not be used directly by users.
Gets converted to standard momentum notation at the end of routing.";

(* ::Section::Closed:: *)

(*Begin Private*)

Begin["`Private`"];

(* ::Section:: *)

(*Global setup redefinitions*)

(* ::Input::Initialization:: *)

FRoute[expr_FEx] /; Head[$GlobalSetup] =!= Symbol :=
    FRoute[$GlobalSetup, expr];

FUnroute[expr_] /; Head[$GlobalSetup] =!= Symbol :=
    FUnroute[$GlobalSetup, expr];

FSimplify[expr_FEx] /; Head[$GlobalSetup] =!= Symbol :=
    FSimplify[$GlobalSetup, expr];

FSimplify[expr_FEx, OptionsPattern[]] /; Head[$GlobalSetup] =!= Symbol :=
    FSimplify[$GlobalSetup, expr, (Sequence @@ Thread[Rule @@ {#, OptionValue[FSimplify, #]}]& @ Keys[Options[FSimplify]])];

(* ::Section:: *)

(*Global variables*)

(* ::Input::Initialization:: *)

ModuleLoaded::dependency = "The module `1` requires `2`, which has not been loaded.";

If[ModuleLoaded[FunKit] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FunKit"];
    Abort[];
];

If[ModuleLoaded[FEDeriK] =!= True,
    Message[ModuleLoaded::dependency, "AnSEL", "FEDeriK"];
    Abort[];
];

ModuleLoaded[AnSEL] = True;

(* ::Input::Initialization:: *)

SetLoopMomentumName[name_String] :=
    Module[{},
        If[StringQ[$loopMomentumName],
            Unprotect @@ Table[$loopMomentumName <> ToString[idx], {idx, 1, 50}];
            Unprotect @@ Table[$loopMomentumName <> "f" <> ToString[idx], {idx, 1, 50}];
            Unprotect @@ Table[$loopMomentumName <> "fb" <> ToString[idx], {idx, 1, 50}];
        ];
        $loopMomentumName = name;
        ClearAll @@ Table[$loopMomentumName <> ToString[idx], {idx, 1, 50}];
        ClearAll @@ Table[$loopMomentumName <> "f" <> ToString[idx], {idx, 1, 50}];
        ClearAll @@ Table[$loopMomentumName <> "fb" <> ToString[idx], {idx, 1, 50}];
        Protect @@ Table[$loopMomentumName <> ToString[idx], {idx, 1, 50}];
        Protect @@ Table[$loopMomentumName <> "f" <> ToString[idx], {idx, 1, 50}];
        Protect @@ Table[$loopMomentumName <> "fb" <> ToString[idx], {idx, 1, 50}];
        Unprotect[$availableLoopMomenta, $availableLoopMomentaf, $availableLoopMomentafb];
        $availableLoopMomenta := Table[Symbol[$loopMomentumName <> ToString[idx]], {idx, 1, 50}];
        $availableLoopMomentaf := Table[Symbol[$loopMomentumName <> "f" <> ToString[idx]], {idx, 1, 50}];
        $availableLoopMomentafb := Table[Symbol[$loopMomentumName <> "fb" <> ToString[idx]], {idx, 1, 50}];
        Protect[$availableLoopMomenta, $availableLoopMomentaf, $availableLoopMomentafb];
    ];

SetLoopMomentumName["l"];

(* ::Section:: *)

(*Index routing*)

(* ::Input::Initialization:: *)

(*A convenience function to quickly obtain the index structure of a given field.*)

FieldSetupIndices[setup_, field_] :=
    Module[{},
        List @@ SelectFirst[Flatten @ Values[setup["FieldSpace"]], Head[#] === field&]
    ];

(* ::Input::Initialization:: *)

FRoute::undeterminedFields = "Cannot route indices in expressions with undetermined fields.";

FRoute::momentaFailed = "Cannot route momenta in the given expression. Final momentum conservation read `1`";

FRoute::conservationFail = "Momentum conservation could not be fulfilled. Error in `1`.
Full Expression:
    `2`";

(*detect if we should route into a fermionic loopMomentum (True) or a bosonic one (False)*)

fermionicExtMomRouting[setup_, vertex_] :=
    Module[{momsum, factor},
        momsum = Total[vertex[[2, All, 1]]];
        (*for this, we can set all external momenta with fermions equal and all external momenta with bosons to 0*)
        momsum = momsum //. externalMomentum[p_, True] :> externalMomentum[1, True] //. externalMomentum[p_, False] :> 0;
        (*Extract the prefactor of externalMomentum[1, True] (or 0, if it does not appear)*)
        momsum = Flatten[momsum /. Plus[a_, b__] :> List[a, b]];
        factor =
            Cases[
                momsum
                ,
                Times[c___, externalMomentum[1, True]] | externalMomentum[1, True] :>
                    If[Length[{c}] > 0,
                        Times[c]
                        ,
                        1
                    ]
            ];
        factor =
            If[Length[factor] > 0,
                Total[factor]
                ,
                0
            ];
        Return[Mod[factor, 2] === 1];
    ];

FRoute[setup_, expr_FTerm] :=
    Module[{openIndices, closedIndices, objects, ret = ReduceFTerm[setup, ReduceIndices[setup, expr]], doFields, idx, a, indPos, assocField, subObj, subMom, subExtMom, indStruct, externalIndices, externalMomenta, kind, f, momRepl, i, mom, loopMomenta, sidx, discard, rightMomenta, closedIndex, nextObj, tmp, flag},
        FunKitDebug[1, "FRoute: routing the sub-term ", expr];
        (*We first get all closed, open indices and all indexed objects. *)
        doFields = replFields[setup];
        openIndices = Sort @ GetOpenSuperIndices[setup, ret];
        closedIndices = GetClosedSuperIndices[setup, ret];
        objects = ExtractObjectsWithIndex[setup, ret] //. doFields;
        (*If there are any undetermined fields, we cannot route indices. *)
        If[MemberQ[objects[[All, 1]], AnyField, {1, 4}],
            Message[FRoute::undeterminedFields];
            Abort[]
        ];
        (*We need to reorder the objects list. In particular, (if possible) the next object should always share a closed index with the one before it.*)
        Do[
            subObj = objects[[idx]];
            (*find the closed index in the subObj*)
            closedIndex = Cases[subObj[[2]], x_ /; MemberQ[closedIndices, x], Infinity];
            (*find the first object after with a shared closedIndex*)
            nextObj = Select[objects[[idx + 1 ;; ]], ContainsAny[makePosIdx /@ #[[2]], closedIndex]&];
            If[Length[nextObj] === 0,
                Continue[]
            ];
            nextObj = FirstPosition[objects, nextObj[[1]]];
            (*Swap the object right after with nextObj*)
            If[nextObj =!= "NotFound" && nextObj[[1]] =!= idx + 1,
                FunKitDebug[2, "  FRoute: Swapping objects at positions ", idx + 1, " and ", nextObj];
                tmp = objects[[idx + 1]];
                objects[[idx + 1]] = objects[[nextObj]];
                objects[[nextObj]] = tmp;
            ]
            ,
            {idx, 1, Length[objects] - 1}
        ];
        (*Now, momenta. As a first step, we insert the correct index structures into all superindices and define momentum variables at every single vertex. We loop over all closed indices.*)
        Do[
            (*The indexed object we currently modify. There are always two and we simply grab the first. *)subObj = Select[objects, MemberQ[#, closedIndices[[idx]], Infinity]&][[1]];
            (*The position of the current index inside the subObj*)
            indPos = FirstPosition[subObj[[2]], closedIndices[[idx]]][[1]];
            (*See what kind of field is associated with the index*)
            assocField = subObj[[1, indPos]];
            (*Grab the index structure of this field from the setup and assign a new momentum variable*)
            indStruct =
                Map[
                    If[MatchQ[#, _Symbol],
                        Unique[SymbolName[#]]
                        ,
                        #
                    ]&
                    ,
                    FieldSetupIndices[setup, assocField]
                    ,
                    {1, 3}
                ];
            indStruct[[1]] = loopMomentum[indStruct[[1]], IsGrassmann[setup, assocField]];
            (* replace all occurences of the superindex with the fitting index structure. *)
            (* We want to keep the index sign in the momenta, but remove it from the group indices *)
            ret = ret /. closedIndices[[idx]] -> indStruct;
            objects = objects /. closedIndices[[idx]] -> indStruct;
            If[Length[indStruct] > 1,
                ret = ret /. (-indStruct[[2]]) -> indStruct[[2]];
                objects = objects /. (-indStruct[[2]]) -> indStruct[[2]];
            ];
            ,
            {idx, 1, Length[closedIndices]}
        ];
(*Next, we treat the external superindices. We assign to each an open group structure and a new momentum p1,p2,... 
Momentum conservation is already enforced here, i.e. \!\(
\*SubscriptBox[\(\[Sum]\), \(i\)]
\*SubscriptBox[\(p\), \(i\)]\)=0 and we choose Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]\(
\*SubscriptBox[\(p\), \(i\)]\ for\ the\ last\ momentum\ \(
\*SubscriptBox[\(p\), \(n\)]\(.\)\)\)\)*)
        externalIndices = Table[{}, {idx, 1, Length[openIndices]}];
        Do[
            (*see above*)subObj = Select[objects, MemberQ[#, openIndices[[idx]], Infinity]&][[1]];
            indPos = FirstPosition[subObj[[2]], openIndices[[idx]]][[1]];
            assocField = subObj[[1, indPos]];
            indStruct =
                Map[
                    If[MatchQ[#, _Symbol],
                        Symbol[SymbolName[#] <> ToString[idx]]
                        ,
                        #
                    ]&
                    ,
                    FieldSetupIndices[setup, assocField]
                    ,
                    {1, 3}
                ];
(*Subscript[p, n]=-\!\(
\*SubscriptBox[\(\[Sum]\), \(i < n\)]
\*SubscriptBox[\(p\), \(i\)]\)*)
            If[idx === Length[openIndices],
                indStruct[[1]] = -Total[Values[externalIndices][[ ;; idx - 1, 1]]]
                ,
                indStruct[[1]] = externalMomentum[indStruct[[1]], IsGrassmann[setup, assocField]];
            ];
            (*Wrap the momenta in externalMomentum[...]*)
            (*Do the replacements*)
            ret = ret /. (-openIndices[[idx]]) -> indStruct;
            ret = ret /. (openIndices[[idx]]) -> indStruct;
            objects = objects /. (-openIndices[[idx]]) -> indStruct;
            objects = objects /. openIndices[[idx]] -> indStruct;
            (*This is information for the user, which we will return.    *)
            externalIndices[[idx]] = openIndices[[idx]] -> indStruct;
            ,
            {idx, 1, Length[openIndices]}
        ];
        (*extract a list of all new external momenta*)
        externalMomenta = Values[externalIndices][[All, 1]];
        FunKitDebug[2, "  FRoute: Determined external momenta as ", externalMomenta];
        (*Now, we do the momentum routing. We iterate over all objects in subObj and fully resolve them.*)
        Do[
            subObj = objects[[idx]];
            subMom = subObj[[2, All, 1]];
            (*See if the object has any external (sub-)momenta*)
            subExtMom = Select[subMom, (ContainsAny[externalMomenta, makePosIdx /@ Flatten[{# /. Plus[a_, b__] :> List[a, b]}]])&];
            FunKitDebug[3, "  FRoute: routing the subObj ", subObj];
            FunKitDebug[3, "    FRoute: subExtMom are ", subExtMom];
            (*********************************************************************************)
            (* CASE 0: If momentum conservation is already fulfilled, do nothing *)
            (*********************************************************************************)
            If[Total @ subMom === 0,
                FunKitDebug[3, "      FRoute: Have only external momenta"];
                If[Total @ subObj[[2, All, 1]] =!= 0,
                    Message[FRoute::conservationFail, subObj, ret];
                    Abort[];
                ];
                Continue[]
            ];
            (*********************************************************************************)
            (*CASE 1: we have no external momentum anywhere in the legs of the subObject *)
            (*********************************************************************************)
            If[Length[subExtMom] === 0,
                (*If we have nothing to enforce, skip this object. This is the case for 1-Point functions*)
                If[Length[subObj[[2, All, 1]]] < 2,
                    Continue[]
                ];
                FunKitDebug[3, "      FRoute: No external momenta"];
                (*Grab the first loopMomentum that is fermionic*)
                tmp = subObj[[2, All]] //. loopMomentum[_, True] -> loopMomentum[1, True];
                f = Select[tmp, MemberQ[#, loopMomentum[_, True], Infinity]&];
                If[Length[f] =!= 0,
                    f = Position[tmp, f[[1]]][[1, 1]];
                    ,
                    (*Otherwise, we have no (purely) fermionic loop momenta, so just grab the first bosonic one*)
                    f = Select[subObj[[2, All]], MemberQ[#, loopMomentum[_, False], Infinity]&];
                    f = Position[subObj[[2]], f[[1]]][[1, 1]];
                ];
                (*Make a list of momenta out of the momentum sum in the subObj at position f *)
                tmp = makePosIdx /@ Flatten[{subObj[[2, f, 1]] //. {Plus[a_, b__] :> List[a, b], Times[a_loopMomentum, b__] :> List[a, b]}}];
                (*Grab one of the momenta which is a loopMomentum *)
                mom = Select[tmp, MatchQ[#, loopMomentum[_, True]]&];
                If[Length[mom] === 0,
                    mom = Select[tmp, MatchQ[#, loopMomentum[_, False]]&];
                ];
                mom = mom[[1]];
                (*Now create the replacement rule*)
                momRepl = Solve[Total[subObj[[2, All, 1]]] == 0, mom][[1, 1]];
                objects = objects /. momRepl;
                ret = ret /. momRepl;
                FunKitDebug[3, "      FRoute: routing a momentum as ", momRepl];
                Continue[];
            ];
            (*********************************************************************************)
            (*Case 2: We have both internal and external momenta *)
            (*********************************************************************************)
            If[Length[subExtMom] <= Length[subMom],
                FunKitDebug[3, "      FRoute: Have both internal and external momenta"];
                flag = fermionicExtMomRouting[setup, subObj];
                FunKitDebug[3, "        Are we routing a fermionic external momentum? ", flag];
                (*If we have a fermionic external momentum, we need to route it correctly. In that case, try to find a fermionic loopMomentum*)
                If[flag,
                    f = Select[subObj[[2, All]], MemberQ[#, loopMomentum[_, True], Infinity]&];
                    FunKitDebug[5, "        1. Chose f =  ", f];
                ];
                (*Otherwise, or, if we can't find a fermionic loopMomentum, pick a bosonic one*)
                If[Not @ flag || Length[f] === 0,
                    f = Select[subObj[[2, All]], MemberQ[#, loopMomentum[_, False], Infinity]&];
                    (* There's one more (nested) case: we have only fermionic loop Momenta, but no external fermionic one.*)
                    If[Length[f] === 0,
                        f = Select[subObj[[2, All]], MemberQ[#, loopMomentum[_, True], Infinity]&];
                    ];
                    FunKitDebug[5, "        2. Chose f =  ", f];
                ];
                f = Position[subObj[[2]], f[[1]]][[1, 1]];
                FunKitDebug[5, "        Final f =  ", f];
                (*Make a list of momenta out of the momentum sum in the subObj at position f *)
                tmp = makePosIdx /@ Flatten[{subObj[[2, f, 1]] //. {Plus[a_, b__] :> List[a, b], Times[a_loopMomentum, b__] :> List[a, b]}}];
                FunKitDebug[5, "        tmp =  ", tmp];
                (*Grab one of the momenta which is a loopMomentum *)
                If[flag,
                    mom = Select[tmp, MatchQ[#, loopMomentum[_, True]]&];
                ];
                If[Not @ flag || Length[mom] === 0,
                    mom = Select[tmp, MatchQ[#, loopMomentum[_, False]]&];
                    If[Length[mom] === 0,
                        mom = Select[tmp, MatchQ[#, loopMomentum[_, True]]&];
                    ];
                ];
                mom = mom[[1]];
                (*now build the replacement rule*)
                momRepl = Solve[Total[subObj[[2, All, 1]]] == 0, mom][[1, 1]];
                (*if the given momentum is NOT a fermionic one, we will need to replace all the momenta on the right-hand-side with NOT fermionic ones*)
                If[Not @ mom[[2]],
                    rightMomenta = Cases[momRepl[[2]], loopMomentum[__, True], Infinity] // DeleteDuplicates;
                    rightMomenta = Map[# -> Head[#][#[[1]], False]&, rightMomenta];
                    subObj = subObj /. rightMomenta;
                    objects = objects /. rightMomenta;
                    ret = ret /. rightMomenta;
                    momRepl = Solve[Total[subObj[[2, All, 1]]] == 0, mom][[1, 1]];
                ];
                objects = objects /. momRepl;
                ret = ret /. momRepl;
                FunKitDebug[3, "      FRoute: routing a momentum as ", momRepl];
                Continue[];
            ];
            ,
            {idx, 1, Length[objects]}
        ];
        (*Sanity check to see that we did not make an error*)
        Do[
            subObj = objects[[idx]];
            (*Skip again Fields and such*)
            If[Length[subObj[[2, All, 1]]] < 2,
                Continue[]
            ];
            (*Check the conservation of momentum at all vertices*)
            If[Total[subObj[[2, All, 1]]] =!= 0,
                Message[FRoute::momentaFailed, Total[subObj[[2, All, 1]]]];
                Abort[]
            ];
            ,
            {idx, 1, Length[objects]}
        ];
        (*replace the loopMomenta[...] by l1, l2, ...*)
        loopMomenta = Cases[objects[[All, 2, 1]], loopMomentum[__], Infinity] // DeleteDuplicates;
        kind =
            If[#[[2]],
                "f"
                ,
                ""
            ]&;
        (*Insert loop momenta*)
        ret = ret /. Thread[loopMomenta -> Table[Symbol[$loopMomentumName <> kind[loopMomenta[[idx]]] <> ToString[idx]], {idx, 1, Length[loopMomenta]}]];
        (*Insert external momenta*)
        ret = ret //. externalMomentum[p_, _] :> p;
        externalIndices = externalIndices //. externalMomentum[p_, _] :> p;
        loopMomenta = loopMomenta /. Thread[loopMomenta -> Table[Symbol[$loopMomentumName <> ToString[idx]], {idx, 1, Length[loopMomenta]}]];
        Return[<|"Expression" -> FEx[ret], "ExternalIndices" -> Sort @ externalIndices, "LoopMomenta" -> Sort @ loopMomenta|>];
    ];

makeMomentaAlternatives[mom_] :=
    Module[{idx},
        idx = StringSplit[SymbolName[mom], x:NumberString :> ToExpression @ x][[2]];
        Return[Alternatives[Symbol[$loopMomentumName <> ToString[idx]], Symbol[$loopMomentumName <> "f" <> ToString[idx]]]]
    ];

FRoute[setup_, expr_FEx] :=
    Module[{results, ret, idx, subidx},
        results = FRoute[setup, #]& /@ (List @@ expr);
        results = GatherBy[results, Length[#["LoopMomenta"]]&];
        results = Map[<|"Expression" -> FEx @@ #[[All, Key["Expression"]]], "ExternalIndices" -> #[[1, Key["ExternalIndices"]]], "LoopMomenta" -> makeMomentaAlternatives /@ #[[1, Key["LoopMomenta"]]]|>&, results];
        results = Association @@ Map[ToString[Length[#["LoopMomenta"]]] ~~ "-Loop" -> #&, results];
        Return[results];
    ];

(* ::Input::Initialization:: *)

isLoopAssociation[expr_] :=
    Module[{},
        If[Head[expr] =!= Association,
            Return[False]
        ];
        If[FreeQ[Keys[expr], "Expression"],
            Return[False]
        ];
        If[FreeQ[Keys[expr], "ExternalIndices"],
            Return[False]
        ];
        If[FreeQ[Keys[expr], "LoopMomenta"],
            Return[False]
        ];
        Return[True];
    ];

isRoutedAssociation[expr_] :=
    Module[{},
        If[Head[expr] =!= Association,
            Return[False]
        ];
        Return @ AllTrue[expr, isLoopAssociation]
    ];

(* ::Input::Initialization:: *)

FUnroute[setup_, assoc_Association] /; isLoopAssociation[assoc] :=
    Module[{},
        Return @ FUnroute[assoc["Expression"] /. Map[#[[2]] -> #[[1]]&, assoc["ExternalIndices"]]];
    ];

FUnroute[setup_, assoc_Association] /; isRoutedAssociation[assoc] :=
    FEx @@ (FUnroute[setup, #]& /@ (List @@ assoc));

FUnroute[setup_, term_FEx] :=
    FUnroute[setup, #]& /@ term;

FUnroute[setup_, term_FTerm] :=
    Module[{fw, bw},
        {fw, bw} = GetSuperIndexTermTransformations[setup, term];
        Return[term // fw];
    ];

(* ::Section:: *)

(*Identification of expressions*)

(* ::Input::Initialization:: *)

(*Get viable starting points for a comparison of two diagrams*)

StartPoints[setup_, t1_FTerm, t2_FTerm] :=
    Module[{obj1, obj2, count, desired, sList, match1, match2, cidx1, cidx2, doFields},
        doFields = replFields[setup];
        (*Get all sub-objects inside the terms*)
        obj1 = Reverse @ Sort @ ExtractObjectsWithIndex[setup, t1] /. doFields;
        obj2 = Reverse @ Sort @ ExtractObjectsWithIndex[setup, t2] /. doFields;
        FunKitDebug[4, "StartPoints: Comparing objects ", obj1, " and ", obj2];
        (*If the objects (with field content) do not match, they are not identical.*)
        If[Sort @ Map[Head[#][Sort @ #[[1]]]&, obj1] =!= Sort @ Map[Head[#][Sort @ #[[1]]]&, obj2],
            FunKitDebug[4, "Failed at object head check"];
            Return[{False, Null, Null}]
        ];
        cidx1 = GetClosedSuperIndices[setup, t1];
        cidx2 = GetClosedSuperIndices[setup, t2];
        If[Length[cidx1] =!= Length[cidx2],
            FunKitDebug[4, "Failed at closed index count check: ", Length[cidx1], " vs ", Length[cidx2]];
            Return[{False, Null, Null}]
        ];
(*
If[Length[cidx1]>0,
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
obj1=Select[obj1,ContainsAny[#[[2]],cidx1]&];
];*)
        (*Otherwise, we check which object is the "rarest"*)
        sList = Map[Head[#][#[[1]]]&, obj1];
        count = Counts[sList];
        desired = Keys[count][[PositionSmallest[Values[count]][[1]]]];
        match1 = Select[obj1, (Head[#][#[[1]]] === desired)&];
        match2 = Select[obj2, (Head[#][#[[1]]] === desired)&];
        (*return all possible starting points *)
        Return[{True, match1, match2}]
    ];

(* ::Input::Initialization:: *)

(*Find all objects following the closed indices attached to the object curPos*)

IterateDiagram[setup_Association, allObj_, closedIndices_, openIndices_, curPos_, entryIdx_] :=
    Module[{otherIndices, followObjects, i},
        FunKitDebug[4, "Inspecting: ", curPos];
        (*All indices except the one we entered with*)
        otherIndices = DeleteCases[makePosIdx /@ curPos[[2]], entryIdx];
        otherIndices = Intersection[otherIndices, closedIndices];
        FunKitDebug[4, "Found outgoing indices: ", otherIndices];
        (*all objects containing the otherIndices*)
        followObjects = Table[Select[DeleteCases[allObj, curPos], MemberQ[#[[2]], otherIndices[[i]], Infinity]&][[1]], {i, 1, Length[otherIndices]}];
        FunKitDebug[3, "Found followObjects: ", followObjects];
        Return[{otherIndices, followObjects}]
    ];

(* ::Input::Initialization:: *)

(*maximum accepted loop length.*)

$MaxIterLoop = 100;

TermsEqualAndSum::exceededLoopLimit = "Exceeded the maximum allowed length of a loop! (" <> ToString[$MaxIterLoop] <> ")";

TermsEqualAndSum::branchFailure = "Arrived at unhandled branch point";

TermsEqualAndSum[setup_, t1_, t2_, MallObjt1_, cidxt1_, oidxt1_, Mmemory1_, entry1_, MallObjt2_, cidxt2_, oidxt2_, Mmemory2_, entry2_, Msign2_] :=
    Module[{allObjt1 = MallObjt1, curIdx1, curPos1, nextInd1, nextPos1, memory1 = Mmemory1, assocFields1, allObjt2 = MallObjt2, curIdx2, curPos2, nextInd2, nextPos2, memory2 = Mmemory2, assocFields2, sign2 = Msign2, iter = 1, idx, jdx, viableBranches, branchSign, branchItRepl, branchObj, temp1, temp2},
        FunKitDebug[3, "Following along a chain of indices."];
        curIdx1 = makePosIdx @ entry1;
        curIdx2 = makePosIdx @ entry2;
        curPos1 = memory1[[-1]];
        curPos2 = memory2[[-1]];
        While[
            iter < $MaxIterLoop
            ,
            (*Take a single step forward in the terms*)
            {nextInd1, nextPos1} = IterateDiagram[setup, allObjt1, cidxt1, oidxt1, curPos1, curIdx1];
            {nextInd2, nextPos2} = IterateDiagram[setup, allObjt2, cidxt2, oidxt2, curPos2, curIdx2];
            (*If the (set of) next object(s) is different for 1 and 2, we can immediately abort.*)
            If[Sort @ Map[Head[#][Sort[#[[1]]]]&, nextPos1] =!= Sort @ Map[Head[#][Sort[#[[1]]]]&, nextPos2],
                FunKitDebug[3, "FAILURE ------------ Heads do not match: ", nextPos1, ", ", nextPos2];
                Return[{False, allObjt2}]
            ];
            (*Check if the external indices in the current object match *)
            If[Intersection[oidxt1, makePosIdx /@ (curPos1[[2]])] =!= Intersection[oidxt2, makePosIdx /@ (curPos2[[2]])],
                FunKitDebug[3, "FAILURE ------------ Current open indices disagree: ", Intersection[oidxt1, makePosIdx /@ (curPos1[[2]])], ", ", Intersection[oidxt2, makePosIdx /@ (curPos2[[2]])]];
                Return[{False, allObjt2}]
            ];
            FunKitDebug[3, "Next objects along the chain: ", nextPos1, ", ", nextPos2];
            FunKitDebug[3, "Entering through: ", nextInd1, ", ", nextInd2];
            (*Case 1: There is only a single object following*)
            If[Length[nextInd1] === 1,
                FunKitDebug[3, "Following the index chain."];
                (*Check if the open indices aggree*)
                If[Sort @ Intersection[oidxt1, makePosIdx /@ nextPos1[[1, 2]]] =!= Sort @ Intersection[oidxt2, makePosIdx /@ nextPos2[[1, 2]]],
                    FunKitDebug[3, "FAILURE ------------ Next open indices disagree.", Sort @ Intersection[oidxt1, makePosIdx /@ nextPos1[[1, 2]]], ", ", Sort @ Intersection[oidxt2, makePosIdx /@ nextPos2[[1, 2]]]];
                    Return[{False, allObjt2}]
                ];
                (*fix the current object*)
                {temp1, temp2} = RearrangeFields[setup, curPos1, curPos2, {nextInd1[[1]], nextInd2[[1]]}];
                sign2 = sign2 * temp1;
                allObjt2 = allObjt2 /. curPos2 -> temp2;
                memory2 = memory2 /. curPos2 -> temp2;
                curPos2 = temp2;
                (*fix the next object*)
                {temp1, temp2} = RearrangeFields[setup, nextPos1[[1]], nextPos2[[1]], {nextInd1[[1]], nextInd2[[1]]}];
                sign2 = sign2 * temp1;
                allObjt2 = allObjt2 /. nextPos2[[1]] -> temp2;
                memory2 = memory2 /. nextPos2[[1]] -> temp2;
                nextPos2[[1]] = temp2;
                (*Check if we closed a loop*)
                If[FirstPosition[memory1, nextPos1[[1]]] === FirstPosition[memory2, nextPos2[[1]]] && NumericQ[FirstPosition[memory1, nextPos1[[1]]][[1]]],
                    FunKitDebug[3, "SUCCESS ------------ Closed a loop."];
                    Return[{sign2, allObjt2}]
                ];
                (*Closed one loop, but not the other*)
                If[FirstPosition[memory1, nextPos1[[1]]] =!= FirstPosition[memory2, nextPos2[[1]]],
                    FunKitDebug[3, "FAILURE ------------ Closed only one loop."];
                    Return[{False, allObjt2}]
                ];
                (*step forward*)
                curIdx1 = nextInd1[[1]];
                curPos1 = nextPos1[[1]];
                curIdx2 = nextInd2[[1]];
                curPos2 = nextPos2[[1]];
                (*update the memory*)
                AppendTo[memory1, curPos1];
                AppendTo[memory2, curPos2];
                iter++;
                Continue[];
            ];
            (*Case 2: End of the line.*)
            If[Length[nextInd1] === 0,
                FunKitDebug[4, "Finished an index chain in (", curPos1, ", ", curPos2, ")"];
                (*We need to check if both expressions are with FDOps *)
                If[Head @ curPos1 === Field,
                    temp1 = Cases[t1, FDOp[curPos1[[1, 1]][curPos1[[2, 1]]]], Infinity];
                    temp2 = Cases[t2, FDOp[curPos2[[1, 1]][curPos2[[2, 1]]]], Infinity];
                    If[Length[temp1] =!= Length[temp2],
                        FunKitDebug[3, "FAILURE ------------ Number of FDOps is different."];
                        Return[{False, allObjt2}]
                    ];
                ];
                FunKitDebug[3, "SUCCESS ------------ Index chain ended with equality."];
                Return[{sign2, allObjt2}]
            ];
            (*Case 3: Branching point.*)
            If[Length[nextInd1] > 1,
                FunKitDebug[3, "Index chain is branching."];
                (*We need to build all possible combinations between the "next" indices and follow these separately, until one of them fits.*)
                assocFields1 = curPos1[[1, FirstPosition[curPos1[[2]], #][[1]]]]& /@ nextInd1;
                assocFields2 = curPos2[[1, FirstPosition[curPos2[[2]], #][[1]]]]& /@ nextInd2;
                viableBranches = Map[Transpose[{Transpose @ {nextInd1, assocFields1, nextPos1}, #}]&, Permutations[Transpose @ {nextInd2, assocFields2, nextPos2}]];
                viableBranches = Select[viableBranches, AllTrue[#, (#[[1, 2]] === #[[2, 2]])&]&];
                FunKitDebug[4, "Viable Branches: ", viableBranches];
                For[idx = 1, idx <= Length[viableBranches], idx++,
                    branchSign = sign2;
                    branchObj = allObjt2;
                    Do[
                        (*Fix the outgoing objects*){branchSign, branchItRepl} = RearrangeFields[setup, curPos1, curPos2, viableBranches[[idx, jdx, All, 1]]];
                        (*Fix the incoming objects*)
                        {temp1, temp2} = RearrangeFields[setup, viableBranches[[idx, jdx, 1, 3]], viableBranches[[idx, jdx, 2, 3]], viableBranches[[idx, jdx, All, 1]]];
                        branchSign = temp1 * branchSign;
                        branchObj = branchObj /. curPos2 -> branchItRepl;
                        branchObj = branchObj /. viableBranches[[idx, jdx, 2, 3]] -> temp2;
                        viableBranches[[idx, jdx, 2, 3]] = temp2;
                        FunKitDebug[4, "Branching at ", branchObj];
                        {branchSign, branchObj} = TermsEqualAndSum[setup, t1, t2, allObjt1, cidxt1, oidxt1, Append[memory1, viableBranches[[idx, jdx, 1, 3]]], viableBranches[[idx, jdx, 1, 1]], branchObj, cidxt2, oidxt2, Append[memory2 /. curPos2 -> branchItRepl, viableBranches[[idx, jdx, 2, 3]]], viableBranches[[idx, jdx, 2, 1]], branchSign];
                        If[branchSign === False,
                            Break[]
                        ];
                        ,
                        {jdx, 1, Length[viableBranches[[idx]]]}
                    ];
                    If[branchSign === False,
                        Continue[]
                    ];
                    FunKitDebug[3, "SUCCESS ------------ Branch ", idx, " succeeded, branchSign is ", branchSign];
                    Return[{branchSign, branchObj}];
                ];
                FunKitDebug[3, "FAILURE ------------ Branch failed."];
                Return[{False, allObjt2}];
            ];
            (*Nothing should lead here*)
            Message[TermsEqualAndSum::branchFailure];
            Abort[];
        ];
        (*Nothing should lead here*)
        Message[TermsEqualAndSum::exceededLoopLimit];
        Abort[];
    ];

(* ::Input::Initialization:: *)

RearrangeFields[setup_, t1_, t2_, equiv_] :=
    Module[
        {ipos1, ipos2, idx, sign, newt2}
        ,
        (*re-order the fields in an indexed object t2 so that it fits the order in t1. Returns both the sign and the reordered t2*)
        ipos1 = FirstPosition[makePosIdx /@ t1[[2]], equiv[[1]]][[1]];
        ipos2 = FirstPosition[makePosIdx /@ t2[[2]], equiv[[2]]][[1]];
        (*nothing to do:*)
        If[ipos1 === ipos2,
            Return[{1, t2}]
        ];
        sign =
            If[ipos2 > ipos1,
                (*commute pos2 backwards*)
                Table[FMinus[{t2[[1, ipos2]], t2[[1, ipos2 - idx]]}, {t2[[2, ipos2]], t2[[2, ipos2 - idx]]}], {idx, 1, ipos2 - ipos1}]
                ,
                (*commute pos2 forwards*)
                Table[FMinus[{t2[[1, ipos2]], t2[[1, ipos2 + idx]]}, {t2[[2, ipos2]], t2[[2, ipos2 + idx]]}], {idx, 1, ipos1 - ipos2}]
            ];
        (*Resolve the resulting FMinus, if possible*)
        sign = Times @@ ReduceIndices[setup, FTerm @@ sign];
        (*Replace the indices & fields in t2*)
        newt2 = Head[t2][Insert[Delete[t2[[1]], ipos2], t2[[1, ipos2]], ipos1], Insert[Delete[t2[[2]], ipos2], t2[[2, ipos2]], ipos1]];
        Return[{sign, newt2}];
    ];

(* ::Input::Initialization:: *)

TermsEqualAndSum::undeterminedFields = "Error: Cannot equate terms if they are not fully truncated, i.e. contain instances of AnyField.";

TermsEqualAndSum[setup_, it1_FTerm, it2_FTerm] :=
    Module[
        {t1 = ReduceIndices[setup, it1], t2 = ReduceIndices[setup, it2], startPoints, doFields, allObjt1, allObjt2, cidxt1, cidxt2, oidxt1, oidxt2, startt1, startt1fields, cidxstartt1, startt2, nstartt2, startt2fields, cidxstartt2, branchAllObjt2, idx, jdx, equal = False, startsign, a, factor, removeOther}
        ,
        (*If[MemberQ[t1,AnyField,Infinity],Message[TermsEqualAndSum::undeterminedFields];Abort[]];*)
        (*Briefly check the trivial case*)
        FunKitDebug[4, "    TermsEqualAndSum: Comparing \n  ", t1, "\n   &\n  ", t2];
        If[it1 === it2,
            Return @ FTerm[2, t1]
        ];
        If[t1[[2 ;; ]] === t2[[2 ;; ]],
            Return @ FTerm[t1[[1]] + t2[[1]], t1[[2 ;; ]]]
        ];
        If[t1[[2 ;; ]] === t2[[1 ;; ]],
            Return @ FTerm[t1[[1]] + 1, t1[[2 ;; ]]]
        ];
        If[t1[[1 ;; ]] === t2[[2 ;; ]],
            Return @ FTerm[1 + t2[[1]], t2[[2 ;; ]]]
        ];
        (*Get all the possible starting points for the search*)
        startPoints = StartPoints[setup, t1, t2];
        If[Not[startPoints[[1]]],
            FunKitDebug[3, "    No matching StartPoints could be identified"];
            Return[False]
        ];
        FunKitDebug[4, "Collected StartPoints"];
        doFields = replFields[setup];
        (*collect objects for both terms*)
        allObjt1 = Select[ExtractObjectsWithIndex[setup, t1] /. doFields, FreeQ[FMinus[__]]];
        allObjt2 = Select[ExtractObjectsWithIndex[setup, t2] /. doFields, FreeQ[FMinus[__]]];
        cidxt1 = GetClosedSuperIndices[setup, t1];
        cidxt2 = GetClosedSuperIndices[setup, t2];
        oidxt1 = GetOpenSuperIndices[setup, t1];
        oidxt2 = GetOpenSuperIndices[setup, t2];
        (*We pick the first candidate for t1 and iterate over all candidates for t2.*)
        startt1 = startPoints[[2, 1]];
        (*starting indices can only be closed indices! We pick these out with the following 4 commands*)
        startt1fields = startt1[[1]];
        cidxstartt1 = Map[MemberQ[cidxt1, makePosIdx @ #]&, startt1[[2]]];
        startt1fields = Pick[startt1fields, cidxstartt1];
        cidxstartt1 = makePosIdx /@ Pick[startt1[[2]], cidxstartt1];
        (*Sanity check*)
        If[Length[cidxstartt1] === 0,
            Return[False]
        ];
        FunKitDebug[3, "Comparing the terms \n  ", t1, "\n  ", t2];
        (*If the terms are equal for any starting candidates for t2, we have succeeded*)
        For[idx = 1, idx <= Length[startPoints[[3]]], idx++,
            (*We need to identify all possible insertion points in t2 that fit the insertion in t1*)startt2 = startPoints[[3, idx]];
            (*starting indices can only be 1. closed indices 2. have same field content as the starting point in t1. We pick these out with the following 2 commands*)
            cidxstartt2 = Map[(MemberQ[cidxt2, #[[1]]] && #[[2]] === startt1fields[[1]])&, Transpose[{makePosIdx /@ startt2[[2]], startt2[[1]]}]];
            cidxstartt2 = Pick[makePosIdx /@ startt2[[2]], cidxstartt2];
            (*Loop over all possible starting indices*)
            For[jdx = 1, jdx <= Length[cidxstartt2], jdx++,
                (*re-order the starting point so that it fits the first. *){startsign, nstartt2} = RearrangeFields[setup, startt1, startt2, {cidxstartt1[[1]], cidxstartt2[[jdx]]}];
                FunKitDebug[3, "Starting sign: ", startsign];
                branchAllObjt2 = allObjt2 /. startt2 -> nstartt2;
                (*iterate the diagram*)
                FunKitDebug[3, "StartPoints: \n  ", startt1, "\n  ", nstartt2];
                FunKitDebug[3, "StartIndices: \n  ", cidxstartt1[[1]], "\n  ", cidxstartt2[[jdx]]];
                {equal, branchAllObjt2} = TermsEqualAndSum[setup, t1, t2, allObjt1, cidxt1, oidxt1, {startt1}, cidxstartt1[[1]], branchAllObjt2, cidxt2, oidxt2, {nstartt2}, cidxstartt2[[jdx]], startsign];
                FunKitDebug[3, "Finished pass ", jdx, " with equal=", equal];
                (*If we found an equality, break out*)
                If[equal =!= False,
                    Break[]
                ];
            ];
            If[equal =!= False,
                Break[]
            ];
        ];
        (*If equal===False, the terms are clearly not equal*)
        If[equal === False,
            Return[False]
        ];
        FunKitDebug[3, "Found two equal terms"];
        removeOther = Dispatch[{Alternatives @@ Map[Blank, $allObjects \[Union] {FDOp}] -> 1, Alternatives @@ Map[Blank, GetAllFields[setup] \[Union] {AnyField}] -> 1}];
        (*No need to do any ordering if there are no explicit Grassmanns in the expression*)
        If[GrassmannCount[setup, t1] === 0,
            factor = (equal * Times @@ (t2 /. removeOther) + Times @@ (t1 /. removeOther)) / Times @@ (t1 /. removeOther);
            FunKitDebug[3, "With prefactor: ", factor];
            Return @ FTerm[factor, t1];
        ];
        Print[Style["FATAL: Could not resolve Grassmann factors", Red]];
        Abort[];
        Return @ FTerm[standardOrderGrassmanns[t1][[1]] * standardOrderGrassmanns[t2][[1]] * (equal * (Times @@ t2) + (Times @@ t1)) / (Times @@ t1) /. Alternatives @@ Map[Blank, $allObjects \[Union] {FDOp}] -> 1 /. Alternatives @@ Map[Blank, GetAllFields[setup]] -> 1, t1];
    ];

(* ::Input::Initialization:: *)

FTermContent[setup_, term_FTerm] :=
    Module[{},
        Hash[Sort @ Map[Head[#][#[[1]]]&, FunKit`Private`ExtractObjectsWithIndex[setup, term] /. FunKit`Private`replFields[setup]], "SHA"]
    ];

(* ::Input::Initialization:: *)

SeparateTermGroups[setup_, expr_FEx] :=
    Module[
        {ret = List @@ expr, identifierRep, removeFirsts, groupedDiagrams}
        ,
        (*We group all diagrams into groups that could be potentially identical. We simply make sure that in each group all diagrams have the same objects.*)
        identifierRep = Map[FTermContent[setup, #]&, ret];
        identifierRep = Thread[{identifierRep, ret}];
        removeFirsts[ex_] := Map[#[[2]]&, ex];
        groupedDiagrams = (FEx @@ #)& /@ Map[removeFirsts, GatherBy[identifierRep, #[[1]]&]];
        FunKitDebug[2, "Separated into ", Length[groupedDiagrams], " groups."];
        Return[groupedDiagrams]
    ];

(* ::Input::Initialization:: *)

SubFSimplify[setup_, expr_FEx] :=
    Module[{ret = List @@ expr, idx, jdx, red},
        For[idx = 1, idx <= Length[ret], idx++,
            For[jdx = idx + 1, jdx <= Length[ret], jdx++,
                red = TermsEqualAndSum[setup, ret[[idx]], ret[[jdx]]];
                FunKitDebug[3, "Comparing ", idx, " and ", jdx, ", result: ", red];
                If[red =!= False,
                    ret[[idx]] = red;
                    ret = Delete[ret, jdx];
                    jdx--;
                ];
            ];
        ];
        Return[FEx @@ ret];
    ];

(* ::Input::Initialization:: *)

BuildSymmetryList[setup_, symmetries_, derivativeList_] :=
    Module[{procDerList, buildOneSymmetry},
        If[Head[symmetries] =!= List,
            Print["Symmetries must be given as a list!"];
            Abort[]
        ];
        If[Length[symmetries] == 0,
            Return[{}]
        ];
        If[Length[derivativeList] == 0,
            Return[{}]
        ];
        procDerList = derivativeList /. unreplFields[setup];
        buildOneSymmetry[sym_] :=
            Module[{valid = True, buildCycle, pairs},
                If[AnyTrue[sym[[ ;; -2]], Not[Head[#] === List]&],
                    valid = False
                ];
                pairs = Subsets[sym[[ ;; -2]], {2}];
                valid = Not @ AnyTrue[Map[ContainsAny[#[[1]], #[[2]]]&, pairs], Identity];
                If[Not @ valid,
                    Print[sym, " is  not a valid symmetry!"];
                    Abort[]
                ];
                buildCycle[cyc_] :=
                    Module[{cycvalid = True, numberRules, idx, nextIdx},
                        If[AnyTrue[cyc, Not[IntegerQ[#]]&],
                            cycvalid = False
                        ];
                        If[AnyTrue[cyc, (# > Length[derivativeList]) || (# < 1)&],
                            cycvalid = False
                        ];
                        If[Not @ cycvalid,
                            Print[cyc, " is  not a valid cycle!"];
                            Abort[]
                        ];
                        numberRules = {};
                        For[idx = 1, idx <= Length[cyc], idx++,
                            nextIdx = Mod[(idx), Length[cyc]] + 1;
                            numberRules = Join[numberRules, {{cyc[[idx]], cyc[[nextIdx]]}}];
                        ];
                        Return[Map[procDerList[[#[[1]], 1]] -> procDerList[[#[[2]], 1]]&, numberRules]];
                    ];
                <|"Rule" -> Flatten[Map[buildCycle, sym[[ ;; -2]]], 1], "Factor" -> sym[[-1]]|>
            ];
        Return @ Join[{<|"Rule" -> {}, "Factor" -> 1|>}, Map[buildOneSymmetry, symmetries /. Cycles -> Identity]];
    ];

SubFSimplify[setup_, expr_FEx, symmetryList_] :=
    Module[{ret = List @@ expr, idx, jdx, kdx, red},
        For[idx = 1, idx <= Length[ret], idx++,
            For[jdx = idx + 1, jdx <= Length[ret], jdx++,
                For[kdx = 1, kdx <= Length[symmetryList], kdx++,
                    red = symmetryList[[kdx, Key["Factor"]]] * TermsEqualAndSum[setup, ret[[idx]], ret[[jdx]] /. symmetryList[[kdx, Key["Rule"]]]];
                    If[red =!= False,
                        ret[[idx]] = red;
                        ret = Delete[ret, jdx];
                        jdx--;
                        kdx = Length[symmetryList] + 1;
                    ];
                ];
            ];
        ];
        Return[FEx @@ ret];
    ];

FSimplifyNoSym[setup_, expr_FEx] :=
    Module[{
        subGroups
        ,
        res
        ,
        map =
            If[$FunKitDebugLevel >= 2,
                Map
                ,
                ParallelMap
            ]
    },
        FunKitDebug[1, "Simplifying diagrammatic expression of length ", Length[expr]];
        subGroups = SeparateTermGroups[setup, expr];
        res = FEx @@ map[SubFSimplify[setup, #]&, subGroups];
        FunKitDebug[1, "FTerms before: ", Length[expr], ", after: ", Length[res]];
        Return[res];
    ];

Options[FSimplify] = {"Symmetries" -> {}};

FSimplify[setup_, expr_FEx, OptionsPattern[]] :=
    Module[{
        subGroups
        ,
        res
        ,
        symmetryList
        ,
        map =
            If[$FunKitDebugLevel >= 2,
                Map
                ,
                ParallelMap
            ]
    },
        If[OptionValue["Symmetries"] === {},
            Return[FSimplifyNoSym[setup, expr]]
        ];
        FunKitDebug[1, "Simplifying diagrammatic expression of length ", Length[expr], "with symmetry list"];
        subGroups = SeparateTermGroups[setup, expr];
        symmetryList = BuildSymmetryList[setup, OptionValue["Symmetries"][[1]], AnyField[#]& /@ OptionValue["Symmetries"][[2]]];
        res = FEx @@ map[SubFSimplify[setup, #, symmetryList]&, subGroups];
        FunKitDebug[1, "FTerms before: ", Length[expr], ", after: ", Length[res]];
        Return[res];
    ];

(* ::Section::Closed:: *)

(*End Private*)

End[];
